/*!
GPII Settings Transformer

Copyright 2012 OCAD University
Copyright 2012 Antranig Basman
Copyright 2013-2014 Raising the Floor

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

The research leading to these results has received funding from the European Union's
Seventh Framework Programme (FP7/2007-2013) under grant agreement no. 289016.

You may obtain a copy of the License at
https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

"use strict";

var fluid = fluid || require("infusion"),
    $ = fluid.registerNamespace("jQuery"),
    gpii = fluid.registerNamespace("gpii");

(function () {

    fluid.defaults("gpii.transformer", {
        gradeNames: ["fluid.littleComponent", "autoInit"],
        invokers: {
            configurationToSettings: {
                funcName: "gpii.transformer.configurationToSettings",
                args: [ "{arguments}.0", "{arguments}.1" ]
            }
        }
    });

    /**
     * Helper function for `gpii.transformer.configurationToSettings`. Used to modify the settings handler
     * blocks to be in the format required (i.e. including the application specific settings to be
     * set) by the actual settings handlers. This modifies the block in place - it has already been copied by the
     * the caller
     *
     * @param settingsHandler {Object} - The settingsHandler information from the solutions registry to be transformed - MODIFIED IN PLACE
     * @param oneUserSolution {Object} - the user preferences related to this solution and settings handler
     * @param solutionId {Object} - the ID of the solution for which the settingshandler is related
     *
     * @return {Object} - the modified settingshandler object - ready to be passed to the lifecycle manager
     */
    gpii.transformer.transformOneSettingsHandler = function (settingsHandler, oneUserSolution, solutionId) {
        // TODO: throw app specific settings in the correct locations if there are multiple handlers
        var settings = fluid.copy(oneUserSolution.settings["http://registry.gpii.net/applications/" + solutionId]);

        if (settingsHandler.capabilitiesTransformations) {
            var inferred = fluid.model.transformWithRules(oneUserSolution.settings, settingsHandler.capabilitiesTransformations);
            settings = $.extend(true, inferred, settings);
        }

        settingsHandler.settings = settings;
        delete settingsHandler.capabilitiesTransformations;
        delete settingsHandler.capabilities;
        return settingsHandler;
    };

    /**
     * Converts a system configuration (output from the context manager from matchmaker output) to a format readable by the
     * lifecycle manager. This includes translation of common terms to application specific settings.
     * The following rules apply when doing this translation:
     * - the translation is based on the transformations in the solutionsRegistry entry
     * - if a common term transforms into a setting which is already specific as application specific
     *      in the configuration argument, the application specific takes priority. In other words:
     *      if the configuration contains both an application specific and (transformable) common
     *       term for some application setting, the application specific one will stay and the
     *      transformed will be discarded.
     *
     * @param configuration {Object} - An element of the matchmaker output payload for a particular context
     *      (by the context manager)
     * @param solutionsRegistry {Object} - a section of the solutions registry database, filtered for configured solutions (currently only done by OS and device context)
     *
     * @return An object isomorphic to the "configuration" with settings blocks transformed and evaluated - this is ready to be
     * dispatched to settings handlers
     */
    gpii.transformer.configurationToSettings = function (configuration, solutionsRegistryEntries) {
        var togo = fluid.transform(configuration.applications, function (oneUserSolution, solutionId) {
            var oneSolution = fluid.copy(solutionsRegistryEntries[solutionId]);
            if (oneSolution === undefined) {
                fluid.log("The configuration to be applied contains an entry for " + solutionId +
                    " which was not found in the solutionRegistry. Aborting configuration");
                return undefined;
            }
            delete oneSolution.contexts; // solutions registry entries should include this as "old device reporter context info"
            oneSolution.settingsHandlers = fluid.transform(oneSolution.settingsHandlers, function (settingsHandler) {
                return gpii.transformer.transformOneSettingsHandler(settingsHandler, oneUserSolution, solutionId);
            });
            return oneSolution;
            // TODO: take launching, etc., into consideration
        });

        //ensure no empty entries exist in the settings payload
        for (var i in togo) {
            if (togo[i] === undefined) {
                delete togo[i];
            }
        }
        return togo;
    };



    fluid.defaults("gpii.transformer.quantize", {
        gradeNames: "fluid.standardTransformFunction"
    });

    gpii.transformer.quantize = function (value, transformSpec, transform) {
        if (!transformSpec.ranges || !transformSpec.ranges.length) {
            fluid.fail("gpii.transformer.quantize should have a key called ranges containing an array defining ranges to quantize");
        }
        // TODO: error checking that upper bounds are all numbers and increasing
        for (var i = 0; i < transformSpec.ranges.length; i++) {
            var rangeSpec = transformSpec.ranges[i];
            if (value <= rangeSpec.upperBound || rangeSpec.upperBound === undefined && value >= Number.NEGATIVE_INFINITY) {
                return fluid.isPrimitive(rangeSpec.output) ? rangeSpec.output : transform.expand(rangeSpec.output);
            }
        }
    };

    fluid.defaults("gpii.transformer.booleanToNumber", {
        gradeNames: "fluid.standardTransformFunction"
    });

    gpii.transformer.booleanToNumber = function (value) {
        return value ? 1 : 0;
    };

    /**
     * inRange transformer checks whether a value is within a given range and returns true if it is,
     * and false if it's not.
     *
     * The range is defined by the two inputs: "min" and "max" (both inclusive). If one of these inputs
     * is not present it is considered -infinite and +infinite, respectively - In other words, if no
     * `min` value is defined, any value below or equal to the given "max" value will result in true.
     */
    fluid.defaults("gpii.transformer.inRange", {
        gradeNames: "fluid.standardTransformFunction"
    });

    gpii.transformer.inRange = function (value, transformSpec) {
        return (transformSpec.min === undefined || transformSpec.min <= value) &&
            (transformSpec.max === undefined ||  transformSpec.max >= value) ? true : false;
    };


    /**
     * timeInRange is implemented specifically for checking whether an input time falls in between
     * two given times. The valid and required inputs, besides the standard input/inputPath are `to`
     * and `from`. All inputs should be strings of the type "hh:mm" (eg. "17:30"). The range wraps
     * midnight, so given a `from` of "20:00" and a `to` of `"08:00"` all the following inputs would
     * result in true: "20:00", 23:00", "02:45".
     */
    fluid.defaults("gpii.transformer.timeInRange", {
        gradeNames: "fluid.standardTransformFunction"
    });


    gpii.transformer.timeInRange = function (value, transformSpec) {
        var timeInRange = gpii.transformer.timeInRange;
        var currentTime = timeInRange.timeParser(value);
        var fromTime = timeInRange.timeParser(transformSpec.from);
        var toTime = timeInRange.timeParser(transformSpec.to);

        if (timeInRange.isEarlier(toTime, fromTime)) { // if time wraps
            return (timeInRange.isEarlier(fromTime, currentTime) || timeInRange.isEarlier(currentTime, toTime));
        } else {
            return (timeInRange.isEarlier(fromTime, currentTime) && timeInRange.isEarlier(currentTime, toTime));
        }
    };

    gpii.transformer.timeInRange.timeParser = function (time) {
        time = time.split(":");
        return {
            hours: parseInt(time[0], 10),
            minutes: parseInt(time[1], 10)
        };
    };

    // checks whether 'first' is earlier than 'second' - returns true if so
    gpii.transformer.timeInRange.isEarlier = function (first, second) {
        return (60 * (first.hours - second.hours) + first.minutes - second.minutes) < 0;
    };


}());
