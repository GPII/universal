/*!
GPII Settings Transformer

Copyright 2012 OCAD University
Copyright 2012 Antranig Basman
Copyright 2013-2014 Raising the Floor

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

"use strict";

var fluid = fluid || require("infusion"),
    $ = fluid.registerNamespace("jQuery"),
    gpii = fluid.registerNamespace("gpii");

(function () {

    fluid.defaults("gpii.transformer", {
        gradeNames: ["fluid.littleComponent", "autoInit"],
        invokers: {
            settingsHandlerToLifecycle: {
                funcName: "gpii.transformer.toLifecycleFormat",
                args: [ "{arguments}.0", "{arguments}.1" ]
            }
        }
    });

    /*
     * helper function for `gpii.transformer.toLifecycleFormat`. Used to modify the settings handler
     * blocks to be in the format required (ie. including the application specific settings to be
     * set) by the lifecycle manager
     *
     * @settingsHandler (Object) - The settingshandler to be modified. Note that this object will be
     *     modified - not just a copy of it.
     * @preferences (Object) - the user preferences related to this solution and settings handler.
     * @solutionId (Object) - the ID of the solution for which the settingshandler is related
     *
     * @return (Object) - the modified settingshandler object - ready to be passed to the lifecycle
     *     manager
     */
    gpii.transformer.settingsHandlerToLifecycle = function (settingsHandler, preferences, solutionId) {
        // todo: throw app specific settings in the correct locations if there are multiple handlers
        var settings = preferences.settings["http://registry.gpii.net/applications/"+solutionId];
        var inferred;
        if (settingsHandler.capabilitiesTransformations) {
            inferred = fluid.model.transformWithRules(preferences.settings, settingsHandler.capabilitiesTransformations);
            settings = $.extend(true, inferred, settings);
        }

        settingsHandler.settings = settings;
        delete settingsHandler.capabilitiesTransformations;
        delete settingsHandler.capabilities;
        return settingsHandler;
    };

    /*
     * Modifies a system configuration (output from the context manager) to a format readible by the
     * lifecycle manager. This includes translation common terms to application specific settings.
     * The following rules apply when doing this translation:
     * - the translation is based on the transformations in the solutionsRegistry entry
     * - if a common term transforms into a setting which is already specific as applicaiton speicfic
     *      in the configuration parameter, the application specific takes priority. In other words:
     *      if the configuration contains both an application specific and (transformable) common
     *       term for some application setting, the application specific one will stay and the
     *      transformed will be discarded.
     *
     * @configuration (Object) - An object, which has already been evaluated with regards to context
     *      (by the context manager)
     * @solutionsRegistry (Object) - the solutions registry database
     *
     * @returns the modified solutions registry entries, ready to be applied by the lifecycle manager.
     */
    gpii.transformer.toLifecycleFormat = function (configuration, solutionsRegistry) {
        var togo = {};
        fluid.each(configuration.applications, function (preferences, solutionId) {
            togo[solutionId] = fluid.copy(solutionsRegistry[solutionId]);
            if (togo[solutionId] === undefined) {
                fluid.fail("The configuration to be applied contains an entry for " + solutionId +
                    " which was not found in the solutionRegistry. Aborting configuration");
            }
            delete togo[solutionId].contexts;
            var registryEntry = togo[solutionId];
            fluid.transform(registryEntry.settingsHandlers, function (settingsHandler) {
                return gpii.transformer.settingsHandlerToLifecycle(settingsHandler, preferences, solutionId);
            });
            // Hack to take "active: <bool>" into account
            if (preferences.active === false) {
                // if start block has a setSettings directive, this should be the only content left
                // else no actions should be taken
                var lm = registryEntry.lifecycleManager;
                lm.start = (lm.start && $.inArray("setSettings", lm.start) !== -1) ? [ "setSettings" ] : [];
                // same for stop block:
                lm.stop = (lm.stop && $.inArray("restoreSettings", lm.stop) !== -1) ? [ "restoreSettings" ] : [];
            }

        });

        return togo;
    };



    fluid.defaults("gpii.transformer.quantize", {
        gradeNames: "fluid.standardTransformFunction"
    });

    gpii.transformer.quantize = function (value, transformSpec, transform) {
        if (!transformSpec.ranges || !transformSpec.ranges.length) {
            fluid.fail("gpii.transformer.quantize should have a key called ranges containing an array defining ranges to quantize");
        }
        for (var i = 0; i < transformSpec.ranges.length; i++) {
            var rangeSpec = transformSpec.ranges[i];
            if (rangeSpec.upperBound === undefined || value <= rangeSpec.upperBound) {
                // note that we might return undefined if output evaluates to that on an expand
                return fluid.isPrimitive(rangeSpec.output) ? rangeSpec.output : transform.expand(rangeSpec.output);
            }
        }
    };

    fluid.defaults("gpii.transformer.booleanToNumber", {
        gradeNames: "fluid.standardTransformFunction"
    });

    gpii.transformer.booleanToNumber = function (value) {
        return value ? 1 : 0;
    };

}());
