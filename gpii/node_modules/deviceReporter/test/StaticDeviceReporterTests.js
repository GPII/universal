/*!
 * Static Device Reporter Tests
 *
 * Copyright 2019 OCAD University
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion"),
    gpii = fluid.registerNamespace("gpii"),
    jqUnit = fluid.registerNamespace("jqUnit"),
    kettle = require("kettle");

kettle.loadTestingSupport();

require("../src/DeviceReporter.js");

fluid.registerNamespace("gpii.tests.deviceReporter");

// The base testEnvironment grade to be inherited by all tests
fluid.defaults("gpii.tests.deviceReporterTestEnv", {
    gradeNames: ["fluid.test.testEnvironment"],
    installedSolutionsPath: null,    // supplied by individual tests
    testCaseHolderGrade: null,   // supplied by individual tests
    distributeOptions: {
        installedSolutionsPath: {
            source: "{that}.options.installedSolutionsPath",
            target: "{that deviceReporter installedSolutionsDataSource}.options.path"
        },
        testCaseHolderGrade: {
            source: "{that}.options.testCaseHolderGrade",
            target: "{that > testCaseHolder}.type"
        }
    },
    components: {
        deviceReporter: {
            type: "gpii.deviceReporter.static"
        },
        testCaseHolder: {
            type: "fluid.test.testCaseHolder"
        }
    }
});

// Successful test cases
fluid.defaults("gpii.tests.deviceReporter.testCaseHolder.success", {
    gradeNames: "fluid.test.testCaseHolder",
    modules: [{
        name: "The device reporter test - a successful workflow",
        expect: 2,
        tests: [{
            name: "The payload returned by the device reporter is correct",
            sequence: [{
                task: "{deviceReporter}.get",
                resolve: "gpii.tests.deviceReporter.verifyPayload",
                resolveArgs: ["{arguments}.0"]
            }]
        }]
    }]
});

fluid.defaults("gpii.tests.deviceReporter.success", {
    gradeNames: ["gpii.tests.deviceReporterTestEnv"],
    installedSolutionsPath: "%gpii-universal/testData/deviceReporter/installedSolutions.json",
    testCaseHolderGrade: "gpii.tests.deviceReporter.testCaseHolder.success"
});

gpii.tests.deviceReporter.verifyPayload = function (response) {
    jqUnit.assertNotUndefined("OS id has been received", response.OS.id);
    jqUnit.assertTrue("Solutions have been received", response.solutions.length > 0);
};

// Error test cases
fluid.defaults("gpii.tests.deviceReporter.testCaseHolder.error", {
    gradeNames: "fluid.test.testCaseHolder",
    modules: [{
        name: "Device Reporter fails on corrupt JSON file",
        expect: 2,
        tests: [{
            name: "The payload returned by the device reporter is correct",
            sequence: [{
                task: "{deviceReporter}.get",
                reject: "gpii.tests.deviceReporter.assertError",
                rejectArgs: ["{arguments}.0", ["Failed to read deviceReporter", "Parse error"]]
            }]
        }]
    }]
});

fluid.defaults("gpii.tests.deviceReporter.error", {
    gradeNames: ["gpii.tests.deviceReporterTestEnv"],
    installedSolutionsPath: "%gpii-universal/tests/data/faultyDeviceReport.jsonx",
    testCaseHolderGrade: "gpii.tests.deviceReporter.testCaseHolder.error"
});

gpii.tests.deviceReporter.assertError = function (response, expectedErrorMsg) {
    fluid.each(expectedErrorMsg, function (msg) {
        jqUnit.assertTrue("The error message is expected", response.message.includes(msg));
    });
};

fluid.test.runTests([
    "gpii.tests.deviceReporter.success",
    "gpii.tests.deviceReporter.error"
]);
