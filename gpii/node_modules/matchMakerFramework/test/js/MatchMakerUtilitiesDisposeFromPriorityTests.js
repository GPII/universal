/*!
GPII MatchMaker Utilities: Dispose from priority Tests

Copyright 2014 Raising The Floor - International

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

The research leading to these results has received funding from the European Union's
Seventh Framework Programme (FP7/2007-2013) under grant agreement no. 289016.

You may obtain a copy of the License at
https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

/*global jqUnit */

var fluid = fluid || require("infusion"),
    gpii = fluid.registerNamespace("gpii");

(function () {
    "use strict";
    fluid.registerNamespace("gpii.tests.matchMakerUtilities.disposeFromPriority");

    var fullData = {
        solIds: [ "solA", "solB", "solC", "solD", "solE" ],
        solrecs: {
            solA: {
                solution: {},
                skeleton: {},
                index: "solA"
                // priority: 1024
            },
            solB: {
                solution: {},
                skeleton: {},
                index: "solB"
                // priority: 1024
            },
            solC: {
                solution: {},
                skeleton: {},
                index: "solC"
                // priority: 1024
            },
            solD: {
                solution: {},
                skeleton: {},
                index: "solD"
                // priority: 1024
            },
            solE: {
                solution: {},
                skeleton: {},
                index: "solE"
                // priority: 1024
            }
        },
        data: {
            solutionTypes: {
                solA: [
                    "http://registry\\.gpii\\.net/common/magnifierApplication",
                    "http://registry\\.gpii\\.net/common/screenReaderApplication"
                ],
                solB: [
                    "http://registry\\.gpii\\.net/common/magnifierApplication",
                    "http://registry\\.gpii\\.net/common/screenReaderApplication"
                ],
                solC: [
                    "http://registry\\.gpii\\.net/common/screenReaderApplication"
                ],
                solD: [
                    "http://registry\\.gpii\\.net/common/screenReaderApplication"
                ],
                solE: [
                    "http://registry\\.gpii\\.net/common/magnifierApplication"
                ]
            },
            solutionTypeMapping: {
                "http://registry\\.gpii\\.net/common/magnifierApplication": {
                    solA: true,
                    solB: true,
                    solE: true
                },
                "http://registry\\.gpii\\.net/common/screenReaderApplication": {
                    solA: true,
                    solB: true,
                    solC: true,
                    solD: true
                }
            }
        }
    };

    // "undefined" disposition means that the solution is either tied with another solution
    // or not present on the device. Decisions are based on priority and solution type - see
    // the data block above.
    var testData = [{
        description: "Tie between highest priority, rest rejected",
        priorities: [2, 2, 1, 1, 1],
        expectedDispositions: [undefined, undefined, "reject", "reject", "reject"]
    }, {
        description: "Single highest priority wins, rest rejected",
        priorities: [2, 1, 1, 1, 1],
        expectedDispositions: ["accept", "reject", "reject", "reject", "reject"]
    }, {
    //     description: "Only solution covering all required solution types selected",
    //     priorities: [2, 1, 2, 1, 1],
    //     expectedDispositions: ["accept", "reject", "reject", "reject", "reject"]
    // }, {
        description: "Highest priority selected, solution type equivalents remove",
        priorities: [2, 1, 3, 1, 2],
        expectedDispositions: ["reject", "reject", "accept", "reject", "accept"]
    }, {
        description: "Tie between multiple solutions of different types",
        priorities: [2, 1, 2, 2, 2],
        expectedDispositions: [undefined, "reject", undefined, undefined, undefined]
    }, {
        description: "Tie between multiple solutions of different types #2",
        priorities: [2, 1, 2, 1, 2],
        expectedDispositions: [undefined, "reject", undefined, "reject", undefined]
    // }, {
    //     description: "",
    //     priorities: [1, null, 2, null, null],
    //     expectedDispositions: ["accept", undefined, "reject", undefined, undefined]
    }];


    /**
     * Adjusts the 'testData' input object according to the solution and priority given. If priority
     * === null, the solution will be reported as not existing on the system. Else the solution will
     * be reported with the given priority.
     */
    gpii.tests.matchMakerUtilities.disposeFromPriority.setSinglePriority = function (testData, solId, priority) {
        if (priority === null) {
            delete testData.solrecs[solId];
            delete testData.data.solutionTypes[solId];
            delete testData.data.solutionTypeMapping["http://registry\\.gpii\\.net/common/magnifierApplication"][solId];
            delete testData.data.solutionTypeMapping["http://registry\\.gpii\\.net/common/screenReaderApplication"][solId];
        } else {
            testData.solrecs[solId].priority = priority;
        }
    };

    /**
     * Adjusts the 'testData' input object according to the solution and priority given. If priority
     * === null, the solution will be reported as not existing on the system. Else the solution will
     * be reported with the given priority.
     */
    gpii.tests.matchMakerUtilities.disposeFromPriority.setPriorities = function (priorities) {
        if (priorities.length !== fullData.solIds.length) {
            jqUnit.assertTrue("Priorities need to be specified for 5 solutions when testing priority disposition", false);
        }
        var cpy = fluid.copy(fullData);
        for (var i = 0; i < fullData.solIds.length; i++) {
            gpii.tests.matchMakerUtilities.disposeFromPriority.setSinglePriority(cpy, fullData.solIds[i], priorities[i]);
        }
        return cpy;
    };

    gpii.tests.matchMakerUtilities.disposeFromPriority.assertSolutionDisposition = function (input, solId, expDisposition) {
        var msg = "Expecting solution " + solId + " to have disposition: " + expDisposition;
        jqUnit.assertEquals(msg, expDisposition, input.solrecs[solId].disposition);
    };

    gpii.tests.matchMakerUtilities.disposeFromPriority.singleTest = function (priorities, expectedDispositions) {
        var input = gpii.tests.matchMakerUtilities.disposeFromPriority.setPriorities(priorities);

        gpii.matchMakerFramework.utils.disposeFromPriority(input.solrecs, input.data);
        fluid.each(fullData.solIds, function (solId, index) {
            var msg = "Expecting solution " + solId + " to have disposition: " + expectedDispositions[index];
            jqUnit.assertEquals(msg, expectedDispositions[index], input.solrecs[solId].disposition);
        });
    };

    gpii.tests.matchMakerUtilities.disposeFromPriority.runTests = function () {
        jqUnit.module("MatchMakerUtilities - disposeFromPriority");
        fluid.each(testData, function (fixture) {
            jqUnit.test(fixture.description, function () {
                gpii.tests.matchMakerUtilities.disposeFromPriority.singleTest(fixture.priorities, fixture.expectedDispositions);
            });
        });
    };
})();
