/*
* Match Maker Framework
*
* Copyright 2014 Raising the Floor - International
*
* Licensed under the New BSD license. You may not use this file except in
* compliance with this License.
*
* The research leading to these results has received funding from the European Union's
* Seventh Framework Programme (FP7/2007-2013)
* under grant agreement no. 289016.
*
* You may obtain a copy of the License at
* https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

"use strict";

var fluid = require("infusion"),
    gpii = fluid.registerNamespace("gpii"),
    semver = require("semver");

fluid.registerNamespace("gpii.matchMakerFramework");

fluid.defaults("gpii.matchMakerFramework", {
    gradeNames: ["fluid.component"],
    matchMakerUrl: "%matchMakerPath/match",
    components: {
        matchMakerService: {
            type: "kettle.dataSource.URL",
            options: {
                url: "{gpii.matchMakerFramework}.options.matchMakerUrl",
                writable: true,
                termMap: {
                    matchMakerPath: "noencode:%matchMakerPath"
                }
            }
        }
    },
    invokers: {
        preProcess: {
            funcName: "gpii.matchMakerFramework.preProcess",
            args: ["{that}", "{arguments}.0"]
        }, // initialPayload
        matchMakerDispatcher: {
            funcName: "gpii.matchMakerFramework.matchMakerDispatcher",
            args: ["{that}", "{arguments}.0"]
        }
    },
    events: {
        onSolutions: null
    }
});

/*
 * responsible for building the input payload to the matchmaker, via a bunch of helper functions
 * initialPayload consists of:
 *    userToken, preferences, deviceContext, solutionsRegistryEntries
 */
gpii.matchMakerFramework.preProcess = function (that, initialPayload) {
    var matchMakerInput = fluid.extend({
        activeContexts: [ // TODO calculate properly
            "gpii-default"
        ],
        environmentReporter: {}, // TODO,
        inferredCommonTerms: gpii.matchMakerFramework.utils.inferCommonTerms(initialPayload.preferences, initialPayload.fullSolutionsRegistry)
    }, initialPayload);
    // remove full solutions registry from the payload, now that we've used it
    // to avoid sending a too large payload to the matchmaker (see GPII-1880)
    delete matchMakerInput.fullSolutionsRegistry;

    return matchMakerInput;
};

/**
 * Asynchronous function responsible for, given a matchMaker input payload, deciding which matchmaker is most
 * suitable to do the actual matching process and send the payload there. Once the matchmaker
 * returns its matched data, the event will be fired with both the returned and original data in a combined payload.
 *
 * @param that {Object} - object containing a matchMakerService datasource component which can be used
 *     when sending the data to the actual match maker
 * @param matchMakerInput {Object} - a valid input payload for the matchmakers
 * @param event {Object} - event to fire when the matchmaker has finished its matching
 */
gpii.matchMakerFramework.matchMakerDispatcher = function (that, matchMakerInput) {
    var matchMakerResponse = fluid.extend({}, matchMakerInput);
    // TODO: some algorithm to decide the MM
    var selectedMatchMaker = "default";
    var matchMakerPath = that.options.matchMakers[selectedMatchMaker].url;
    fluid.log("MatchMaker Framework: dispatching to the " + selectedMatchMaker + " MatchMaker at path " + matchMakerPath);
    var promise = that.matchMakerService.set({
        matchMakerPath: matchMakerPath
    }, matchMakerInput, { writeMethod: "POST" });

    var outputPromise = fluid.promise();
    promise.then(function (matchMakerOutput) {
        matchMakerResponse.matchMakerOutput = matchMakerOutput;
        outputPromise.resolve(matchMakerResponse);
    }, function (err) { // TODO: This rejection handler is untested
        outputPromise.reject(err);
    });
    return outputPromise;
};

/**
 * Takes a solutions registry object and filters out all solutions that do not match the ones
 * reported by the device reporter.
 *
 * @param solutions {Object} - solutions registry entries as retrieved from solutions registry
 * @param device {Object} - device reporter data as retrieved from the device reporter
 *
 * @return {Object} - the solutions registry object, but with all the solutions not matching
 *      the device filtered out
 */
gpii.matchMakerFramework.filterSolutions = function (solutions, device) {
    return fluid.remove_if(fluid.copy(solutions), function (solution, solutionId) {
        // Match on device solutions.
        var matchesSolutions = fluid.find(device.solutions, function (devSolution) {
            if (devSolution.id === solutionId &&
                (!solution.version ||
                 !devSolution.version ||
                 semver.satisfies(devSolution.version, solution.version)
                )) {
                return true;
            }
        });
        if (!matchesSolutions) {
            return solutions;
        }
    });
};
