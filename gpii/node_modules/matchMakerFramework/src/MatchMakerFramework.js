/*
* Match Maker Framework
*
* Copyright 2014 Raising the Floor - International
*
* Licensed under the New BSD license. You may not use this file except in
* compliance with this License.
*
* The research leading to these results has received funding from the European Union's
* Seventh Framework Programme (FP7/2007-2013)
* under grant agreement no. 289016.
*
* You may obtain a copy of the License at
* https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

(function () {
    "use strict";

    var fluid = require("infusion"),
        $ = fluid.registerNamespace("jQuery"),
        gpii = fluid.registerNamespace("gpii"),
        semver = require("semver");

    fluid.registerNamespace("gpii.matchMakerFramework");

    gpii.matchMakerFramework.inverseCapabilities = require("./inverseCapabilities.json");
    gpii.matchMakerFramework.matchmakerCapabilities = require("./MatchMakerCapabilities.json");

    fluid.defaults("gpii.matchMakerFramework", {
        gradeNames: ["fluid.eventedComponent", "autoInit"],
        inverseCapabilities: gpii.matchMakerFramework.inverseCapabilities,
        matchMakerUrl: "%matchMakerPath/match",
        matchMakers: "{flowManager}.options.matchMakers",
        matchMakerDispatcherDisabled: "{flowManager}.options.matchMakerDispatcherDisabled",
        components: {
            matchMakerService: {
                type: "kettle.dataSource.URL",
                options: {
                    gradeNames: ["kettle.dataSource.simpleCallbackWrapper"],
                    url: "{gpii.matchMakerFramework}.options.matchMakerUrl",
                    writable: true,
                    termMap: {
                        matchMakerPath: "noencode:%matchMakerPath"
                    }
                }
            }
        },
        invokers: {
            preProcess: {
                funcName: "gpii.matchMakerFramework.preProcess",
                args: ["{that}", "{flowManager}.lifecycleManager", "{arguments}.0"]
            }, // initialPayload
            matchMakerDispatcher: {
                funcName: "gpii.matchMakerFramework.matchMakerDispatcher",
                args: ["{that}", "{arguments}.0"]
            }
        },
        events: {
            onSolutions: null
        }
    });

    /*
     * responsible for building the input payload to the matchmaker, via a bunch of helper functions
     * initialPayload consists of:
     *    userToken, preferences, deviceContext, solutionsRegistryEntry
     */
    gpii.matchMakerFramework.preProcess = function (that, lifecycleManager, initialPayload) {
        // add the web based solution registry entries
        var initialPayloadCopy = fluid.copy(initialPayload);

        initialPayloadCopy.solutionsRegistryEntries = $.extend({},
            initialPayloadCopy.webSolutionsRegistryEntries, initialPayloadCopy.solutionsRegistryEntries);
        delete initialPayloadCopy.webSolutionsRegistryEntries;

        var activeTokens = lifecycleManager.getUserTokens();
        if (activeTokens.length === 1) {
            // if a user is already logged in, send a combined NP set;
            var currentSession = lifecycleManager.session;
            var preferences = [{
                userToken: currentSession.userToken,
                contexts: currentSession.preferences.contexts
            }, {
                userToken: initialPayloadCopy.userToken,
                contexts: initialPayloadCopy.preferences.contexts
            }];
            initialPayloadCopy.preferences = preferences;
        }

        var matchMakerInput = $.extend({
            // token: token,
            // preferences: preferences,
            // deviceReporter: deviceContext,
            // solutionsRegistry: solutionsRegistry,
            activeContexts: [ // TODO calculate properly
                "gpii-default"
            ],
            environmentReporter: {}, // TODO,
            inferredCommonTerms: gpii.matchMakerFramework.inferCommonTerms(initialPayloadCopy.preferences)
        }, initialPayloadCopy);
        return matchMakerInput;
    };

    /**
     * Asynchronous function responsible for, given a matchMaker input payload, deciding which matchmaker is most
     * suitable to do the actual matching process and send the payload there. Once the matchmaker
     * returns its matched data, the event will be fired with both the returned and original data in a combined payload.
     *
     * @param that {Object} - object containing a matchMakerService datasource component which can be used
     *     when sending the data to the actual match maker
     * @param matchMakerInput {Object} - a valid input payload for the matchmakers
     * @param event {Object} - event to fire when the matchmaker has finished its matching
     */
    gpii.matchMakerFramework.matchMakerDispatcher = function (that, matchMakerInput) {
        var matchMakerResponse = $.extend({}, matchMakerInput);
        // TODO: some algorithm to decide the MM
        var selectedMatchMaker = gpii.matchMakerFramework.selectMatchMaker(that, matchMakerInput);
        var matchMakerPath = that.options.matchMakers[selectedMatchMaker].url;
        fluid.log("MatchMaker Framework: dispatching to the " + selectedMatchMaker + " MatchMaker at path " + matchMakerPath);
        var promise = that.matchMakerService.set({
            matchMakerPath: matchMakerPath
        }, matchMakerInput, { writeMethod: "POST" });

        var outputPromise = fluid.promise();
        promise.then(function (matchMakerOutput) {
            matchMakerResponse.matchMakerOutput = matchMakerOutput;
            outputPromise.resolve(matchMakerResponse);
        });
        return outputPromise;
    };

    /*
     * Returns a string indicating the matchmaker to select from configuration. Depends on the matchmaker payload.
     */
    gpii.matchMakerFramework.selectMatchMaker = function (that, matchMakerPayload) {
        if (that.options.matchMakerDispatcherDisabled) {
            return "flat";
        }
        var result = gpii.matchMakerFramework.GetPreferredMatchMaker(matchMakerPayload);
        return (result) ? result : gpii.matchMakerFramework.GetCapableMatchMaker(matchMakerPayload);
    };

    /*
     * Returns if a matchmaker payload contains preferences for selecting a matchmaker.
     * Returns NULL if no matchmaker preference was found.
     */
    gpii.matchMakerFramework.GetPreferredMatchMaker = function (matchMakerPayload) {
        // Rejection tests
        if (matchMakerPayload.preferences === undefined || matchMakerPayload.preferences.contexts === undefined || matchMakerPayload.activeContexts === undefined) {
            return null;
        }
        // Search for mm selection preferences
        var contexts = matchMakerPayload.preferences.contexts;
        var activeContexts = matchMakerPayload.activeContexts;
        var foundPriority = -1;
        var foundMatchMaker;
        fluid.each(activeContexts, function (activeContext) {
            if (contexts[activeContext] && contexts[activeContext].preferences) {
                var prefs = contexts[activeContext].preferences;
                var curPriority = 0;
                if (contexts[activeContext].priority) {
                    curPriority = contexts[activeContext].priority;
                }
                if ((prefs["http://registry.gpii.net/common/matchMakerType"]) && (curPriority > foundPriority)) {
                    foundPriority = curPriority;
                    foundMatchMaker = prefs["http://registry.gpii.net/common/matchMakerType"];
                }
            }
        });
        return foundMatchMaker;
    };

    /*
     * Returns the Matchmaker that best matches to the playload based on its capabilities.
     * See MatchMakerCapabilities.json.
     */
    gpii.matchMakerFramework.GetCapableMatchMaker = function (matchMakerPayload) {
        // Contexts
        var contexts = matchMakerPayload.preferences.contexts;
        // Find excluded matchmakers
        var excludedMatchMakers = [];
        var activeContexts = matchMakerPayload.activeContexts;
        fluid.each(activeContexts, function (activeContext) {
            if (contexts[activeContext] && contexts[activeContext].preferences) {
                var prefs = contexts[activeContext].preferences;
                if (prefs["http://registry.gpii.net/common/excludedMatchMakers"]) {
                    excludedMatchMakers = prefs["http://registry.gpii.net/common/excludedMatchMakers"];
                }
            }
        });
        // Try again block
        if (matchMakerPayload.tryAgain && matchMakerPayload.tryAgain.active) {
            if (matchMakerPayload.tryAgain.excludedMatchMakers) {
                excludedMatchMakers.concat(matchMakerPayload.tryAgain.excludedMatchMakers);
            }
        }
        // Calculate metric values
        var payloadHasConditions = false;
        var payloadPreferenceCount = 0;
        fluid.each(contexts, function (context) {
            if (context.conditions && (context.conditions.length > 0)) {
                payloadHasConditions = true;
            }
            if (context.preferences) {
                fluid.each(context.preferences, function (pref) {
                    if (typeof pref === "object") {
                        payloadPreferenceCount += Object.keys(pref).length;
                    } else {
                        ++payloadPreferenceCount;
                    }
                });
            }
        });
        // Compute capabilities
        var foundMatchmaker = false;
        var confidence = {};
        fluid.each(gpii.matchMakerFramework.matchmakerCapabilities, function (capability) {
            if (excludedMatchMakers.indexOf(capability.matchMakerId) < 0) {
                // Do we support conditions?
                var supportsConditions = true;
                if (capability.conditions && capability.conditions.supported) {
                    supportsConditions = capability.conditions.supported;
                }
                // Which preferences do we support?
                var supportedPreferences = [];
                if (capability.preferences && capability.preferences.supported) {
                    supportedPreferences = capability.preferences.supported;
                }
                // Count unsupported preferences
                var unsupportedPreferencesCount = 0;
                fluid.each(contexts, function (context) {
                    if (context.preferences) {
                        fluid.each(context.preferences, function (pref, prefName) {
                            if (supportedPreferences.indexOf(prefName) < 0) {
                                if (pref && typeof pref === "object") {
                                    unsupportedPreferencesCount += Object.keys(pref).length;
                                } else {
                                    ++unsupportedPreferencesCount;
                                }
                            }
                        });
                    }
                });
                // Our confidence.
                if (supportsConditions || !payloadHasConditions) {
                    var baseValue = 0;
                    var forEachPreference = 0;
                    var forEachUnsupportedPreference = 0;
                    if (capability.metrics) {
                        if (capability.metrics.baseValue) {
                            baseValue = capability.metrics.baseValue;
                        }
                        if (capability.metrics.forEachPreference) {
                            forEachPreference = capability.metrics.forEachPreference;
                        }
                        if (capability.metrics.forEachUnsupportedPreference) {
                            forEachUnsupportedPreference = capability.metrics.forEachUnsupportedPreference;
                        }
                    }
                    confidence[capability.matchMakerId] = baseValue +
                        payloadPreferenceCount * forEachPreference +
                        unsupportedPreferencesCount * forEachUnsupportedPreference;
                    foundMatchmaker = true;
                }
            }
        });
        if (foundMatchmaker) {
            var resultMatchmaker = "flat";
            var resultConfidence = -999999;
            fluid.each(confidence, function (confValue, confMatchmaker) {
                if (confValue > resultConfidence) {
                    resultConfidence = confValue;
                    resultMatchmaker = confMatchmaker;
                }
            });
            return resultMatchmaker;
        } else {
            return "flat";
        }
    };

    /*
     * Takes a solutions registry object and filters out all solutions that do not match the ones
     * reported by the device reporter.
     *
     * @solutions (Object) - solutions registry entries as retrieved from solutions registry
     * @device (Object) - device reporter data as retrieved from the device reporter
     *
     * @return (Object) - the solutions registry object, but with all the solutions not matching
     *      the device filtered out
     */
    gpii.matchMakerFramework.filterSolutions = function (solutions, device) {
        return fluid.remove_if(fluid.copy(solutions), function (solution, solutionId) {
            // Match on device solutions.
            var matchesSolutions = fluid.find(device.solutions, function (devSolution) {
                if (devSolution.id === solutionId &&
                    (!solution.version ||
                     !devSolution.version ||
                     semver.satisfies(devSolution.version, solution.version)
                    )) {
                    return true;
                }
            });
            if (!matchesSolutions) {
                return solutions;
            }
        });
    };

    /*
     * Converts application specific settings into common terms, keyed by application ids. Given a
     * set of preferences, for each application block in those preferences, the settings for which
     * inverse transformations exist will be transformed into common terms. All the common terms
     * that have successfully been inferred from an application will be written to a block keyed by
     * that applications ID.
     *
     * @preferences (Object) - An NP set (including contexts, etc)
     *
     * @return (Object) - Object where keys are solution IDs and entries are common term
     *      preferences which have been transformed from application specific settings for that
     *      soluion
     */
    gpii.matchMakerFramework.inferCommonTerms = function (preferences) {
        var irules = gpii.matchMakerFramework.inverseCapabilities;
        var togo = {};
        fluid.each(preferences.contexts, function (context, contextId) {
            var prefs = context.preferences;
            togo[contextId] = {};
            fluid.each(irules, function (rule, appId) {
                var appBlock = prefs["http://registry.gpii.net/applications/" + appId];
                if (appBlock) { // TODO: Currently we'll get an {} returned if no transformations matches settings
                    var out = fluid.model.transformWithRules(appBlock, irules[appId]);
                    togo[contextId][appId] = out;
                }
            });
        });
        return togo;
    };
})();
