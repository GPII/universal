/*
* MatchMaker Framework
*
* Copyright 2014 Raising the Floor - International
* Copyright 2018 OCAD University
*
* Licensed under the New BSD license. You may not use this file except in
* compliance with this License.
*
* The research leading to these results has received funding from the European Union's
* Seventh Framework Programme (FP7/2007-2013)
* under grant agreement no. 289016.
*
* You may obtain a copy of the License at
* https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

"use strict";

var fluid = require("infusion"),
    gpii = fluid.registerNamespace("gpii"),
    semver = require("semver");

fluid.registerNamespace("gpii.matchMakerFramework");

fluid.defaults("gpii.matchMakerFramework", {
    gradeNames: ["fluid.component"],
    invokers: {
        matchMakerDispatcher: {
            funcName: "gpii.matchMakerFramework.matchMakerDispatcher",
            args: ["{that}", "{matchMaker}", "{arguments}.0"]
        }
    },
    events: {
        onSolutions: null
    }
});

/**
 * Asynchronous function responsible for, given a matchMaker input payload, deciding which matchmaker is most
 * suitable to do the actual matching process and send the payload there. Once the matchmaker
 * returns its matched data, the promise will be resolved with both the returned and original data in a combined
 * payload.
 *
 * @param {Object} that - object containing a matchMakerService datasource component which can be used
 *     when sending the data to the actual MatchMaker.
 * @param {Component} matchMaker - A instance of "matchMaker" component.
 * @param {Object} matchMakerInput - A valid input payload for the matchmakers.
 * @return {Promise} A promise that will be resolved with both the returned and original data in a combined payload, or rejected on error.
 */
gpii.matchMakerFramework.matchMakerDispatcher = function (that, matchMaker, matchMakerInput) {
    fluid.log("MatchMaker Framework: dispatching to matchMaker.match() with the input ", matchMakerInput);
    var matchMakerResponse = fluid.extend({}, matchMakerInput);
    matchMakerResponse.matchMakerOutput = matchMaker.match(matchMakerInput);
    return fluid.promise().resolve(matchMakerResponse);
};

/**
 * Takes a solutions registry object and filters out all solutions that do not match the ones
 * reported by the device reporter.
 *
 * @param {Object} solutions - Solutions registry entries as retrieved from solutions registry.
 * @param {Object} device - Device reporter data as retrieved from the device reporter.
 * @return {Object} The solutions registry object, but with all the solutions not matching
 *      the device filtered out.
 */
gpii.matchMakerFramework.filterSolutions = function (solutions, device) {
    return fluid.remove_if(fluid.copy(solutions), function (solution, solutionId) {
        // Match on device solutions.
        var matchesSolutions = fluid.find(device.solutions, function (devSolution) {
            if (devSolution.id === solutionId &&
                (!solution.version ||
                !devSolution.version ||
                semver.satisfies(devSolution.version, solution.version)
                )) {
                return true;
            }
        });
        if (!matchesSolutions) {
            return solutions;
        }
    });
};
