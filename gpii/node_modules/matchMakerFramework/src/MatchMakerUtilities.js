/*!
GPII Matchmaker Framework - Utilities

Copyright 2012 OCAD University
Copyright 2012 Antranig Basman
Copyright 2014 Raising the Floor - international

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

var fluid = fluid || require("infusion"),
    gpii = fluid.registerNamespace("gpii");

(function () {

    "use strict";
    fluid.registerNamespace("gpii.matchMakerFramework.utils");

    /*
     * Helper function for computeCapabilitiesFromSolution. Grabs the capabilities (incl. those from the
     * capabilities transformations) for a single settings handler.
    */
    gpii.matchMakerFramework.utils.computeCapabilitiesFromSettingsHandler = function (settingsHandler, transformSpec) {
        var leaves = [];
        leaves = leaves.concat(fluid.makeArray(settingsHandler.capabilities));
        var inputPaths = fluid.model.transform.collectInputPaths(settingsHandler.capabilitiesTransformations || {});

        // Input paths are flat so need to be transformed into hierarchical
        var skel = gpii.matchMakerFramework.utils.pathsToSkeleton(inputPaths, true);
        var hskeleton = fluid.model.transformWithRules(skel, transformSpec);
        leaves = leaves.concat(gpii.matchMakerFramework.utils.computeLeaves(hskeleton));
        return leaves;
    };

    /*
     * Given a solution entry all the capabilities of that solution will be calculated based on
     * input paths in the transformations (specified in the capabilitiesTransformations block) and
     * on the list in the capabilities block of that solution. The result will be an array list of
     * el-paths.
     *
     * @solution {Object} A single solution entry, as can be found in the solutions registry
     * @transformSpec {Object} transformation rules to transform the input paths from the solution
     *    registry format into the format desired in the output array. If if one would like the result
     *    as a list of ISO24751 el-paths and the solutionsregistry transformations are given in
     *    the flat format, a transformation rules for 'flat' to ISO24751 should be given
     * @result {Array} An array of el-paths to all the input paths of the capabilitiesTransformations
     *    concatenated with the list given in the capabilities block of the solution entry.
    */
    gpii.matchMakerFramework.utils.computeCapabilitiesFromSolution = function (solution, transformSpec) {
        var leaves = [];
        leaves = leaves.concat.apply(leaves, fluid.transform(solution.settingsHandlers,
            function(settingsHandler) {
                return gpii.matchMakerFramework.utils.computeCapabilitiesFromSettingsHandler(settingsHandler, transformSpec);
            }));
        return leaves;
    };

    /*
     * Helper function for gpii.matchMakerFramework.utils.computeLeaves - see description there
     */
    var computeLeavesImpl = function (model, path, paths) {
        fluid.each(model, function (value, key) {
            var newPath = fluid.pathUtil.composePath(path, key.toString());
            if (fluid.isPrimitive(value)) {
                paths.push(newPath);
            }
            else {
                computeLeavesImpl(value, newPath, paths);
            }
        });
    };

    /*
     * Function to extract all leaves (ie. primitive end points) from an object. More specifically,
     * it takes a object (eg. prefs set) and finds all leaves - for each leaf found the path is
     * to an array as an el-path, one path for each leaf.
     *
     * @model {Object} the object from which to subtract leaves
     * @return {Array} an array of el-paths, one entry for each leaf found in the object
     */
    gpii.matchMakerFramework.utils.computeLeaves = function (model) {
        var paths = [];
        computeLeavesImpl(model, "", paths);
        return paths;
    };

    /*
     * Given a array of el-paths, this function creates an object with a structure that includes
     * all the el-paths in the array. Each of the entries will have the value passed as parameter or
     * defaulting to {} (ie. the empty object);
     *
     * @paths {Array} an array of el-paths that should be present in the resulting object
     * @value {any} the value that should be assigned to each of the keys given in the el-path array,
     *      if no @value is given, this defaults to the empty object ({})
     * @return {Object} and object with a structure containing all the el-paths, where each path has
     *     the value given in the parameter.
     */
    gpii.matchMakerFramework.utils.pathsToSkeleton = function (paths, value) {
        var togo = {};
        for (var i = 0; i < paths.length; ++ i) {
            var path = paths[i];
            var existing = fluid.get(togo, path, fluid.model.escapedGetConfig);
            if (!existing) {
                fluid.set(togo, path, value || {}, fluid.model.escapedSetConfig);
            }
        }
        return togo;
    };

    /*
     * Given a list of solutions, calculate the capabilities and generate a skeleton based on those.
     *
     * @solutions {Object} list of solution entries in the same format as the solutions registry
     * @transformSpec {Object} transformation rules to translate from the format the input paths are
     *     given in in the solutions entries' capabilitiesTransformations block, to the ontology
     *     that the skeleton should be in
     * @return {Object} an object listing the same solutions as the input payload, but where each
     *     solution block instead contains three keys: 'solution' which contains the original solution
     *     entry. 'skeleton' which contains the capabilities of the solution. 'index' which contains
     *     the solution id.
     */
    gpii.matchMakerFramework.utils.expandSolutions = function (solutions, transformSpec) {
        return fluid.transform(solutions, function (solution, solutionId) {
            var paths = gpii.matchMakerFramework.utils.computeCapabilitiesFromSolution(solution, transformSpec);
            var skeleton = gpii.matchMakerFramework.utils.pathsToSkeleton(paths);

            return {
                solution: solution,
                skeleton: skeleton,
                index: solutionId
            };
        });
    };

    /*
     * Function that takes a MM payload set as input that *includes* an entry of
     * preferences in a hierarchical format, as well as a strategy for selecting solutions
     * and a set of transformations rules between ontologies.
     *
     * @data {Object} a match maker output input payload that includes a translation of the
     *     preferences in an hierarchical ontology, keyed by 'hierarchicalPrefs'.
     * @strategy {function} the strategy to use to select which solutions should be configured and
     *     and launched on the system
     * @transformSpec {Object} Transformation rules FROM the format used in the input paths of the
     *     solutions registry capability transformations TO the format in which the
     *     settings of hierarchicalPrefs in the data argument are given
     * @return {Object} An object keyed by contexts and where the values are arrays of solutions
     *     to launch in that context
     */
    gpii.matchMakerFramework.utils.disposeSolutions = function (data, strategy, transformSpec) {
        var solrecs = gpii.matchMakerFramework.utils.expandSolutions(data.solutionsRegistry, transformSpec);
        var togo = {};
        // calculate match for each of the contexts
        fluid.each(data.hierarchicalPrefs.contexts, function (context, contextId) {
            var leaves = gpii.matchMakerFramework.utils.computeLeaves(context.preferences);
            var disposed = strategy(leaves, solrecs);
            togo[contextId] = [];
            fluid.each(disposed, function(solrec, solid) {
                if (solrec.disposition === "accept") {
                    togo[contextId].push(solid);
                }
            });
        });
        return togo;
    };

    /*
     * Function to build the payload required to be the output from the matchmaker framework
     *
     * @fullModel {Object} The full input sent to the MM
     * @disposed {Object} Object with keys of context-ids. Each value should be an array listing
     *     the disposed solutions
     * @return {Object} The data arranged to be compatible with the required MM format
     */
    gpii.matchMakerFramework.utils.buildReturnPayload = function (fullModel, disposed) {
        var togo = {
            inferredConfiguration: {}
        };

        fluid.each(disposed, function (solArray, contextId) {
            togo.inferredConfiguration[contextId] = {
                applications: {}
            };
            var appBlock = togo.inferredConfiguration[contextId].applications;
            fluid.each(solArray, function (solutionId) {
                var content = {
                    active: true,
                    settings: fullModel.preferences.contexts[contextId].preferences
                };
                appBlock[solutionId] = content;
                // TODO: add metadata sections
            });

            // add conditions if they exist:
            if (fullModel.preferences.contexts[contextId].conditions) {
                togo.inferredConfiguration[contextId].conditions = fullModel.preferences.contexts[contextId].conditions;
            }
        });
        return togo;
    };

    /*
     * Returns a string indicating the matchmaker to select from configuration. Depends on the matchmaker payload.
     */
    gpii.matchMakerFramework.utils.selectMatchMaker = function (matchMakerPayload) {
        var result = gpii.matchMakerFramework.utils.tryGetPreferredMatchMaker(matchMakerPayload);
        return (result) ? result : "flat";
    };

    /*
     * Returns if a matchmaker payload contains preferences for selecting a matchmaker.
     * Returns { "found": @bool, "matchMaker": @string }
     */
    gpii.matchMakerFramework.utils.tryGetPreferredMatchMaker = function (matchMakerPayload) {
        // Constants
        var USER_DEFINED_MATCHMAKER_PREF = "http://registry.gpii.net/common/matchMakerType";
        // Rejection tests
        if (matchMakerPayload.preferences === undefined || matchMakerPayload.preferences.contexts === undefined || matchMakerPayload.activeContexts === undefined) {
            return null;
        }
        // Search for mm selection preferences
        var contexts = matchMakerPayload.preferences.contexts;
        var activeContexts = matchMakerPayload.activeContexts;
        var foundPriority = -1;
        var foundMatchMaker;
        fluid.each(activeContexts, function (activeContext) {
            if ((activeContext in contexts) && ("preferences" in contexts[activeContext])) {
                var prefs = contexts[activeContext].preferences;
                var curPriority = 0;
                if ("priority" in contexts[activeContext]) {
                    curPriority = contexts[activeContext].priority;
                }
                if ((USER_DEFINED_MATCHMAKER_PREF in prefs) && (curPriority > foundPriority)) {
                    foundPriority = curPriority;
                    foundMatchMaker = prefs[USER_DEFINED_MATCHMAKER_PREF];
                }
            }
        });
        return foundMatchMaker;
    };

})();