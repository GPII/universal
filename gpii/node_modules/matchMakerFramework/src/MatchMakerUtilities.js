/*!
GPII Matchmaker Framework - Utilities

Copyright 2012 OCAD University
Copyright 2012 Antranig Basman
Copyright 2014 Raising the Floor - international

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

The research leading to these results has received funding from the European Union's
Seventh Framework Programme (FP7/2007-2013) under grant agreement no. 289016.

You may obtain a copy of the License at
https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

/* eslint-env browser */
/* eslint strict: ["error", "function"] */

var fluid = fluid || require("infusion"),
    gpii = fluid.registerNamespace("gpii");

(function () {

    "use strict";
    fluid.registerNamespace("gpii.matchMakerFramework.utils");
    fluid.registerNamespace("gpii.matchMakerFramework");

    /**
     * APP_SETTING_PRIORITY: the priority that an application is given if the user has application
     *    specific settings in their preference set for that application, but has no explicit priority for
     *    that application. * MIN_USER_PRIORITY: If an explicit priority is set by the user for an application, this is
     *    the minimum value it should have, to avoid conflicting with system generated priorities.
     */

    gpii.matchMakerFramework.APP_SETTING_PRIORITY = 512;
    gpii.matchMakerFramework.MIN_USER_PRIORITY = 1024;

    /**
     * responsible for building the input payload to the matchmaker, via a bunch of helper functions
     *
     * @param {Object} initialPayload - The initial payload sent to the matchmaking framework. It should as a
     *   minimum contain: gpiiKey, preferences, deviceContext, solutionsRegistryEntries.
     *   The values from this object will become part of the new matchmaker input object returned from this function,
     */
    gpii.matchMakerFramework.utils.preProcess = function (initialPayload) {
        var matchMakerInput = fluid.extend({
            activeContexts: [], // set later in the process
            environmentReporter: {}, // for holding any environment information
            inferredCommonTerms: gpii.matchMakerFramework.utils.inferCommonTerms(initialPayload.preferences, initialPayload.fullSolutionsRegistry),
            specialPreferences: gpii.matchMakerFramework.utils.findSpecialPreferences(initialPayload.preferences)
        }, fluid.copy(initialPayload));
        gpii.matchMakerFramework.utils.addCapabilitiesInformation(matchMakerInput);
        // remove full solutions registry from the payload, now that we've used it
        // to avoid sending a too large payload to the matchmaker (see GPII-1880)
        delete matchMakerInput.fullSolutionsRegistry;

        return matchMakerInput;
    };

    /**
     * extracts the capabilities from a settingshandler block based on the `capabilities` entry
     * and the inputPaths of the capabilitiesTransformations block
     */
    gpii.matchMakerFramework.utils.extractCapabilities = function (settingsHandler) {
        return fluid.model.transform.collectInputPaths(settingsHandler.capabilitiesTransformations || {});
    };

    /**
     * Takes an array of paths as input and returns them in the ontology provided via the transform spec.
     * The result will be an array list of el-paths in the ontology transformed to.
     *
     * @param {Array} paths - An array of supported capabilities by a solution (as returned by the
     *     gpii.matchMakerFramework.utils.computeCapabilitiesFromSolution function).
     * @param {Object} transformSpec - Transformation rules to transform the input paths from the solution
     *    registry format into the format desired in the output array. If if one would like the result
     *    as a list of ISO24751 el-paths and the solutionsregistry transformations are given in
     *    the flat format, a transformation rules for 'flat' to ISO24751 should be given.
     * @return {Array} An array of el-paths to all the input paths of the given capabilities in the
     *    ontology produced by the transformSpec.
     */
    gpii.matchMakerFramework.utils.transformCapabilitiesToOntologizedLeaves = function (paths, transformSpec) {
        // Input paths are flat so need to be transformed into hierarchical
        var skel = gpii.matchMakerFramework.utils.pathsToSkeleton(paths, true);
        var hskeleton = fluid.model.transformWithRules(skel, transformSpec);

        return gpii.matchMakerFramework.utils.computeLeaves(hskeleton);
    };

    /**
     * Given a solution entry, all the capabilities of that solution will be calculated based on
     * input paths in the transformations (specified in the capabilitiesTransformations block) and
     * on the list in the capabilities block of that solution
     *
     * @param {Object} solution - A single solution entry, as can be found in the solutions registry.
     * @return {Array} An array capabilities supported by the given solution.
    */
    gpii.matchMakerFramework.utils.computeCapabilitiesFromSolution = function (solution) {
        var paths = [];
        fluid.each(solution.settingsHandlers, function (handlerBlock) {
            paths = paths.concat(gpii.matchMakerFramework.utils.extractCapabilities(handlerBlock));
        });
        // grab the capabilities block from the solution if present:
        if (solution.capabilities) {
            paths = paths.concat(solution.capabilities);
        }
        return paths;
    };

    /**
     * Helper function for gpii.matchMakerFramework.utils.computeLeaves - see description there
     */
    var computeLeavesImpl = function (model, path, paths) {
        fluid.each(model, function (value, key) {
            var newPath = fluid.pathUtil.composePath(path, key.toString());
            if (fluid.isPrimitive(value)) {
                paths.push(newPath);
            }
            else {
                computeLeavesImpl(value, newPath, paths);
            }
        });
    };

    /**
     * Function to extract all leaves (i.e. primitive end points) from an object. More specifically,
     * it takes a object (eg. prefs set) and finds all leaves - for each leaf found the path is
     * to an array as an el-path, one path for each leaf.
     *
     * @param {Object} model - The object from which to subtract leaves.
     * @return {Array} An array of el-paths, one entry for each leaf found in the object.
     */
    gpii.matchMakerFramework.utils.computeLeaves = function (model) {
        var paths = [];
        computeLeavesImpl(model, "", paths);
        return paths;
    };

    /**
     * Given a array of el-paths, this function creates an object with a structure that includes
     * all the el-paths in the array. Each of the entries will have the value passed as parameter or
     * defaulting to {} (i.e. the empty object);
     *
     * @param {Array} paths - An array of el-paths that should be present in the resulting object.
     * @param {Any} value - The value that should be assigned to each of the keys given in the el-path array,
     *      if no @value is given, this defaults to the empty object ({}).
     * @return {Object} An object with a structure containing all the el-paths, where each path has
     *     the value given in the parameter.
     */
    gpii.matchMakerFramework.utils.pathsToSkeleton = function (paths, value) {
        var togo = {};
        for (var i = 0; i < paths.length; ++i) {
            var path = paths[i];
            var existing = fluid.get(togo, path, fluid.model.escapedGetConfig);
            if (!existing) {
                fluid.set(togo, path, value || {}, fluid.model.escapedSetConfig);
            }
        }
        return togo;
    };

    /**
     * Given a list of solutions and capabilities, ontologize the capabilities and generate a skeleton based on those.
     *
     * @param {Object} solutions - List of solution entries in the same format as the solutions registry\.
     * @param {Object} capabilities - (array)listings of solution capabilities, keyed by solution ID.
     * @param {Object} transformSpec - Transformation rules to translate from the format the input paths are
     *     given in in the solutions entries' capabilitiesTransformations block, to the ontology
     *     that the skeleton should be in.
     * @return {Object} An object listing the same solutions as the input payload, but where each
     *     solution block instead contains three keys: 'solution' which contains the original solution
     *     entry. 'skeleton' which contains the capabilities of the solution. 'index' which contains
     *     the solution id.
     */
    gpii.matchMakerFramework.utils.expandSolutions = function (solutions, capabilities, transformSpec) {
        return fluid.transform(solutions, function (solution, solutionId) {
            var solutionIdObj = {};
            solutionIdObj["http://registry.gpii.net/applications/" + solutionId] = {};
            var transformedId = fluid.model.transformWithRules(solutionIdObj, transformSpec);

            var paths = gpii.matchMakerFramework.utils.transformCapabilitiesToOntologizedLeaves(capabilities[solutionId], transformSpec);
            var skeleton = fluid.extend(true, {}, gpii.matchMakerFramework.utils.pathsToSkeleton(paths), transformedId);

            return {
                solution: solution,
                skeleton: skeleton,
                index: solutionId
            };
        });
    };

    /**
     * Based on the /enabled terms from a user's preference set and the /enabled capabilities from the solution,
     * this function returns what the 'active' value of the solution should be.
     *
     * @param {Object} specialPreferences - The specialPreferences value of the relevant context (from the value of the same name in the match maker input payload).
     * @param {Array} specialCapabilities - The solutions specialCapabilities (from the value of the same name in the match maker input payload).
     * @param {Object} solution - The solution registry entry of the solution for which to decide the 'active' value.
     * @param {String} solutionId - The solution id.
     * @return {boolean} The value of the 'active' flag of the solution.
     **/
    gpii.matchMakerFramework.utils.getActiveValueFromEnabledTerms = function (specialPreferences, specialCapabilities, solution, solutionId) {
        var active;

        // see if solution has any enabled flags:
        fluid.each(specialCapabilities, function (term) {
            // if we have an /enabled term and this is not just a settings transformation:
            if (term.endsWith("/enabled") && solution.capabilities && solution.capabilities.includes(term)) {
                // set the active flag based on the user's preference value (from solution specific pref or general pref)
                var applicationBlockKey = gpii.matchMakerFramework.utils.makeApplicationTerm(solutionId);
                active = fluid.get(specialPreferences[applicationBlockKey], term, fluid.model.escapedGetConfig);
                if (active === undefined) {
                    active = fluid.get(specialPreferences, term, fluid.model.escapedGetConfig);
                }
            }
        });

        return active;
    };

    /**
     * Function that takes a MM payload set as input that *includes* an entry of
     * preferences in a hierarchical format, as well as a strategy for selecting solutions
     * and a set of transformations rules between ontologies.
     *
     * @param {Object} data - A match maker input payload that includes a translation of the
     *     preferences in an hierarchical ontology, keyed by 'hierarchicalPrefs'.
     * @param {Function} strategy - The strategy to use to select which solutions should be configured and
     *     and launched on the system.
     * @param {Object} transformSpec - Transformation rules FROM the format used in the input paths of the
     *     solutions registry capability transformations TO the format in which the
     *     settings of hierarchicalPrefs in the data argument are given.
     * @return {Object} An object keyed by contexts and where the values are arrays of solutions
     *     to launch in that context.
     */
    gpii.matchMakerFramework.utils.disposeSolutions = function (data, strategy, transformSpec, ontologyMetadata) {
        var solrecs = gpii.matchMakerFramework.utils.expandSolutions(data.solutionsRegistryEntries, data.solutionCapabilities, transformSpec);
        var togo = {};
        // calculate match for each of the contexts
        fluid.each(data.hierarchicalPrefs.contexts, function (context, contextId) {
            var tmpSolrecs = fluid.copy(solrecs);
            // add implicit priorities based on which applications the user has application
            // specific settings for
            gpii.matchMakerFramework.utils.addPriorityFromApplicationSettings(context.preferences, tmpSolrecs);

            // add users explicit application priorities to the solrecs object
            gpii.matchMakerFramework.utils.parsePriorities(context, tmpSolrecs);

            var leaves = gpii.matchMakerFramework.utils.computeLeaves(context.preferences);
            var disposed = strategy(leaves, tmpSolrecs, data, contextId, ontologyMetadata);
            togo[contextId] = {};
            fluid.each(disposed, function (solrec, solid) {
                if (solrec.disposition === "accept") { // only output accepted solutions
                    togo[contextId][solid] = solrec.active; // true if it should be running
                }
            });
        });
        return togo;
    };

    // true if one of the values matches across the two arrays (ignoring the indexing)
    gpii.matchMakerFramework.utils.containsSameValue = function (arr1, arr2) {
        var obj2 = fluid.arrayToHash(arr2);
        // find match across arrays or set to false
        var found = fluid.find(arr1, function (v) {
            return obj2[v];
        }, false);
        return found;
    };

    /**
     * Calculate dispositions based on priorities while taking solution types into account.
     *
     * NOTE: this function will modify the solrecs object by adding, changing or removing the `disposition`,
     * `dispositionReason` and `priority` properties of a solrec[solution] entry.
     *
     * @param {Object} solrecs - A map of solution information, keyed by solution ids. This object should
     *     have a format identical to the output of the gpii.matchMakerFramework.utils.expandSolutions
     *     function. Each entry in this object will potentially be modified by the
     *     modification/addition/deletion of the disposition, priority and/or dispositionReason.
     * @param {Object} data - Contains information about the type each solution is. More precisely,
     *     the value for the key `solutionTypeMapping` is a map of <solutionType name>: <array of
     *     solutionsIds of that type> pairs. The second key, `solutionTypes` is a map of <solutionIds>
     *     with <solution types> as values.
     */
    gpii.matchMakerFramework.utils.disposeFromPriority = function (solrecs, data, contextId) {
        // sort into prioritized map, eg: { 1024: [sola, solb], 200 [solc] }
        var prioritiesMap = {};
        fluid.each(solrecs, function (sol) {
            if (sol.priority) {
                fluid.set(prioritiesMap, [sol.priority, sol.index], true);
            }
        });
        // sort priority entries desc
        var priorities = Object.keys(prioritiesMap).sort(function (a, b) { return b - a; });
        // for each priority bucket:
        for (var i = 0; i < priorities.length; i++) {
            var priority = priorities[i];
            var sols = prioritiesMap[priority];

            // for each solution as sol
            for (var solutionId in sols) {
                var tied = [];
                var solutionType = data.solutionTypes[solutionId];
                // if a disposition is already decided for this solution, or if priority has been
                // removed (in case of ties), ignore it.
                if (solrecs[solutionId].disposition || !solrecs[solutionId].priority) {
                    continue;
                }
                // check if there are any similar typed solution with same priority:
                // for each remaining solution as rsol
                for (var otherId in sols) {
                    // if a disposition is already decided for this solution, or if priority has been
                    // removed (in case of ties), ignore it.
                    if (otherId === solutionId || solrecs[otherId].disposition || !solrecs[otherId].priority) {
                        continue;
                    }
                    // if solutions are of equal type:
                    if (gpii.matchMakerFramework.utils.containsSameValue(solutionType, data.solutionTypes[otherId])) {
                        // since we tie with another solution, resolve by other disposal means
                        tied.push(otherId);
                    }
                }
                // before accepting a solution, make sure all solutions of that type are marked reject
                gpii.matchMakerFramework.utils.rejectFromTypes(data.solutionTypes[solutionId],
                        data.solutionTypeMapping, solrecs,
                        "Another solution of same type with higher priority was found.");

                // if no ties, mark the current solution as "accept"
                if (tied.length === 0) {
                    solrecs[solutionId].disposition = "accept";
                    var prefActive = gpii.matchMakerFramework.utils.getActiveValueFromEnabledTerms(data.specialPreferences[contextId] || {},
                                                                                                data.specialCapabilities[solutionId],
                                                                                                data.solutionsRegistryEntries[solutionId],
                                                                                                solutionId);
                    solrecs[solutionId].active = (prefActive !== undefined) ? prefActive : true;
                    solrecs[solutionId].dispositionReason = "Has a higher priority (" + priority +
                        ") than any solution of the same type";
                } else {
                    // if there are ties, we "unreject" all of them, removing their disposition completely
                    // so they can be tiebreaked by other disposal means (such as via the canopy)
                    tied.push(solutionId);
                    gpii.matchMakerFramework.utils.removePriorityTies(tied, solrecs);
                }
            }
        }
    };

    /**
     * Remove priority and dispositions from tied solutions.
     * Given a list of tied solutionID and solution records, it modifies the solution
     * records by removing all priorities, dispositions and dispositionsReasons from the tied solutions.
     *
     * NOTE: this function will modify the solrecs object
     *
     * @param {Array} tied - An array of solutionIds of tied solutions for which the disposition and
     *     priority information should be removed.
     * @param {Object}:solrecs - A map of solution information, keyed by solution ids. This object should
     *     have a format identical to the output of the gpii.matchMakerFramework.utils.expandSolutions
     *     function, but might contain priority and disposition entries for each solution.
     *     Each tied entry in this object will be modified by this function.
     */
    gpii.matchMakerFramework.utils.removePriorityTies = function (tied, solrecs) {
        fluid.each(tied, function (tiedSolutionId) {
            delete solrecs[tiedSolutionId].priority;
            delete solrecs[tiedSolutionId].disposition;
            delete solrecs[tiedSolutionId].dispositionReason;
            delete solrecs[tiedSolutionId].active;
        });
    };

    /**
     * Rejects all solutions of a given type. This is useful for ensuring that a user does not
     * get eg. multiple versions of screenReader launched. The "solution type" is the apptology
     * type as defined in the apptology ontology - see description in "%gpii-universal/documentation/Apptology.md"
     *
     * NOTE: this function will modify the solrecs object
     *
     * @param {Array} types - An array of solution types.
     * @param {Object} solutionTypeMapping - A hash of solutionTypes with values being arrays of solutionIds
     *     of solutions that are of that type.
     * @param {Object} solrecs - A map of solution information, keyed by solution ids. This object should
     *     have a format identical to the output of the gpii.matchMakerFramework.utils.expandSolutions
     *     function. This object will be modified in the following way: If a solution is rejected
     *     based on its type by this function, that solution entry will have a `disposition: reject`
     *     and dispositionReason added to it.
     * @param {String} disposeReason - The reason to record for rejecting this solution. If this parameter
     *     is not provided, it will default to "Solution rejected due to its type of <type>".
     */
    gpii.matchMakerFramework.utils.rejectFromTypes = function (types, solutionTypeMapping, solrecs, disposeReason) {
        fluid.each(types, function (type) {
            for (var solutionId in solutionTypeMapping[type]) {
                var sol = solrecs[solutionId];
                if (!sol.disposition) {
                    sol.disposition = "accept";
                    sol.active = false;
                    sol.dispositionReason = disposeReason || "Solution accepted but deactivated due to its type of " + type;
                }
            }
        });
    };

    /**
     * Scans the metadata block for application priorities, and for each found, the priority is added
     * to the solrecs object.
     *
     * Given the context section of an preference set, the function will search the metadata section for
     * application priorities. If this is found, the entry for that solution in the solrec object
     * will be modified by the addition of a `priority` key with the value of the user priority.
     *
     * NOTE: this function will modify the solrecs object
     *
     * @param {Object} context - The contextual portion of an preference set - i.e. the part of the preference set that is
     *     inside a single context (the value for the context name key).
     * @param {Object} solrecs - A map of solution information, keyed by solution ids. This object should
     *     have a format identical to the output of the `gpii.matchMakerFramework.utils.expandSolutions`
     *     function. For each solution for which the user has an application priority, this solutions'
     *     entry in solrecs will be modified by the addition of a priority`key.
     */
    gpii.matchMakerFramework.utils.parsePriorities = function (context, solrecs) {
        // for each entry in the metadata block:
        fluid.each(context.metadata, function (metadata) {
            if (metadata.type === "priority") {
                fluid.each(metadata.scope, function (applicationId) {
                    // set the priority of the application if it's part of our solrecs list:
                    var solrec = solrecs[gpii.matchMakerFramework.utils.applicationIdFromTerm(applicationId)];
                    if (solrec) {
                        solrec.priority = metadata.value;
                    }
                });
            }
        });
    };

    gpii.matchMakerFramework.utils.addPriorityFromApplicationSettings = function (preferences, solrecs) {
        fluid.each(preferences.applications, function (value, applicationId) {
            var sol = solrecs[applicationId];
            // If solution is available on the system, and doesn't already have higher priority
            if (sol && (!sol.priority || sol.priority < gpii.matchMakerFramework.APP_SETTING_PRIORITY)) {
                sol.priority = gpii.matchMakerFramework.APP_SETTING_PRIORITY;
            }
        });
    };

    /**
     * Filters preferences to contain only common terms and application specific settings for the solutionId
     */
    gpii.matchMakerFramework.utils.filterPreferencesForSolution = function (solutionId, allPreferences, solutionEntry) {
        var filtered = fluid.copy(allPreferences);

        var applicationString = "http://registry.gpii.net/applications/" + solutionId;

        // find supported common terms:
        var supportedCommonArr = gpii.matchMakerFramework.utils.computeCapabilitiesFromSolution(solutionEntry);
        var supportedCommon = {}; // create object of keys that are unescaped common term URIs and values of true
        fluid.each(supportedCommonArr, function (common) {
            fluid.set(supportedCommon, common, true, fluid.model.escapedSetConfig);
        });

        // move any common terms from the application block to the outer level:
        if (filtered[applicationString]) { // application block for this solution
            fluid.each(filtered[applicationString], function (value, preference) {
                // move all common terms outside application block:
                if (gpii.matchMakerFramework.utils.isCommonTerm(preference)) {
                    filtered[preference] = value;
                    delete filtered[applicationString][preference];
                }
            });
        }

        // top level: filter everything that is not the application block and supported common terms
        return fluid.remove_if(filtered, function (value, preference) {
            // Keep preference if it is a supported common term
            if (gpii.matchMakerFramework.utils.isCommonTerm(preference) && supportedCommon[preference] === true) {
                return false;
            }
            // Also leave the applicaiton specific block
            if (preference.startsWith(applicationString) === true) {
                return false;
            }

            return true;
        });
    };

    /**
     * Function to build the payload required to be the output from the matchmaker framework
     *
     * @param {Object} fullModel - The full input sent to the MM.
     * @param {Object} disposed - Object with keys of context-ids. Each value should be an array listing
     *     the disposed solutions.
     * @return {Object} The data arranged to be compatible with the required MM format.
     */
    gpii.matchMakerFramework.utils.buildReturnPayload = function (fullModel, disposed) {
        var togo = {
            inferredConfiguration: {}
        };

        fluid.each(disposed, function (solArray, contextId) {
            togo.inferredConfiguration[contextId] = {
                applications: {}
            };
            var appBlock = togo.inferredConfiguration[contextId].applications;
            fluid.each(solArray, function (active, solutionId) {
                var filteredSettings = gpii.matchMakerFramework.utils.filterPreferencesForSolution(solutionId, fullModel.preferences.contexts[contextId].preferences, fullModel.solutionsRegistryEntries[solutionId]);
                appBlock[solutionId] = {
                    active: active,
                    settings: filteredSettings
                };
                // TODO: add metadata sections
            });

            // add conditions if they exist:
            if (fullModel.preferences.contexts[contextId].conditions) {
                togo.inferredConfiguration[contextId].conditions = fullModel.preferences.contexts[contextId].conditions;
            }
        });
        return togo;
    };

    /**
     * Merges a set of common term preferences with an already existing preference set. This is
     * used when merging inferred common terms from the MM input payload with the already existing
     * common terms of the preference set. This happens for all the context blocks (for which inferred
     * common terms exist). Existing common terms take priority over the inferred terms
     *
     * @param {Object} preferences - A needs and preference set (including the context blocks).
     * @param {Object} inferred - Inferred common terms, as provided in the MM input.
     * @return {Object} A copy of the preferences object with the inferred common terms merged in.
     */
    gpii.matchMakerFramework.utils.addInferredCommonTermsToPreferences = function (preferences, inferred) {
        var togo = fluid.copy(preferences);
        fluid.each(inferred, function (context, contextId) {
            var tcont = togo.contexts[contextId];
            fluid.each(context, function (settings) {
                tcont.preferences = fluid.extend(true, settings, tcont.preferences);
            });
        });
        return togo;
    };

    /**
     * Simple function that takes a list of capabilities and extract all 'special' capabilities.
     * This is currently all terms ending with /enabled
     *
     * @param {Array} capabilities - An array of term/capabilities.
     * @return {Array} An array of all capabilities that are special (i.e. ends with /enabled).
     **/
    gpii.matchMakerFramework.utils.extractSpecialCapabilities = function (capabilities) {
        return fluid.remove_if(fluid.copy(capabilities), function (term) {
            return !term.endsWith("/enabled");
        });
    };

    /**
     * Adds information about the supported capabilities for each solution (in the flat format) and special capabilities.
     * Two things will be added to the payload:
     * (1) A list of inputPaths from the capabilitiesTransformations of the settingshandlers as well as the content of the solutions "capabiliites" entry.
     * (2) A list of special capabilities, meaning the (1) list run through the extractSpecialCapabilities function
     *
     * NOTE: This will modify the supplied payload
     *
     * @param {Object} payload - An object with the format of a standard matchmaker input payload. At a very
     *     minimum this payload should have a `solutionsRegistryEntries` key with a hashmap of
     *     (solutionID => solution registry entry) pairs. Note that this object will be modified by
     *     addition of two toplevel keys: `solutionTypes` and `solutionTypeMapping.
     */
    gpii.matchMakerFramework.utils.addCapabilitiesInformation = function (payload) {
        fluid.each(payload.solutionsRegistryEntries, function (solution, solutionId) {
            var capabilities = gpii.matchMakerFramework.utils.computeCapabilitiesFromSolution(solution);
            fluid.set(payload, [ "solutionCapabilities", solutionId ], capabilities);
            fluid.set(payload, [ "specialCapabilities", solutionId ], gpii.matchMakerFramework.utils.extractSpecialCapabilities(capabilities));
        });
    };

    /**
     * Adds information about the solutions types to the payload paramater, which should be in the
     * format of an input payload for matchmakers.
     *
     * Two keys are added to the given payload:
     * `solutionTypes` is a hash of solutionId->list of the solution types it is
     * `solutionTypeMapping` is a hash of solutionType->array of solutionIds of that type
     *
     * NOTE: this function will modify the supplied `payload`
     *
     * @param {Object} payload - An object with the format of a standard matchmaker input payload. At a very
     *     minimum this payload should have a `solutionsRegistryEntries` key with the solution entries as well
     *     as a 'solutionCapabilities' key, which contains information about a solutions capabilities (i.e. via
     *     the addCapabilitiesInformation function).
     * @param {Object} transformSpec - ontology transform spec translating from common terms into
     *     a solution type ontology.
     */
    gpii.matchMakerFramework.utils.addSolutionTypeInformation = function (payload, transformSpec) {
        fluid.each(payload.solutionCapabilities, function (capabilities, solutionId) {
            // first get an array of what solution types the current entry is:
            var solutionTypes = gpii.matchMakerFramework.utils.transformCapabilitiesToOntologizedLeaves(capabilities, transformSpec);
            fluid.set(payload, [ "solutionTypes", solutionId], solutionTypes);
            // now add solution ID to the return array in the appropriate places:
            for (var i in solutionTypes) {
                // add solution ID to the solution type
                fluid.set(payload, ["solutionTypeMapping", solutionTypes[i], solutionId], true);
            }
        });
    };

    gpii.matchMakerFramework.utils.isApplicationTerm = function (term) {
        return term.startsWith("http://registry.gpii.net/applications/");
    };

    gpii.matchMakerFramework.utils.isCommonTerm = function (term) {
        return term.startsWith("http://registry.gpii.net/common/");
    };

    gpii.matchMakerFramework.utils.applicationIdFromTerm = function (term) {
        return term.substring("http://registry.gpii.net/applications/".length);
    };

    gpii.matchMakerFramework.utils.makeApplicationTerm = function (applicationId) {
        return "http://registry.gpii.net/applications/" + applicationId;
    };

    gpii.matchMakerFramework.utils.inferCommonTermsFromApplicationsPrefs = function (prefsId, prefsBlock, flattenedSolutionsRegistry) {
        var togo = {};
        if (gpii.matchMakerFramework.utils.isApplicationTerm(prefsId)) {
            var solutionId = gpii.matchMakerFramework.utils.applicationIdFromTerm(prefsId);
            // add any common terms from the application block directly as inferred:
            togo[solutionId] = fluid.remove_if(fluid.copy(prefsBlock), function (val, key) {
                return (!gpii.matchMakerFramework.utils.isCommonTerm(key)); // keep if it's a common term
            });
            // transform the application specific settings and add them to inferred list
            if (solutionId in flattenedSolutionsRegistry) {
                var entry = flattenedSolutionsRegistry[solutionId];
                fluid.each(entry.settingsHandlers, function (handler) {
                    var inverseRules;
                    if (handler.inverseCapabilitiesTransformations !== undefined) {
                        // use explicit inverses if available
                        inverseRules = handler.inverseCapabilitiesTransformations;
                    } else {
                        // else fall back to using the framework's automatic inversion features
                        inverseRules = handler.capabilitiesTransformations !== undefined ?
                            fluid.model.transform.invertConfiguration(handler.capabilitiesTransformations) : {};
                    }

                    var transformed = fluid.model.transformWithRules(prefsBlock, inverseRules);
                    var out = {};
                    fluid.set(out, [solutionId], transformed);
                    fluid.extend(true, togo, out);
                });
            }
        }
        return togo;
    };

    /**
     * Given a preference set, return a nested structure of context->appliactionBlock->special setting->value
     * and context->special setting->value.
     *
     * This function will walk an preference set and look for any /enabled terms. Anything that is not an /enabled
     * term will not be kept. A structure if returned containing the contexts on the outer level. Each context
     * will have any non application specific /enabled terms, as well as any application block with its contained
     * /enabled terms.
     *
     * @preferences {Object} a preference set
     * @return {Object} The preference set with only context names and /enabled terms
    */
    gpii.matchMakerFramework.utils.findSpecialPreferences = function (preferences) {
        return fluid.transform(fluid.copy(preferences.contexts), function (context) {
            var togo = {};
            fluid.each(context.preferences, function (prefsBlock, prefsId) {
                if (prefsId.endsWith("/enabled")) {
                    togo[prefsId] = prefsBlock;
                } else if (gpii.matchMakerFramework.utils.isApplicationTerm(prefsId)) {
                    var applicationId = gpii.matchMakerFramework.utils.applicationIdFromTerm(prefsId);
                    fluid.each(prefsBlock, function (appPrefVal, appPrefId) {
                        if (appPrefId.endsWith("/enabled")) {
                            fluid.set(togo, [ applicationId, appPrefId ], appPrefVal);
                        }
                    });
                }
            });
            return togo;
        });
    };

    /**
     * Converts application specific settings into common terms, keyed by application ids. Given a
     * set of preferences, for each application block in those preferences, the settings for which
     * inverse transformations exist will be transformed into common terms. All the common terms
     * that have successfully been inferred from an application will be written to a block keyed by
     * that application's ID.
     *
     * Note that we're fetching the solution registry for all platforms. The reason is that if the
     * user has e.g. application specific preferences for a Linux solution, we need that solution
     * registry entry to be able to infer common terms - even if the user is currently on a Windows
     * platform. We could consider loading specific application entries as needed - this is
     * described in GPII-2140.
     *
     * @param {Object} preferences - An preference set (including contexts, etc).
     * @param {Object} fullSolutionsRegistry - The solutionsRegistries, keyed by OS.
     * @return {Object} - Object whose keys are solution IDs and entries are common term
     *      preferences which have been transformed from application specific settings for that
     *      solution.
     */
    gpii.matchMakerFramework.utils.inferCommonTerms = function (preferences, fullSolutionsRegistry) {
        var flattenedSolutionsRegistry = {};
        fluid.each(fullSolutionsRegistry, function (entry) {
            fluid.extend(flattenedSolutionsRegistry, entry);
        });
        var togo = {};
        fluid.each(preferences.contexts, function (context, contextId) {
            togo[contextId] = {};
            fluid.each(context.preferences, function (prefsBlock, prefsId) {
                var inferred = gpii.matchMakerFramework.utils.inferCommonTermsFromApplicationsPrefs(
                    prefsId, prefsBlock, flattenedSolutionsRegistry);
                fluid.extend(true, togo[contextId], inferred);
            });
        });
        return togo;
    };

    gpii.matchMakerFramework.utils.updateSingleInferredConfiguration = function (inferredConfiguration, context, pref, value, solutionId) {
        if (solutionId) {
            var path = [ context, "applications", solutionId, "settings", pref ];
            if (fluid.get(inferredConfiguration, path) !== undefined) {
                fluid.set(inferredConfiguration, path, value);
            }
        } else {
            // if solutionId is not provided, loop through all solutions and update the preference value
            // (if the preference is already set in the solution)
            fluid.each(inferredConfiguration[context].applications, function (sol) {
                if (sol.settings[pref] !== undefined) {
                    sol.settings[pref] = value;
                }
            });
        }
    };

    /**
     * Takes a set of preferences and runs through the inferredConfiguration, updating all instances
     * matching preferences/settings within the application with the new values from the preferences
     * set.
     *
     * This feature is required by the PSP to allow updating e.g. a top-level common term and
     * ensuring that the relevant applications are affected by it
     */
    gpii.matchMakerFramework.utils.updateInferredConfiguration = function (preferences, inferredConfiguration, solutionsRegistryEntries) {
        var inferred = fluid.copy(inferredConfiguration);
        fluid.each(preferences.contexts, function (contextBlock, contextName) {
            fluid.each(contextBlock.preferences, function (val, pref) {
                if (gpii.matchMakerFramework.utils.isCommonTerm(pref)) {
                    gpii.matchMakerFramework.utils.updateSingleInferredConfiguration(inferred, contextName, pref, val);
                } else if (gpii.matchMakerFramework.utils.isApplicationTerm(pref)) {
                    var solutionId = gpii.matchMakerFramework.utils.applicationIdFromTerm(pref);
                    fluid.each(val, function (solPrefVal, solPref) {
                        gpii.matchMakerFramework.utils.updateSingleInferredConfiguration(inferred, contextName, solPref, solPrefVal, solutionId);
                    });
                }
            });
            // get active value from */enabled preferences:
            fluid.each(inferred[contextName].applications, function (solutionBlock, solutionId) {
                var solutionCapabilities = fluid.get(solutionsRegistryEntries, [ solutionId, "capabilities" ]) || {};
                var active = gpii.matchMakerFramework.utils.getActiveValueFromEnabledTerms(contextBlock.preferences, solutionCapabilities,
                        solutionsRegistryEntries[solutionId], solutionId);
                if (active !== undefined) {
                    solutionBlock.active = active;
                }
            });
        });
        return inferred;
    };

    /**
     * Given an inferred configuration this function creates a listing of "allowed" preferences and settings,
     * meaning a list of settings and preferences present in the inferred configuration. Any common term
     * encountered in the inferred configuration is added to the list as top level keys with a value of true. Any application
     * specific term will be added under a top level key of: "http://registry.gpii.net/applications/<app-id>". The
     * resulting "allowed" list will be built based on preferences and settings from all the "contexts" in the
     * inferred configuration (i.e. all the contexts of the preference set)
     */
    gpii.matchMakerFramework.utils.extractAllowedPreferences = function (inferredConfiguration) {
        var allowed = {};
        fluid.each(inferredConfiguration, function (context) {
            fluid.each(context.applications, function (app, appId) {
                allowed["http://registry.gpii.net/applications/" + appId] = {}; // mark the solution in allowed
                fluid.each(app.settings, function (val, term) {
                    if (term.startsWith("http://registry.gpii.net/applications/")) {
                        allowed[term] = val; // copy all application specific values to a flat application block key
                        return;
                    }
                    allowed[term] = true;
                });
            });
        });
        return allowed;
    };

    /**
     * Filter a preference set based on the preferences available in the inferred configuration. This is used to
     * ensure that no preferences are passed in the preference set that are not already given via the inferred configuration,
     * which is useful for the something like the untrusted flowmanager model.
     */
    gpii.matchMakerFramework.utils.filterPreferencesFromInferredConfig = function (preferences, inferredConfiguration) {
        // Get the list of allowed terms
        var allowed = gpii.matchMakerFramework.utils.extractAllowedPreferences(inferredConfiguration);

        var togo = fluid.censorKeys(preferences, ["contexts"]);
        togo.contexts = fluid.transform(fluid.copy(preferences).contexts, function (context) {
            context.preferences = fluid.remove_if(context.preferences, function (val, term) {
                // if it's an application block
                if (term.startsWith("http://registry.gpii.net/applications/")) {
                    if (allowed[term] === undefined) { // if the application is not in the allowed terms, remove it
                        return true;
                    }

                    fluid.remove_if(val, function (appVal, appTerm) {
                        // remove if not found as top level common term and it's not in the application specific allowed
                        // terms block
                        return (allowed[appTerm] !== true && (fluid.get(allowed, [ term, appTerm ]) === undefined));
                    });
                } else {
                    return allowed[term] !== true;
                }
            });
            return context;
        });
        return togo;
    };

    gpii.matchMakerFramework.utils.livenessOrdering = [
        "OSRestart",
        "manualRestart",
        "liveRestart",
        "live"
    ];

    /**
     * Given one or more solutions registry entries and optionally a term, this function will walk each
     * solution (and its settingshandlers) and find the lowest liveness for any of the solutions. If a term is
     * given, the liveliness reported is the lowest of those settingshandlers which supports that term
     * (decided via its capabilities and/or capabilitiesTransformations). The lowest or least
     * liveness is dictated by gpii.matchMakerFramework.utils.livenessOrdering, where a lower
     * index means less/lower liveness.
     *
     * @param {Array or Object} solutions - A list of the solutions that should be search for support of the term.
     * @param {String} term - (Optional) The term to find the liveness for.
     * @return {String} Returns the lowest/least liveness found by any solution provided that supports the term.
     */
    gpii.matchMakerFramework.utils.getLeastLiveness = function (solutions, term) {
        var leastLiveness;
        fluid.each(solutions, function (solution) {
            fluid.each(solution.settingsHandlers, function (handler) {
                if (term !== undefined) {
                    // if term is defined, only check liveness of block if the term is within the capabilities
                    // of the block. If not, simply skip to next block
                    var capabilities = gpii.matchMakerFramework.utils.extractCapabilities(handler);
                    if (capabilities && capabilities.indexOf(fluid.pathUtil.composeSegments(term)) === -1) {
                        return;
                    }
                }

                // if the liveness of term in current solution is lower than any previously checked solutions
                var livenessOrder = gpii.matchMakerFramework.utils.livenessOrdering.indexOf(handler.liveness);
                if (leastLiveness === undefined || livenessOrder < leastLiveness) {
                    leastLiveness = livenessOrder;
                }
            });
        });
        return gpii.matchMakerFramework.utils.livenessOrdering[leastLiveness];
    };
})();
