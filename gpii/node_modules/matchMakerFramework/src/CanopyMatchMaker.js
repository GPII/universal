/*!
GPII Canopy Matchmaker

Copyright 2012 OCAD University
Copyright 2012 Antranig Basman

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

The research leading to these results has received funding from the European Union's
Seventh Framework Programme (FP7/2007-2013) under grant agreement no. 289016.

You may obtain a copy of the License at
https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

"use strict";

var fluid = fluid || require("infusion");

(function () {
    var gpii = gpii || fluid.registerNamespace("gpii");
    fluid.registerNamespace("gpii.matchMakerFramework.utils");
    fluid.registerNamespace("gpii.matchMaker.canopy");

    gpii.matchMaker.canopy.computeFitness = function (leaves, solution) {
        var vector = [];
        for (var i = 0; i < leaves.length; ++i) {
            var leaf = leaves[i];
            vector[i] = gpii.matchMakerFramework.utils.prefixLength(leaf, solution);
        }
        vector = vector.sort(gpii.matchMakerFramework.utils.sortDescending);
        return vector;
    };

    gpii.matchMaker.canopy.compareFitness = function (solA, solB) {
        var i = 0, fitA = solA.fitness, fitB = solB.fitness;
        for (; ; ++i) {
            var endA = i === fitA.length, endB = i === fitB.length;
            if (endA || endB) {
                return endA && endB ? 0 : (endB ? -1 : 1);
            }
            var diff = fitB[i] - fitA[i];
            if (diff !== 0) {
                return diff;
            }
        }
    };

    gpii.matchMaker.canopy.sortSolutions = function (solutions) {
        return solutions.sort(gpii.matchMaker.canopy.compareFitness);
    };

    gpii.matchMaker.canopy.bestCoverage = function (leaves, soln) {
        var best = Number.NEGATIVE_INFINITY;
        for (var i = 0; i < leaves.length; ++i) {
            var leaf = leaves[i];
            var good = gpii.matchMakerFramework.utils.prefixLength(leaf, soln.solution);
            best = Math.max(good, best);
        }
        return best;
    };



    gpii.matchMaker.canopy.rankSolutions = function (leaves, solrecs) {
        fluid.each(solrecs, function (solrec) {
            solrec.fitness = gpii.matchMaker.canopy.computeFitness(leaves, solrec.skeleton);
        });
        solrecs = gpii.matchMaker.canopy.sortSolutions(solrecs);
        return solrecs;
    };

    gpii.matchMaker.canopy.disposeStrategy = function (leaves, solrecs) {
        var ranked = gpii.matchMaker.canopy.rankSolutions(leaves, solrecs);
        var disposed = gpii.matchMaker.canopy.disposeSolutionsImpl(leaves, ranked);
        return disposed;
    };

    gpii.matchMaker.canopy.disposeSolutionsImpl = function (leaves, solrecs) {
        var canopy = fluid.transform(leaves, function () {
            return Number.NEGATIVE_INFINITY;
        });

        for (var i = 0; i < solrecs.length; ++i) {
            var sol = solrecs[i];
            var inCanopy = false;
            for (var j = 0; j < leaves.length; ++j) {
                var depth = gpii.matchMakerFramework.utils.prefixLength(leaves[j], sol.skeleton);
                if (depth > canopy[j]) {
                    inCanopy = true;
                    canopy[j] = depth;
                }
            }
            if (inCanopy) {
                solrecs[i].disposition = "accept";
            }
            else {
                solrecs[i].disposition = "reject";
            }
        }
        return solrecs;
    };

    /** Returns a non-positive number indicating by how many path segments the supplied
     * path fails to index correctly into the supplied model. A return value of 0
     * indicates that the path indexes fully */
     // only used by canopy MM  - moved from MatchMakerFramework
    gpii.matchMakerFramework.utils.prefixLength = function (path, model) {
        var segs = fluid.pathUtil.parseEL(path);
        for (var i = 0; i < segs.length; ++i) {
            var seg = segs[i];
            model = model[seg];
            if (model === undefined) {
                return i - segs.length;
            }
        }
        return 0;
    };

    // only used by canopyMatchMaker - moved from MatchMakerFramework
    gpii.matchMakerFramework.utils.extractDispositions = function (solrecs) {
        var togo = [];
        fluid.each(solrecs, function (soln) {
            togo[soln.index] = soln.disposition;
        });
        return togo;
    };

    // only used by canopyMatchMaker - moved from MatchMakerFramework
    gpii.matchMakerFramework.utils.sortDescending = function (numA, numB) {
        return numB - numA;
    };

    // TODO: UNUSED FUNCTION
    gpii.matchMakerFramework.utils.makeComparator = function (leaves) {
        return function (solnA, solnB) {
            var domA = false, domB = false;
            for (var i = 0; i < leaves.length; ++i) {
                var leaf = leaves[i];
                var goodA = gpii.matchMakerFramework.utils.prefixLength(leaf, solnA.solution);
                var goodB = gpii.matchMakerFramework.utils.prefixLength(leaf, solnB.solution);
                if (goodA > goodB) {
                    domA = true;
                }
                else if (goodB > goodA) {
                    domB = true;
                }
            }
            return domA ^ domB ? (domA ? 1 : -1) : 0;
        };
    };

})();
