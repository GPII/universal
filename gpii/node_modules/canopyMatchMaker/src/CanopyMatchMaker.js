/*
* Canopy Match Maker
*
* Copyright 2015 Raising the Floor - International
*
* Licensed under the New BSD license. You may not use this file except in
* compliance with this License.
*
* The research leading to these results has received funding from the European Union's
* Seventh Framework Programme (FP7/2007-2013)
* under grant agreement no. 289016.
*
* You may obtain a copy of the License at
* https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

/* global require */
"use strict";

var fluid = fluid || require("infusion"),
    gpii = fluid.registerNamespace("gpii");

fluid.require("kettle", require);
fluid.registerNamespace("gpii.canopyMatchMaker");

fluid.defaults("gpii.canopyMatchMaker", {
    gradeNames: ["kettle.app"],
    components: {
        ontologyHandler: {
            "type": "gpii.ontologyHandler"
        }
    },
    requestHandlers: {
        matchPost: {
            route: "/match",
            method: "post",
            type: "gpii.canopyMatchMaker.matchPost.handler"
        }
    },
    invokers: {
        match: {
            funcName: "gpii.canopyMatchMaker.match",
            args: [ "{ontologyHandler}", "{arguments}.0", "{that}.disposeStrategy"]
        },
        disposeStrategy: {
            funcName: "gpii.canopyMatchMaker.utils.disposeStrategy",
            args: [ "{arguments}.0", "{arguments}.1", "{arguments}.2", "{arguments}.3"]
                    // leaves, solrecs, augmented MM input payload, ontologyMetadata
        }
    }
});

fluid.defaults("gpii.canopyMatchMaker.matchPost.handler", {
    gradeNames: ["kettle.request.http"],
    invokers: {
        handleRequest: {
            funcName: "gpii.canopyMatchMaker.matchPost.handleRequest",
            args: ["{gpii.canopyMatchMaker}", "{request}", "{request}.req.body"]
        }
    }
});

/**
 * Initial function to be called when the user hits the /match URL. Simply calls the
 *  gpii.canopyMatchMaker.match function and fires the 'onSuccess' event with the result
 */
gpii.canopyMatchMaker.matchPost.handleRequest = function (canopyMatchMaker, request, body) {
    var matchedSolutions = canopyMatchMaker.match(body);
    request.events.onSuccess.fire(matchedSolutions);
};

/*
 * Main function of the canopy matchmaker. Ensures that the inferred common terms are taken
 * into account and that the preferences are stored in a hierarchical format, needed by
 * the canopy MM, and then runs the frameworks' 'disposeSolutions' function with the
 * canopyMatchMaker.disposeStrategy strategy. The correct output format is ensured by the
 * buildReturnPayload function of the MM framework.
 */
gpii.canopyMatchMaker.match = function (ontologyHandler, payload, disposeStrategy) {
    // augment payload with inferred common terms
    payload.preferences = gpii.matchMakerFramework.utils.addInferredCommonTerms(payload.preferences, payload.inferredCommonTerms);

    // augment payload with information about the solution types
    var appTransformSpec = gpii.ontologyHandler.getTransformSpec(ontologyHandler.ontologyTransformSpecs, "flat", "apptology");
    gpii.matchMakerFramework.utils.addSolutionTypeInformation(payload, appTransformSpec);

    // Add hierarchical ISO24751 version preferences
    payload.hierarchicalPrefs = ontologyHandler.prefsToOntology(payload.preferences, "flat", "ISO24751");

    var transformSpec = gpii.ontologyHandler.getTransformSpec(ontologyHandler.ontologyTransformSpecs, "flat", "ISO24751");

    var ontologyMetadata = ontologyHandler.ontologyMetadata.ISO24751;

    var disposed = gpii.matchMakerFramework.utils.disposeSolutions(payload, disposeStrategy, transformSpec, ontologyMetadata);
    return gpii.matchMakerFramework.utils.buildReturnPayload(payload, disposed);
};
