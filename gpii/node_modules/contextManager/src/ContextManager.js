/*
* Context Manager
*
* Copyright 2014 Raising the Floor - International
*
* Licensed under the New BSD license. You may not use this file except in
* compliance with this License.
*
* The research leading to these results has received funding from the European Union's
* Seventh Framework Programme (FP7/2007-2013)
* under grant agreement no. 289016.
*
* You may obtain a copy of the License at
* https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

/* global require */
(function () {
    "use strict";

    var fluid = require("infusion"),
        gpii = fluid.registerNamespace("gpii"),
        $ = fluid.registerNamespace("jQuery");

    fluid.registerNamespace("gpii.contextManager");

    fluid.defaults("gpii.contextManager", {
        gradeNames: ["fluid.eventedComponent", "autoInit"],
        members: {
            currentContext: {},
            temporalIntervalID: null
        },
        components: {
            transformer: {
                type: "gpii.transformer"
            },
            lifecycleManager: {
                type: "gpii.lifecycleManager"
            }
        },
        invokers: {
            evaluateMatch: {
                funcName: "gpii.contextManager.evaluateMatch",
                args: [ "{that}", "{arguments}.0", "{arguments}.1", "{arguments}.2" ]
            },
            reEvaluateConditions: {
                funcName: "gpii.contextManager.reEvaluateConditions",
                args: [ "{that}", "{flowManager}" ]
            }
        },
        listeners: {
            onCreate: "gpii.contextManager.startTemporalEnvironmentReporter",
            onDestroy: "gpii.contextManager.stopTemporalEnvironmentReporter"
        }
    });

    fluid.defaults("kettle.requests.request.handler.environmentChanged", {
        gradeNames: ["autoInit", "fluid.littleComponent"],
        invokers: {
            handle: {
                funcName: "gpii.contextManager.environmentChanged",
                args: ["{flowManager}.contextManager", "{request}.req.body", "{requestProxy}.events.onSuccess"],
                dynamic: true
            }
        }
    });

    gpii.contextManager.startTemporalEnvironmentReporter = function (that) {
        that.intervalID = setInterval(function() {
            gpii.contextManager.environmentChanged(that, {
                // set in ms since UTC epoch, eg: 1421066816897
                "http://registry.gpii.net/common/environment/temporal.time": (new Date()).getTime()
            });
        }, 20000); //report time every 20 seconds
    };

    gpii.contextManager.stopTemporalEnvironmentReporter = function (that) {
        clearInterval(that.intervalID);
    };

    gpii.contextManager.environmentChanged = function (that, body, event) { // event is optional
        // add the new context to the existing contexts:
        var currentContext = that.currentContext;
        fluid.each(body, function (newValue, contextId) {
            if (contextId === "timestamp") { // ignore timestamps
                return;
            }
            currentContext[contextId] = newValue;
        });
        fluid.log("Context has been updated to: "+JSON.stringify(currentContext, null, 4));
        // re-evaluate the context and matchData based on the new context
        that.reEvaluateConditions();
        if (event) {
            event.fire();
        }
    };

    gpii.contextManager.reEvaluateConditions = function (that, flowManager) {
        // find logged in users
        var activeSessions = flowManager.lifecycleManager.getActiveSessionTokens();
        // if none is logged in, do nothing
        if (activeSessions.length === 0) {
            return;
        }
        var activeSession = flowManager.lifecycleManager.getSession(activeSessions);
        var newActiveContexts = gpii.contextManager.utils.findActiveContexts(that.currentContext, activeSession.matchedData);
        console.log("New active contexts: " + newActiveContexts);
        if (newActiveContexts[0] === activeSession.appliedContext) {
            console.log("Same context as before (" + activeSession.appliedContext + ") so doing nothing");
            return;
        }
        var sessionChanges = {
            appliedContext: newActiveContexts[0],
            appliedConfiguration: activeSession.matchedData.inferredConfiguration[newActiveContexts[0]]
        };
        var lifecycleInstructions = flowManager.transformer.settingsHandlerToLifecycle(sessionChanges.appliedConfiguration, activeSession.solutionsRegistry);

        flowManager.lifecycleManager.update({ userToken: activeSession.userToken }, lifecycleInstructions, function (response) {
            if (response.success) {
                $.extend(true, activeSession, sessionChanges);
            }
            console.log("Successfully updated configuration triggered by context changes");
        });
    };

    /*
     * Function to take the full output of a matchmaking process, evaluate the current context,
     * and decide which context should currently be used. The application block for this context
     * is passed on in the event passed as parameter.
     *
     * @that (Object) - gpii.contextManager object
     * @matchedData (Object) - the output of a matchmaking process, or an object that is in a
     *      similar format
     * @toSession (Object) - the original data sent to the matchmakers. This is amongst other used
     *      when solutionsRegistry data is needed, etc.
     * @event (Object) - the event to be fired with the result of this function - ie. the relevant
     *      part of the `matchData` block, based on the current context
     */
    gpii.contextManager.evaluateMatch = function (that, matchedData, toSession, event) {
        console.log("gpii.contextManager.evaluateMatch called");

        var activeContexts = gpii.contextManager.utils.findActiveContexts(that.currentContext, matchedData);

        // save highest priority context as the applied one
        toSession.appliedContext = activeContexts[0];
        toSession.appliedConfiguration = matchedData.inferredConfiguration[toSession.appliedContext] || {};
        toSession.matchedData = matchedData;

        // TODO: consider moving this transformation call elsewhere
        var lifecycleInstructions = that.transformer.settingsHandlerToLifecycle(toSession.appliedConfiguration, toSession.solutionsRegistry);

        event.fire(lifecycleInstructions, toSession);
    };
})();