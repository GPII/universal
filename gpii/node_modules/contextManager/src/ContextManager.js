/*
* Context Manager
*
* Copyright 2014 Raising the Floor - International
*
* Licensed under the New BSD license. You may not use this file except in
* compliance with this License.
*
* The research leading to these results has received funding from the European Union's
* Seventh Framework Programme (FP7/2007-2013)
* under grant agreement no. 289016.
*
* You may obtain a copy of the License at
* https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

"use strict";

var fluid = require("infusion"),
    gpii = fluid.registerNamespace("gpii");


fluid.defaults("gpii.contextManager.app", {
    gradeNames: "kettle.app",
    components: {
        contextManager: {
            type: "gpii.contextManager"
        }
    },
    requestHandlers: {
        environmentChanged: {
            route: "/environmentChanged",
            method: "put",
            type: "gpii.contextManager.environmentChanged.handler"
        }
    }
});

fluid.defaults("gpii.contextManager.environmentChanged.handler", {
    gradeNames: ["kettle.request.http"],
    invokers: {
        handleRequest: {
            funcName: "gpii.contextManager.environmentChanged.handleRequest",
            args: ["{flowManager}.contextManager", "{request}.req.body", "{request}.events.onSuccess"]
        }

    }
});

/**
 * Request handler for URL /environmentChanged. Forwards the content to environmentChanged
 * function and fires the onSuccess event.
 *
 * @that {Object} The context manager component
 * @body {Object} the body of the request. It is expected to contain only key-value pairs
 *      of context variables, and optionally a 'timestamp' key (and associated value) which
 *      will not be considered part of the current context
 * @onSuccess {Object} onSuccess event - will be fired with empty content
 **/
gpii.contextManager.environmentChanged.handleRequest = function (that, body, onSuccess) {
    gpii.contextManager.onEnvironmentChanged(that, body);
    onSuccess.fire();
};

fluid.defaults("gpii.contextManager", {
    gradeNames: "fluid.modelComponent",
    members: {
        temporalIntervalID: null
    },
    components: {
        transformer: {
            type: "gpii.transformer"
        }
    },
    invokers: {
        evaluateMatch: {
            funcName: "gpii.contextManager.evaluateMatch",
            args: [ "{that}", "{arguments}.0"]
        },
        environmentChanged: "gpii.contextManager.onEnvironmentChanged({that}, {arguments}.0)" // body
    },
    modelListeners: {
        currentContext: {
            funcName: "gpii.contextManager.evaluateConditions",
            args: [ "{that}", "{lifecycleManager}", "{change}.value" ]
        }
    },
    listeners: {
        onCreate: "gpii.contextManager.startTemporalEnvironmentReporter",
        onDestroy: "gpii.contextManager.stopTemporalEnvironmentReporter"
    }
});


/**
 * Responsible for weeding out any information from the request body that is not strictly
 * context variables and then notifying the applier.
 *
 * @that {Object} The context manager component
 * @body {Object} the body of the request. It is expected to contain only key-value pairs
 *      of context variables, and optionally a 'timestamp' key (and associated value) which
 *      will not be considered part of the current context
 **/
gpii.contextManager.onEnvironmentChanged = function (that, body) {
    var newContext = fluid.copy(body);
    delete newContext.timestamp;
    fluid.log("contextManager: Updating context with: " + JSON.stringify(newContext, null, 4));
    that.applier.change("currentContext", newContext);
};



/**
 * Function to start the "Temporal reporter". Will report timerelated contexts every 20 seconds.
 * It reports both the timestamp and timeOfDay context variables via manual calls to the
 * gpii.contextManager.environmentChanged function
 *
 * TODO: The timezone here is retrieved based on the system time - the geographical location
 * of the user is not taken into account (unless the OS does so by default) - see GPII-1105
 *
 * @that {Object} The context manager object
 **/
gpii.contextManager.startTemporalEnvironmentReporter = function (that) {
    that.intervalID = setInterval(function () {
        var date = new Date();
        gpii.contextManager.onEnvironmentChanged(that, {
            // ms since UTC epoch, eg: 1421066816897
            "http://registry.gpii.net/common/environment/timestamp": date.getTime(),
            // time of day, eg: "18:30"
            "http://registry.gpii.net/common/environment/timeOfDay": date.getHours() + ":" + date.getMinutes()
        });
    }, 20000); //report time every 20 seconds
};

/**
 * Triggered on destruction of the context manager component. Stops the temporal reporters
 * time reports
 *
 * @that {Object} The context manager object
 **/
gpii.contextManager.stopTemporalEnvironmentReporter = function (that) {
    clearInterval(that.intervalID);
};

/**
 * This function is listening to the changeApplier of the contextManager ("currentContext" path)
 *
 * On changes to the currentContext part of the model it will:
 * 1) parse the context against the currently logged in users' conditions
 * 2) if the new calculated active context is different from the currently applied context,
 *    the lifecycle managers update functionality will be called and the applied context and
 *    configuration will be stored in the active session of the lifecycle manager.
 *
 * @that {Object} The context manager object
 * @lifecycleManager {Object} the lifecycleManager component from which the current
 *    session will be retrieved
 * @context {Object} The model as reporterd by the changeApplier (i.e. the content of
 *    that.model.currentContext)
 **/
gpii.contextManager.evaluateConditions = function (that, lifecycleManager, context) {
    // find logged in users
    var activeSessions = lifecycleManager.getActiveSessionTokens();
    // if noone is logged in, do nothing
    if (activeSessions.length === 0) {
        return;
    }
    var activeSession = lifecycleManager.getSession(activeSessions);
    var newActiveContexts = gpii.contextManager.utils.findActiveContexts(context, activeSession.model.matchMakerOutput);
    fluid.log("contextManager: New active contexts: " + newActiveContexts);
    if (newActiveContexts[0] === activeSession.activeContextName) {
        fluid.log("contextManager: Same context as before (" + activeSession.model.appliedContext + ") so doing nothing");
        return;
    }
    var activeConfiguration = activeSession.model.matchMakerOutput.inferredConfiguration[newActiveContexts[0]];
    var finalPayload = {
        userToken: activeSession.model.userToken,
        activeContextName: newActiveContexts[0],
        activeConfiguration: activeConfiguration
    };

    var response = lifecycleManager.update(finalPayload);
    response.then(function () {
        // Delete these this to avoid the 'lifecycleInstructions' block being attached
        // to the sessionState in the next line. LifecycleInstructions is only used in the
        // "finalPayload" as instructions on how to configure the system.. once configured,
        // the applied settings are stored in 'activeConfiguration'
        delete finalPayload.lifecycleInstructions;
        // TODO: This is pretty rubbish, why isn't the natural action of lifecycleManager.update good enough here?
        activeSession.applier.change("", finalPayload); // TODO: this will need to be a "MERGE" in time
        fluid.log("contextManager: Successfully updated configuration triggered by context changes");
    }, function () {
        fluid.log(fluid.logLevel.ERROR, "contextManager: Failed to apply newly evaluated conditions");
    });
};

/*
 * Function to take the full output of a matchmaking process, evaluate the current context,
 * and decide which context should currently be used. The application block for this context
 * is passed on in the event passed as parameter.
 *
 * @param that {Object} - gpii.contextManager object
 * @param fullPayload {Object} - the full structure fired from gpii.flowManager.transformLifecycle - a structure containing, in addition to
 * all fields from matchMakerInput payload (userToken, preferences, solutionsRegistryEntries, deviceContext):
 *     activeConfiguration {Object} - the the system configuration consisting of lifecycle instructions ready to be
 *     sent to the lifecycle manager
 * @return {Object} - a filled-in shallow clone of fullPayload including
 *     activeContextName, activeConfiguration
 */
gpii.contextManager.evaluateMatch = function (that, fullPayload) {
    var contextPayload = fluid.extend({}, fullPayload);
    var matchMakerOutput = fullPayload.matchMakerOutput;

    var activeContexts = gpii.contextManager.utils.findActiveContexts(fluid.get(that.model, "currentContext"), matchMakerOutput);

    // save highest priority context as the applied one
    contextPayload.activeContextName = activeContexts[0];
    contextPayload.activeConfiguration = fluid.extend(true, {}, fullPayload.matchMakerOutput.inferredConfiguration[contextPayload.activeContextName]);
    return contextPayload;
};
