/*
* Context Manager
*
* Copyright 2014 Raising the Floor - International
*
* Licensed under the New BSD license. You may not use this file except in
* compliance with this License.
*
* The research leading to these results has received funding from the European Union's
* Seventh Framework Programme (FP7/2007-2013)
* under grant agreement no. 289016.
*
* You may obtain a copy of the License at
* https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

"use strict";

var fluid = require("infusion"),
    gpii = fluid.registerNamespace("gpii");


fluid.defaults("gpii.contextManager.app", {
    gradeNames: "kettle.app",
    components: {
        contextManager: {
            type: "gpii.contextManager"
        }
    },
    requestHandlers: {
        environmentChanged: {
            route: "/environmentChanged",
            method: "put",
            type: "gpii.contextManager.environmentChanged.handler"
        }
    }
});

fluid.defaults("gpii.contextManager.environmentChanged.handler", {
    gradeNames: ["kettle.request.http"],
    invokers: {
        handleRequest: {
            funcName: "gpii.contextManager.environmentChanged.handleRequest",
            args: ["{flowManager}.contextManager", "{request}.req.body", "{request}.events.onSuccess"]
        }

    }
});

/**
 * Request handler for URL /environmentChanged. Forwards the content to environmentChanged
 * function and fires the onSuccess event.
 *
 * @that {Object} The context manager component
 * @body {Object} the body of the request. It is expected to contain only key-value pairs
 *      of context variables, and optionally a 'timestamp' key (and associated value) which
 *      will not be considered part of the current context
 * @onSuccess {Object} onSuccess event - will be fired with empty content
 **/
gpii.contextManager.environmentChanged.handleRequest = function (that, body, onSuccess) {
    gpii.contextManager.onEnvironmentChanged(that, body);
    onSuccess.fire();
};

fluid.defaults("gpii.contextManager", {
    gradeNames: "fluid.modelComponent",
    members: {
        temporalIntervalID: null
    },
    components: {
        transformer: {
            type: "gpii.transformer"
        }
    },
    invokers: {
        evaluateMatch: {
            funcName: "gpii.contextManager.evaluateMatch",
            args: [ "{that}", "{arguments}.0"]
        },
        environmentChanged: "gpii.contextManager.onEnvironmentChanged({that}, {arguments}.0)" // body
    },
    modelListeners: {
        currentContext: {
            funcName: "gpii.contextManager.evaluateConditions",
            args: [ "{that}", "{lifecycleManager}", "{change}.value" ]
        }
    },
    listeners: {
        onCreate: "gpii.contextManager.startTemporalEnvironmentReporter",
        onDestroy: "gpii.contextManager.stopTemporalEnvironmentReporter"
    }
});


/**
 * Responsible for weeding out any information from the request body that is not strictly
 * context variables and then notifying the applier.
 *
 * @that {Object} The context manager component
 * @body {Object} the body of the request. It is expected to contain only key-value pairs
 *      of context variables, and optionally a 'timestamp' key (and associated value) which
 *      will not be considered part of the current context
 **/
gpii.contextManager.onEnvironmentChanged = function (that, body) {
    var newContext = fluid.copy(body);
    delete newContext.timestamp;
    fluid.log("contextManager: Updating context with: " + JSON.stringify(newContext, null, 4));
    that.applier.change("currentContext", newContext);
};



/**
 * Function to start the "Temporal reporter". Will report timerelated contexts every 20 seconds.
 * It reports both the timestamp and timeOfDay context variables via manual calls to the
 * gpii.contextManager.environmentChanged function
 *
 * TODO: The timezone here is retrieved based on the system time - the geographical location
 * of the user is not taken into account (unless the OS does so by default) - see GPII-1105
 *
 * @that {Object} The context manager object
 **/
gpii.contextManager.startTemporalEnvironmentReporter = function (that) {
    that.intervalID = setInterval(function () {
        var date = new Date();
        gpii.contextManager.onEnvironmentChanged(that, {
            // ms since UTC epoch, eg: 1421066816897
            "http://registry.gpii.net/common/environment/timestamp": date.getTime(),
            // time of day, eg: "18:30"
            "http://registry.gpii.net/common/environment/timeOfDay": date.getHours() + ":" + date.getMinutes()
        });
    }, 20000); //report time every 20 seconds
};

/**
 * Triggered on destruction of the context manager component. Stops the temporal reporters
 * time reports
 *
 * @that {Object} The context manager object
 **/
gpii.contextManager.stopTemporalEnvironmentReporter = function (that) {
    clearInterval(that.intervalID);
};

/**
 * This function is listening to the changeApplier of the contextManager ("currentContext" path)
 *
 * On changes to the currentContext part of the model it will:
 * 1) parse the context against the currently logged in users' conditions
 * 2) if the new calculated active context is different from the currently applied context,
 *    the lifecycle managers update functionality will be called and the applied context and
 *    configuration will be stored in the active session of the lifecycle manager.
 *
 * @that {Object} The context manager object
 * @lifecycleManager {Object} the lifecycleManager component from which the current
 *    session will be retrieved
 * @context {Object} The model as reporterd by the changeApplier (ie. the content of
 *    that.model.currentContext)
 **/
gpii.contextManager.evaluateConditions = function (that, lifecycleManager, context) {
    // find logged in users
    var activeSessions = lifecycleManager.getActiveSessionTokens();
    // if none is logged in, do nothing
    if (activeSessions.length === 0) {
        return;
    }
    var activeSession = lifecycleManager.getSession(activeSessions);
    var newActiveContexts = gpii.contextManager.utils.findActiveContexts(context, activeSession.matchMakerOutput);
    fluid.log("contextManager: New active contexts: " + newActiveContexts);
    if (newActiveContexts[0] === activeSession.activeContextName) {
        fluid.log("contextManager: Same context as before (" + activeSession.appliedContext + ") so doing nothing");
        return;
    }
    var activeConfiguration = activeSession.matchMakerOutput.inferredConfiguration[newActiveContexts[0]];
    var lifecycleInstructions = that.transformer.configurationToSettings(activeConfiguration, activeSession.solutionsRegistryEntries);
    var finalPayload = {
        userToken: activeSession.userToken,
        lifecycleInstructions: lifecycleInstructions,
        activeContextName: newActiveContexts[0],
        activeConfiguration: activeConfiguration
    };

    lifecycleManager.update(finalPayload, function (response) {
        if (response.success) {
            // Delete these this to avoid the 'lifecycleInstructions' block being attached
            // to the sessionState in the next line. LifecycleInstructions is only used in the
            // "finalPayload" as instructions on how to configure the system.. once configured,
            // the applied settings are stored in 'activeConfiguration'
            delete finalPayload.lifecycleInstructions;
            fluid.extend(true, activeSession, finalPayload);
        }
        fluid.log("contextManager: Successfully updated configuration triggered by context changes");
    });
};

/*
 * Function to take the full output of a matchmaking process, evaluate the current context,
 * and decide which context should currently be used. The application block for this context
 * is passed on in the event passed as parameter.
 *
 * @param that {Object} - gpii.contextManager object
 * @param matchMakerResponse {Object} - the full structure fired from gpii.matchMakerFramework.matchMakerDispatcher - a structure containing, in addition to
 * all fields from matchMakerInput payload (userToken, preferences, solutionsRegistryEntries, deviceContext):
 *     matchMakerOutput {Object} - the output of a matchmaking process
 * @return {Object} - a filled-in shallow clone of matchMakerResponse including
 *     activeContextName, activeConfiguration
 */
gpii.contextManager.evaluateMatch = function (that, matchMakerResponse) {
    var contextPayload = fluid.extend({}, matchMakerResponse);
    var matchMakerOutput = matchMakerResponse.matchMakerOutput;

    var activeContexts = gpii.contextManager.utils.findActiveContexts(fluid.get(that.model, "currentContext"), matchMakerOutput);

    // save highest priority context as the applied one
    contextPayload.activeContextName = activeContexts[0];
    contextPayload.activeConfiguration = fluid.extend(true, {}, matchMakerOutput.inferredConfiguration[contextPayload.activeContextName]);
    return contextPayload;
};
