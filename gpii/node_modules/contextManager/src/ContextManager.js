/*
* Context Manager
*
* Copyright 2014-2017 Raising the Floor - International
*
* Licensed under the New BSD license. You may not use this file except in
* compliance with this License.
*
* The research leading to these results has received funding from the European Union's
* Seventh Framework Programme (FP7/2007-2013)
* under grant agreement no. 289016.
*
* You may obtain a copy of the License at
* https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

"use strict";

var fluid = require("infusion"),
    gpii = fluid.registerNamespace("gpii");


fluid.defaults("gpii.contextManager.app", {
    gradeNames: "kettle.app",
    components: {
        contextManager: {
            type: "gpii.contextManager"
        }
    },
    requestHandlers: {
        environmentChanged: {
            route: "/environmentChanged",
            method: "put",
            type: "gpii.contextManager.environmentChanged.handler"
        }
    }
});

fluid.defaults("gpii.contextManager.environmentChanged.handler", {
    gradeNames: ["kettle.request.http"],
    invokers: {
        handleRequest: {
            funcName: "gpii.contextManager.environmentChanged.handleRequest",
            args: ["{flowManager}.contextManager", "{that}.req.body", "{that}.events.onSuccess"]
        }

    }
});

/**
 * Request handler for URL /environmentChanged. Forwards the content to environmentChanged
 * function and fires the onSuccess event.
 *
 * @param {Component} that - The context manager component
 * @param {Object} body - The body of the request. It is expected to contain only key-value pairs
 *      of context variables, and optionally a 'timestamp' key (and associated value) which
 *      will not be considered part of the current context
 * @param {Event} onSuccess - onSuccess event - will be fired with empty content
 **/
gpii.contextManager.environmentChanged.handleRequest = function (that, body, onSuccess) {
    gpii.contextManager.updateCurrentEnvironment(that, body);
    onSuccess.fire();
};

fluid.defaults("gpii.contextManager", {
    gradeNames: "fluid.modelComponent",
    members: {
        temporalIntervalID: null
    },
    invokers: {
        updateActiveContextName: {
            funcName: "gpii.contextManager.updateActiveContextName",
            args: ["{that}", "{arguments}.0", "{arguments}.1"]
                             // fullPayload, forceContextName
        },
        contextChanged: {
            funcName: "gpii.contextManager.contextChanged",
            args: ["{that}", "{lifecycleManager}", "{arguments}.0"]
                                                   // forceContextName
        },
        environmentChanged: "gpii.contextManager.updateCurrentEnvironment({that}, {arguments}.0)" // body
    },
    modelListeners: {
        currentEnvironment: {
            func: "{that}.contextChanged",
            args: []
        }
    },
    listeners: {
        onCreate: "gpii.contextManager.startTemporalEnvironmentReporter",
        onDestroy: "gpii.contextManager.stopTemporalEnvironmentReporter"
    }
});


/**
 * Responsible for weeding out any information from the request body that is not strictly
 * environmental variables and then notifying the applier.
 *
 * @param {Component} that - The context manager component
 * @param {Object} body - The body of the request. It is expected to contain only key-value pairs
 *      of environmental variables, and optionally a 'timestamp' key (and associated value) which
 *      will not be considered part of the current context
 **/
gpii.contextManager.updateCurrentEnvironment = function (that, body) {
    var newEnvironment = fluid.censorKeys(body, ["timestamp"]);
    fluid.log("contextManager: Updating environment with: " + JSON.stringify(newEnvironment, null, 4));
    that.applier.change("currentEnvironment", newEnvironment);
};


/**
 * Function to start the "Temporal reporter". Will report timerelated contexts every 20 seconds.
 * It reports both the timestamp and timeOfDay context variables via manual calls to the
 * gpii.contextManager.environmentChanged function
 *
 * TODO: The timezone here is retrieved based on the system time - the geographical location
 * of the user is not taken into account (unless the OS does so by default) - see GPII-1105
 *
 * @param {Component} that - The context manager object
 **/
gpii.contextManager.startTemporalEnvironmentReporter = function (that) {
    that.temporalIntervalID = setInterval(function () {
        var date = new Date();
        gpii.contextManager.updateCurrentEnvironment(that, {
            // ms since UTC epoch, eg: 1421066816897
            "http://registry.gpii.net/common/environment/timestamp": date.getTime(),
            // time of day, eg: "18:30"
            "http://registry.gpii.net/common/environment/timeOfDay": date.getHours() + ":" + date.getMinutes()
        });
    }, 20000); // report time every 20 seconds
};

/**
 * Triggered on destruction of the context manager component. Stops the temporal reporters
 * time reports
 *
 * @param {Component} that - The context manager object
 **/
gpii.contextManager.stopTemporalEnvironmentReporter = function (that) {
    clearInterval(that.temporalIntervalID);
};

/**
 * This function is listening to the changeApplier of the contextManager ("currentEnvironment" path)
 *
 * On changes to the currentEnvironment part of the model it will:
 * 1) parse the context against the currently logged in user's conditions
 * 2) if the new calculated active context is different from the currently applied context,
 *    the LifecycleManager's update functionality will be called and the applied context and
 *    configuration will be stored in the active session of the lifecycle manager.
 *
 * @param {Object} that - The context manager object
 * @param {Component} lifecycleManager - The lifecycleManager component from which the current
 *    session will be retrieved
 * @param {String} [forceContextName] - [optional] A context name to be unconditionally selected
 * @return {Promise} If the context change causes an actual change in the system (i.e. change of
 *    active context and changes to the applied configuration) a promise of an update to the system
 *    configuration is returned. If the call to contextChanged does not result in a different
 *    active context or no user is logged in, undefined will be returned.
 **/
gpii.contextManager.contextChanged = function (that, lifecycleManager, forceContextName) {
    // find logged in users
    var activeSession = lifecycleManager.getSession();
    var activeGpiiKey = activeSession.model.gpiiKey;

    // if no one is logged in, or, a system reserved key is logged in, do nothing
    if (!activeGpiiKey || gpii.isReservedGpiiKey(activeGpiiKey)) {
        return;
    }
    var fullPayload = fluid.extend(true, {}, activeSession.model);
    var oldActiveContext = fullPayload.activeContextName;

    // find and update context:
    that.updateActiveContextName(fullPayload, forceContextName);

    if (oldActiveContext === fullPayload.activeContextName) {
        fluid.log(fluid.logLevel.TRACE, "contextManager: Same context as before (" + oldActiveContext + ") so doing nothing");
        return;
    }
    fluid.log("contextManager: Context changed from old context \"", oldActiveContext, "\" to new active context \"" + fullPayload.activeContextName, "\" for the GPII key: ", activeGpiiKey);
    // Update the context name immediately so we don't produce a model update from the lifecycleManager with a
    // partially applied set of solutions from the new context, confusing, e.g., the PSPChannel
    // This is required because of https://issues.fluidproject.org/browse/FLUID-6208
    activeSession.applier.change("activeContextName", fullPayload.activeContextName);

    // Delete the old appliedSolutions as the new structure will be updated directly onto activeSession.model
    // by lifecycleManager.update() called 2 lines later
    delete fullPayload.appliedSolutions;

    lifecycleManager.addLifecycleInstructionsToPayload(fullPayload);
    var response = lifecycleManager.update(fullPayload);

    response.then(function () {
        // Delete these this to avoid the 'lifecycleInstructions' block being attached
        // to the sessionState in the next line. LifecycleInstructions is only used in the
        // "finalPayload" as instructions on how to configure the system. once configured,
        // the applied settings are stored in 'activeConfiguration'
        delete fullPayload.lifecycleInstructions;
        // TODO: This is pretty rubbish, why isn't the natural action of lifecycleManager.update good enough here?
        activeSession.applier.change("", fullPayload); // TODO: this will need to be a "MERGE" in time
        fluid.log("contextManager: Successfully updated configuration triggered by context changes");
    }, function () {
        fluid.log(fluid.logLevel.FAIL, "contextManager: Failed to apply newly evaluated conditions");
    });
    return response;
};

/**
 * Function to add the current context to the full payload which is output from the matchmaking process.
 *
 * @param {Component} that - An instance of gpii.contextManager component
 * @param {Object} fullPayload - The full structure output from the matchmaking process. NOTE: This object will be modified
 * @param {String} [forceContextName] - [optional] A context name to be selected, overriding environment conditions
 * @return {Object} The modified fullPayload, now including activeContextName, activeConfiguration
 */
gpii.contextManager.updateActiveContextName = function (that, fullPayload, forceContextName) {
    var matchMakerOutput = fullPayload.matchMakerOutput;
    var newActiveContextName;
    if (forceContextName === undefined) {
        if (fullPayload.forcedContext) { // Don't compute conditions if context has been forced
            newActiveContextName = fullPayload.activeContextName;
        } else {
            var activeContexts = gpii.contextManager.utils.findActiveContexts(fluid.get(that.model, "currentEnvironment"), matchMakerOutput);
            // save highest priority context as the applied one
            newActiveContextName = activeContexts[0];
        }
    } else {
        newActiveContextName = forceContextName;
        fullPayload.forcedContext = true;
    }
    fullPayload.activeContextName = newActiveContextName;
    return fullPayload;
};
