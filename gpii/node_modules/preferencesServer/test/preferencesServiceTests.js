/*
    Copyright 2017-2018 OCAD University
    Copyright 2019 Raising the Floor International

    Licensed under the New BSD license. You may not use this file except in
    compliance with this License.

    You may obtain a copy of the License at
    https://github.com/GPII/universal/blob/master/LICENSE.txt
*/
"use strict";
var fluid = require("infusion");
var gpii = fluid.registerNamespace("gpii");

var jqUnit = require("node-jqunit");

fluid.require("%gpii-universal");
gpii.loadTestingSupport();

fluid.registerNamespace("gpii.tests.preferencesServer.preferencesService");

/**
 *
 * Convert a function and the follow up retrieval of the prefs safe to a single promise that can be used with the Fluid
 * IoC `task` and `resolve` syntax.
 *
 * @param {Object} preferencesService - The preferences service component.
 * @param {String} fnNameToExec - The name of the function to execute.
 * @param {Array} fnArgs - The arguments to pass when executing the function.
 * @return {Promise} - A `fluid.promise` that will resolve with the updated prefs safe or reject on error.
 *
 */
gpii.tests.preferencesServer.preferencesService.executeAndRetrievePrefs = function (preferencesService, fnNameToExec, fnArgs) {
    var outerPromise = fluid.promise();

    var execPromise = preferencesService[fnNameToExec].apply(null, fnArgs);
    execPromise.then(
        function (results) {
            // retrieve the updated prefs safe
            preferencesService.getPrefsSafeByGpiiKey(results.gpiiKey).then(
                outerPromise.resolve,
                outerPromise.reject
            );
        },
        outerPromise.reject
    );

    return outerPromise;
};

fluid.defaults("gpii.tests.preferencesServer.preferencesService.caseHolder", {
    gradeNames: ["fluid.test.testCaseHolder"],
    events: {
        createPreferencesService: null
    },
    components: {
        preferencesService: {
            type: "gpii.preferencesServer.preferencesService",
            createOnEvent: "createPreferencesService",
            options: {
                gradeNames: ["gpii.tests.dbOperation.dbDataStore.base"],
                components: {
                    dataStore: {
                        type: "gpii.dbOperation.dbDataStore",
                        options: {
                            dataSourceConfig: {
                                baseUrl: "http://localhost",
                                port: 25984,
                                dbName: "gpii"
                            }
                        }
                    }
                }
            }
        }
    }
});

fluid.defaults("gpii.tests.preferencesServer.preferencesService.createPreferencesService", {
    gradeNames: ["fluid.test.sequenceElement"],
    sequence: [{
        func: "{caseHolder}.events.createPreferencesService.fire"
    }]
});

fluid.defaults("gpii.tests.preferencesServer.preferencesService.sequenceGrade", {
    gradeNames: ["fluid.test.sequence"],
    sequenceElements: {
        startCouch: {
            gradeNames: "gpii.test.startCouchSequence",
            priority: "before:sequence"
        },
        createPreferencesService: {
            gradeNames: "gpii.tests.preferencesServer.preferencesService.createPreferencesService",
            priority: "after:startCouch"
        },
        stopCouch: {
            gradeNames: "gpii.test.stopCouchSequence",
            priority: "after:sequence"
        }
    }
});


// We use the same base grade as the main harness, but avoid merging with that to avoid picking up the wrong test data.
fluid.defaults("gpii.tests.preferencesServer.preferencesService.baseEnvironment", {
    gradeNames: ["gpii.test.couchdb.environment.base"],
    databases: {
        gpii: {
            data: [
                "%gpii-universal/gpii/node_modules/preferencesServer/test/data/gpiiKeys-preferenceServiceTests.json",
                "%gpii-universal/gpii/node_modules/preferencesServer/test/data/prefsSafes-preferencesServiceTests.json",
                "%gpii-universal/testData/dbData/views.json"
            ]
        }
    },
    components: {
        caseHolder: {
            type: "gpii.tests.preferencesServer.preferencesService.caseHolder"
        }
    }
});

// All input test data
gpii.tests.preferencesServer.preferencesService.testData = {
    preferencesToCreate: {
        "http://registry.gpii.net/common/matchMakerType": "ruleBased",
        "http://registry.gpii.net/common/fontSize": 24
    },
    preferencesToUpdate: {
        "flat": {
            "contexts": {
                "gpii-default": {
                    "name": "an updated name",
                    "preferences": {
                        "http://registry.gpii.net/common/fontSize": 20
                    }
                }
            }
        },
        "newKey": {
            "nested": "nested-value"
        }
    }
};

// All expected results
gpii.tests.preferencesServer.preferencesService.expected = {
    // for testing getPreferencesByGpiiKey()
    receivedPrefs: {
        "flat": {
            "name": "Default context",
            "contexts": {
                "gpii-default": {
                    "name": "Default preferences",
                    "preferences": {
                        "http://registry.gpii.net/common/matchMakerType": "ruleBased",
                        "http://registry.gpii.net/common/fontSize": 24,
                        "http://registry.gpii.net/common/foregroundColor": "white"
                    }
                }
            }
        }
    },
    updatedPrefs: {
        "flat": {
            "name": "Default context",
            "contexts": {
                "gpii-default": {
                    "name": "an updated name",
                    "preferences": {
                        "http://registry.gpii.net/common/fontSize": 20,
                        "http://registry.gpii.net/common/foregroundColor": "white",
                        "http://registry.gpii.net/common/matchMakerType": "ruleBased"
                    }
                }
            }
        },
        "newKey": {
            "nested": "nested-value"
        }
    },
    unauthorized: {
        message: "Unauthorized",
        statusCode: 401,
        isError: true
    },
    missingGpiiKey: {
        message: "GPII key \"non-existent-gpii-key\" does not exist"
    },
    noUpdateOnSnapset: {
        message: "Cannot update:  GPII key \"snapset1\" is a snapset"
    },
    // for testing createPreferences()
    preferencesToCreate_prefsOnly: {
        prefsSafeType: "user",
        name: null,
        password: null,
        email: null,
        preferences: {
            "http://registry.gpii.net/common/cursorSize": 24
        }
    },
    gpiiKeyExisted: "GPII key \"alice_gpii_key\" already exists"
};

fluid.defaults("gpii.tests.preferencesServer.preferencesService.getPreferencesByGpiiKey", {
    gradeNames: ["gpii.tests.preferencesServer.preferencesService.baseEnvironment"],
    components: {
        caseHolder: {
            options: {
                modules: [{
                    name: "Test getPreferencesByGpiiKey()",
                    tests: [
                        {
                            name: "getPreferencesByGpiiKey() returns preferences - a successful workflow",
                            sequenceGrade: "gpii.tests.preferencesServer.preferencesService.sequenceGrade",
                            sequence: [{
                                task: "{preferencesService}.getPreferencesByGpiiKey",
                                args: ["alice_gpii_key"],
                                resolve: "jqUnit.assertDeepEq",
                                resolveArgs: ["The access token should be received in an expected format", gpii.tests.preferencesServer.preferencesService.expected.receivedPrefs, "{arguments}.0"]
                            }]
                        },
                        {
                            name: "getPreferencesByGpiiKey() returns undefined when the GPII key has no preferences defined",
                            sequenceGrade: "gpii.tests.preferencesServer.preferencesService.sequenceGrade",
                            sequence: [{
                                task: "{preferencesService}.getPreferencesByGpiiKey",
                                args: ["bob_gpii_key"],
                                resolve: "jqUnit.assertUndefined",
                                resolvArgs: ["undefined is returned when the gpii key has no preferences defined", "{arguments}.0"]
                            }]
                        },
                        {
                            name: "getPreferencesByGpiiKey() returns error when a gpii key is not provided in the argument list",
                            sequenceGrade: "gpii.tests.preferencesServer.preferencesService.sequenceGrade",
                            sequence: [{
                                task: "{preferencesService}.getPreferencesByGpiiKey",
                                args: ["non-existent-gpii-key"],
                                reject: "jqUnit.assertDeepEq",
                                rejectArgs: ["The error is returned when a gpii key is not found", gpii.tests.preferencesServer.preferencesService.expected.missingGpiiKey, "{arguments}.0"]
                            }]
                        }
                    ]
                }]
            }
        }
    }
});

fluid.defaults("gpii.tests.preferencesServer.preferencesService.createPreferences", {
    gradeNames: ["gpii.tests.preferencesServer.preferencesService.baseEnvironment"],
    components: {
        caseHolder: {
            options: {
                modules: [{
                    name: "Test createPreferences()",
                    tests: [
                        {
                            name: "createPreferences() creates a prefs safe and an auto generated GPII key - a successful workflow",
                            sequenceGrade: "gpii.tests.preferencesServer.preferencesService.sequenceGrade",
                            sequence: [{
                                task: "gpii.tests.preferencesServer.preferencesService.executeAndRetrievePrefs",
                                args: ["{preferencesService}", "createPreferences", [gpii.tests.preferencesServer.preferencesService.testData.preferencesToCreate]], // preferencesServer, fnNameToExec, fnArgs
                                resolve: "gpii.tests.preferencesServer.preferencesService.verifyFetchedPrefsSafe",
                                resolveArgs: [gpii.tests.preferencesServer.preferencesService.testData.preferencesToCreate, "{arguments}.0"]
                            }]
                        },
                        {
                            name: "createPreferences() creates a prefs safe and an GPII key with the provided key value - a successful workflow",
                            sequenceGrade: "gpii.tests.preferencesServer.preferencesService.sequenceGrade",
                            sequence: [{
                                task: "gpii.tests.preferencesServer.preferencesService.executeAndRetrievePrefs",
                                args: ["{preferencesService}", "createPreferences", [gpii.tests.preferencesServer.preferencesService.testData.preferencesToCreate, "a-new-gpii-key-by-preferences-service"]], // preferencesServer, fnNameToExec, fnArgs
                                resolve: "gpii.tests.preferencesServer.preferencesService.verifyFetchedPrefsSafe",
                                resolveArgs: [gpii.tests.preferencesServer.preferencesService.testData.preferencesToCreate, "{arguments}.0", "a-new-gpii-key-by-preferences-service"]
                            }]
                        },
                        {
                            name: "createPreferences() returns error when the provided GPII key already exists",
                            sequenceGrade: "gpii.tests.preferencesServer.preferencesService.sequenceGrade",
                            sequence: [{
                                task: "{preferencesService}.createPreferences",
                                args: [gpii.tests.preferencesServer.preferencesService.testData.preferencesToCreate, "alice_gpii_key"],
                                reject: "jqUnit.assertDeepEq",
                                rejectArgs: ["The error is returned when the provided GPII key already exists", gpii.tests.preferencesServer.preferencesService.expected.gpiiKeyExisted, "{arguments}.0"]
                            }]
                        }
                    ]
                }]
            }
        }
    }
});

gpii.tests.preferencesServer.preferencesService.verifyFetchedPrefsSafe = function (preferencesToCreate, response, expectedGpiiKey) {
    if (expectedGpiiKey) {
        jqUnit.assertEquals("The created GPII key matches the input GPII key", expectedGpiiKey, response.gpiiKey);
        jqUnit.assertEquals("The GPII key in the key record matches the input GPII key", expectedGpiiKey, response.gpiiKeyDetails.id);
    } else {
        jqUnit.assertNotUndefined("The GPII key is auto generated", response.gpiiKey);
    }

    var gpiiKeyDetails = response.gpiiKeyDetails;
    jqUnit.assertEquals("The value of \"schemaVersion\" has been set correctly", gpii.dbOperation.schemaVersion, gpiiKeyDetails.schemaVersion);
    jqUnit.assertNotUndefined("The value of \"prefsSafeId\" has been set to default", gpiiKeyDetails.prefsSafeId);
    jqUnit.assertEquals("The value of \"prefsSetId\" has been set to default", gpii.preferencesServer.defaultPrefsSetId, gpiiKeyDetails.prefsSetId);
    jqUnit.assertFalse("The value of \"revoked\" has been set to false", gpiiKeyDetails.revoked);
    jqUnit.assertNull("The value of \"revokedReason\" has been set to null", gpiiKeyDetails.revokedReason);
    jqUnit.assertNotUndefined("The value of \"timestampCreated\" has been set", gpiiKeyDetails.timestampCreated);
    jqUnit.assertNull("The value of \"timestampUpdated\" has been set", gpiiKeyDetails.timestampUpdated);

    var prefsSafe = response.prefsSafe;
    jqUnit.assertLeftHand("The data is saved successfully", preferencesToCreate, prefsSafe.preferences);
};

fluid.defaults("gpii.tests.preferencesServer.preferencesService.updatePreferences", {
    gradeNames: ["gpii.tests.preferencesServer.preferencesService.baseEnvironment"],
    components: {
        caseHolder: {
            options: {
                modules: [{
                    name: "Test updatePreferences()",
                    tests: [
                        {
                            name: "updatePreferences() updates the associated prefs safe with merged preferences - a successful workflow",
                            sequenceGrade: "gpii.tests.preferencesServer.preferencesService.sequenceGrade",
                            sequence: [
                                {
                                    task: "{preferencesService}.getPrefsSafeByGpiiKey",
                                    args: ["alice_gpii_key"],
                                    // save the original GPII key and prefs safe records to compare after the update
                                    resolve: "fluid.set",
                                    resolveArgs: ["{that}", ["originalData"], "{arguments}.0"]
                                },
                                {
                                    task: "gpii.tests.preferencesServer.preferencesService.executeAndRetrievePrefs",
                                    args: ["{preferencesService}", "updatePreferences", [gpii.tests.preferencesServer.preferencesService.testData.preferencesToUpdate, "alice_gpii_key", true]], // preferencesServer, fnNameToExec, fnArgs
                                    resolve: "gpii.tests.preferencesServer.preferencesService.verifyUpdatedPrefsSafe",
                                    resolveArgs: ["{that}", gpii.tests.preferencesServer.preferencesService.expected.updatedPrefs, "alice_gpii_key", "{arguments}.0"]
                                }
                            ]
                        },
                        {
                            name: "updatePreferences() updates the associated prefs safe without merging with existing preferences - a successful workflow",
                            sequenceGrade: "gpii.tests.preferencesServer.preferencesService.sequenceGrade",
                            sequence: [
                                {
                                    task: "{preferencesService}.getPrefsSafeByGpiiKey",
                                    args: ["alice_gpii_key"],
                                    // save the original GPII key and prefs safe records to compare after the update
                                    resolve: "fluid.set",
                                    resolveArgs: ["{that}", ["originalData"], "{arguments}.0"]
                                },
                                {
                                    task: "gpii.tests.preferencesServer.preferencesService.executeAndRetrievePrefs",
                                    args: ["{preferencesService}", "updatePreferences", [gpii.tests.preferencesServer.preferencesService.testData.preferencesToUpdate, "alice_gpii_key"]], // preferencesServer, fnNameToExec, fnArgs
                                    resolve: "gpii.tests.preferencesServer.preferencesService.verifyUpdatedPrefsSafe",
                                    resolveArgs: ["{that}", gpii.tests.preferencesServer.preferencesService.testData.preferencesToUpdate, "alice_gpii_key", "{arguments}.0"]
                                }
                            ]
                        },
                        {
                            name: "updatePreferences() creates a new prefs safe when the GPII key is not associates with a prefs safe - a successful workflow",
                            sequenceGrade: "gpii.tests.preferencesServer.preferencesService.sequenceGrade",
                            sequence: [
                                {
                                    task: "{preferencesService}.getPrefsSafeByGpiiKey",
                                    args: ["bob_gpii_key"],
                                    // save the original GPII key and prefs safe records to compare after the update
                                    resolve: "fluid.set",
                                    resolveArgs: ["{that}", ["originalData"], "{arguments}.0"]
                                },
                                {
                                    task: "gpii.tests.preferencesServer.preferencesService.executeAndRetrievePrefs",
                                    args: ["{preferencesService}", "updatePreferences", [gpii.tests.preferencesServer.preferencesService.testData.preferencesToUpdate, "bob_gpii_key"]], // preferencesServer, fnNameToExec, fnArgs
                                    resolve: "gpii.tests.preferencesServer.preferencesService.verifyNewPrefsSafeForUpdate",
                                    resolveArgs: ["{that}", gpii.tests.preferencesServer.preferencesService.testData.preferencesToUpdate, "bob_gpii_key", "{arguments}.0"]
                                }
                            ]
                        },
                        {
                            name: "updatePreferences() returns error when updating a snapset",
                            sequenceGrade: "gpii.tests.preferencesServer.preferencesService.sequenceGrade",
                            sequence: [{
                                task: "{preferencesService}.updatePreferences",
                                args: [gpii.tests.preferencesServer.preferencesService.testData.preferencesToUpdate, "snapset1"],
                                reject: "jqUnit.assertDeepEq",
                                rejectArgs: ["The error is returned when updating a snapset", gpii.tests.preferencesServer.preferencesService.expected.noUpdateOnSnapset, "{arguments}.0"]
                            }]
                        }
                    ]
                }]
            }
        }
    }
});

gpii.tests.preferencesServer.preferencesService.verifyUpdatedPrefsSafe = function (that, updatedPreferences, gpiiKey, response) {
    jqUnit.assertDeepEq("The GPII key in the response is expected", gpiiKey, response.gpiiKey);
    jqUnit.assertDeepEq("The GPII key record is unchanged", that.originalData.gpiiKeyDetails, response.gpiiKeyDetails);
    jqUnit.assertDeepEq("The preferences has been updated", updatedPreferences, response.prefsSafe.preferences);
    jqUnit.assertNotEquals("The prefs safe timestampUpdated has been updated", that.originalData.prefsSafe.timestampUpdated, response.prefsSafe.timestampUpdated);

    var unchangedOrigPrefsSafeFields = fluid.censorKeys(that.originalData.prefsSafe, ["preferences", "timestampUpdated"]);
    var unchangedPrefsSafeFields = fluid.censorKeys(response.prefsSafe, ["preferences", "timestampUpdated"]);
    jqUnit.assertDeepEq("Other prefs safe values are unchanged", unchangedOrigPrefsSafeFields, unchangedPrefsSafeFields);
};

gpii.tests.preferencesServer.preferencesService.verifyNewPrefsSafeForUpdate = function (that, updatedPreferences, gpiiKey, response) {
    // verify before update status
    jqUnit.assertNull("The GPII key originally has no prefs safe associated", that.originalData.gpiiKeyDetails.prefsSafeId);

    // verify after update status
    jqUnit.assertDeepEq("The GPII key in the response is expected", gpiiKey, response.gpiiKey);
    jqUnit.assertNotUndefined("A prefs safe has been created", response.prefsSafe);
    jqUnit.assertNull("The timestampUpdated of the prefs safe is null", response.prefsSafe.timestampUpdated);
    jqUnit.assertDeepEq("The preferences in the prefs safe is expected", updatedPreferences, response.prefsSafe.preferences);
    jqUnit.assertEquals("The prefs safe has been associated with the GPII key", response.gpiiKeyDetails.prefsSafeId, response.prefsSafe.id);

    var unchangedOrigGpiiKeyFields = fluid.censorKeys(that.originalData.gpiiKeyDetails, ["prefsSafeId", "prefsSetId", "timestampUpdated"]);
    var unchangedGpiiKeyFields = fluid.censorKeys(response.gpiiKeyDetails, ["prefsSafeId", "prefsSetId", "timestampUpdated"]);
    jqUnit.assertDeepEq("Other GPII key values are unchanged", unchangedOrigGpiiKeyFields, unchangedGpiiKeyFields);
};

fluid.test.runTests([
    "gpii.tests.preferencesServer.preferencesService.getPreferencesByGpiiKey",
    "gpii.tests.preferencesServer.preferencesService.createPreferences",
    "gpii.tests.preferencesServer.preferencesService.updatePreferences"
]);
