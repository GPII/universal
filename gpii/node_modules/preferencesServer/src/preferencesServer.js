/*!
GPII Preferences Server

Copyright 2012-2016 OCAD University
Copyright 2014-2015 Raising The Floor - International

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

The research leading to these results has received funding from the European Union's
Seventh Framework Programme (FP7/2007-2013) under grant agreement no. 289016.

You may obtain a copy of the License at
https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

"use strict";

var fluid = require("infusion"),
    gpii = fluid.registerNamespace("gpii");

require("ontologyHandler");
require("gpii-oauth2");

fluid.defaults("gpii.preferencesServer", {
    gradeNames: ["kettle.app"],
    requestHandlers: {
        preferencesGet: {
            route: "/preferences/:userToken",
            method: "get",
            type: "gpii.preferencesServer.get.handler"
        },
        preferencesPost: {
            route: "/preferences",
            method: "post",
            type: "gpii.preferencesServer.post.handler"
        },
        preferencesPut: {
            route: "/preferences/:userToken",
            method: "put",
            type: "gpii.preferencesServer.put.handler"
        },
        addPreferencesPost: {
            route: "/add-preferences",
            method: "post",
            type: "gpii.preferencesServer.add.post.handler"
        }
    },
    invokers: {
        getRawPreferences: {
            funcName: "gpii.preferencesServer.getRawPreferences",
            args: ["{gpii.preferencesServer}.rawPreferencesDataSource", "{arguments}.0"]
        },
        setRawPreferences: {
            funcName: "gpii.preferencesServer.setRawPreferences",
            // TODO: This should really return a promise - {arguments}.0 is "onSuccess"
            args: ["{gpii.preferencesServer}.rawPreferencesDataSource", "{kettle.request}", "{arguments}.0", "{arguments}.1", "{arguments}.2" ]
        },
        setPrefsRequestHandler: {
            funcName: "gpii.preferencesServer.setPrefsRequestHandler",
            args: ["{preferencesServer}", "{arguments}.0", "{arguments}.1"]
            // request, successEvent
        },
        setPrefsReturnHandler: {
            funcName: "gpii.preferencesServer.setPrefsReturnHandler",
            args: ["{arguments}.0", "{arguments}.1"]
            // reply, request
        }
    },
    components: {
        rawPreferencesDataSource: {
            type: "kettle.dataSource.URL",
            options: {
                // url: "{gpii.preferencesServer}.options.urls.rawPreferences",
                termMap: {
                    userToken: "%userToken"
                },
                writable: true
            }
        },
        ontologyHandler: {
            type: "gpii.ontologyHandler"
        },
        dataStore: {
            type: "gpii.oauth2.inMemoryDataStore"
        },
        authGrantFinder: {
            type: "gpii.oauth2.authGrantFinder"
        }
    },
    distributeOptions: {
        "record": "{gpii.preferencesServer}.dataStore",
        "target": "{that authorizationService}.options.components.dataStore"
    }
});

gpii.preferencesServer.getRawPreferences = function (rawPreferencesDataSource, userToken) {
    var promiseTogo = fluid.promise();
    if (userToken === undefined) {
        promiseTogo.reject({message: "User token for getting preferences is undefined - aborting"});
    } else {
        var promise = rawPreferencesDataSource.get({userToken: userToken});
        promise.then(function (data) {
            promiseTogo.resolve(data.preferences || data);
        }, function (err) {
            promiseTogo.reject(err);
        });
    }
    return promiseTogo;
};

gpii.preferencesServer.setRawPreferences = function (rawPreferencesDataSource, request, successEvent, body, userToken) {
    // if we were passed a user token, that means we want to do an update, else we're creating a new NP set
    var writeMethod = (userToken) ? "PUT" : "POST";
    var promise = rawPreferencesDataSource.set({userToken: userToken || ""}, body, {writeMethod: writeMethod});
    promise.then(successEvent.fire, request.events.onError.fire);
};

// TODO - should be removed or factored - just copied from gpii.flowmanager.logAndNotify
gpii.preferencesServer.logAndNotify = function (msg, event, callback) {
    return function (data) {
        fluid.log(msg, data);
        event.fire(callback ? callback(data) : data);
    };
};

/*
 * Simple function to get the 'view' parameter from the request object. In case none is given,
 * defaults to the "flat" ontology.
 *
 * @request (Object) a request object
 *
 * @return (String) the value of the 'view' parameter of the request object, or "flat" if
 *     none is given
 */
gpii.preferencesServer.getRequestView = function (request) {
    return (request.req.query && request.req.query.view) ? request.req.query.view : "flat";
};

gpii.preferencesServer.setPrefsRequestHandler = function (preferencesServer, request, successEvent) {
    // key preferences set by ontology
    var toView = gpii.preferencesServer.getRequestView(request);
    var payload = {};
    payload[toView] = request.req.body;
    preferencesServer.setRawPreferences(successEvent, payload, undefined);
};

gpii.preferencesServer.setPrefsReturnHandler = function (reply, request) {
    // despite potentially having modified the entire raw preferences set, we only return the
    // preferences in the view that we originally got them
    var ret = {
        userToken: reply.userToken,
        preferences: reply.preferences[gpii.preferencesServer.getRequestView(request)]
    };
    request.events.onSuccess.fire(ret);
};
