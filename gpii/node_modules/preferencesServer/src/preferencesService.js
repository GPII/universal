/*!
Copyright 2017-2018 OCAD university

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

/* eslint-env browser */
/* eslint strict: ["error", "function"] */

var fluid = fluid || require("infusion");

(function () {
    "use strict";

    var gpii = fluid.registerNamespace("gpii"),
        $ = fluid.registerNamespace("jQuery");
    require("gpii-express-user");

    fluid.defaults("gpii.preferencesServer.preferencesService", {
        gradeNames: ["fluid.component"],
        components: {
            dataStore: {
                type: "gpii.dbOperation.dataStore"
            },
            expressUserUtils: {
                type: "gpii.express.user.utils",
                options: {
                    couch: {
                        userDbUrl: {
                            expander: {
                                funcName: "fluid.stringTemplate",
                                args: ["%baseUrl:%port/%dbName", {
                                    baseUrl: "{dataStore}.options.dataSourceConfig.baseUrl",
                                    port: "{dataStore}.options.dataSourceConfig.port",
                                    dbName: "{dataStore}.options.dataSourceConfig.dbName"
                                }]
                            }
                        }
                    }
                }
            }
        },
        invokers: {
            getPrefsSafe: {
                funcName: "gpii.preferencesServer.preferencesService.getPrefsSafe",
                args: ["{dataStore}", "{arguments}.0"]
            },
            getPrefsSafeList: {
                func: "{dataStore}.findPrefsSafeList",
                args: ["{arguments}.0"]
            },
            getPrefsSafeByGpiiKey: "{dataStore}.findPrefsSafeByGpiiKey",
            getKeysForPrefsSafe: "{dataStore}.findRelatedDocsForPrefsSafe",
            getPreferencesByGpiiKey: {
                funcName: "gpii.preferencesServer.preferencesService.getPreferencesByGpiiKey",
                args: ["{dataStore}.findPrefsSafeByGpiiKey", "{arguments}.0"]
                                                             // gpiiKey
            },
            addPrefsSafe: {
                funcName: "gpii.preferencesServer.preferencesService.addPrefsSafe",
                args: ["{that}", "{dataStore}", "{arguments}.0"]
            },
            updatePrefsSafe: {
                funcName: "gpii.preferencesServer.preferencesService.updatePrefsSafe",
                args: ["{that}", "{dataStore}", "{arguments}.0"]
            },
            createPreferences: {
                funcName: "gpii.preferencesServer.preferencesService.createPreferences",
                args: ["{that}", "{arguments}.0", "{arguments}.1"]
                                 // preferences, gpiiKey
            },
            updatePreferences: {
                funcName: "gpii.preferencesServer.preferencesService.updatePreferences",
                args: ["{that}", "{arguments}.0", "{arguments}.1", "{arguments}.2"]
                                 // preferences, gpiiKey, merge
            },
            // Add a GPII Key to an existing preferences safe
            addGpiiKey: {
                funcName: "gpii.preferencesServer.preferencesService.addGpiiKey",
                args: ["{that}", "{dataStore}", "{arguments}.0"]
            },
            cloudSafeCredCreate: {
                funcName: "gpii.preferencesServer.preferencesService.cloudSafeCredCreate",
                args: ["{that}", "{arguments}.0"]
            },
            cloudSafeUnlock: {
                funcName: "gpii.preferencesServer.preferencesService.cloudSafeUnlock",
                args: ["{that}", "{arguments}.0"]
            },
            isLive: {
                funcName: "gpii.preferencesServer.preferencesService.isLive",
                args: ["{dataStore}.findAllViews"]
            }
        },
        events: {
            onCreatePreferences: null,
            onAssociatePreferences: null,
            onCloudSafeCredCreate: null,
            onCloudSafeUnlock: null,
            onUpdatePrefsSafe: null
        },
        listeners: {
            onCreatePreferences: [{
                listener: "gpii.preferencesServer.preferencesService.verifyGpiiKey",
                args: ["{dataStore}.findGpiiKey", "{arguments}.0"],
                namespace: "verifyGpiiKey"
            }, {
                listener: "gpii.preferencesServer.preferencesService.createPrefsSafe",
                args: ["{dataStore}.addPrefsSafe", "{arguments}.0"],
                namespace: "createPrefsSafe"
            }, {
                listener: "gpii.preferencesServer.preferencesService.createGpiiKey",
                args: ["{dataStore}.addGpiiKey", "{arguments}.0"],
                namespace: "createGpiiKey"
            }],
            onAssociatePreferences: [{
                listener: "gpii.preferencesServer.preferencesService.createPrefsSafe",
                args: ["{dataStore}.addPrefsSafe", "{arguments}.0"],
                namespace: "createPrefsSafe"
            }, {
                listener: "gpii.preferencesServer.preferencesService.updateGpiiKey",
                args: ["{dataStore}.updateGpiiKey", "{arguments}.0"],
                namespace: "updateGpiiKey"
            }],
            onCloudSafeCredCreate: [{
                func: "{dataStore}.findById",
                args: ["{arguments}.0"],
                namespace: "findById"
            }, {
                func: "gpii.dbOperation.verifyExists",
                args: ["{arguments}.0", "prefsSafe", gpii.preferencesServer.errors.missingPrefsSafe.message,
                    gpii.preferencesServer.errors.missingPrefsSafe.errorCode]
            }, {
                func: "{expressUserUtils}.createNewUser",
                args: [{username: "{arguments}.1.username", password: "{arguments}.1.password"}],
                namespace: "createNewUser"
            }, {
                funcName: "gpii.dbOperation.dbDataStore.addRecord",
                args: ["{dbDataStore}.saveDataSource",
                       "gpiiCloudSafeCredential",
                       "id", {
                           type: "gpiiCloudSafeCredential",
                           schemaVersion: "0.1",
                           prefsSafeId: "{arguments}.1.prefsSafeId",
                           gpiiExpressUserId: "{arguments}.0._id"
                       }],
                namespace: "addRecord"
            }, {
                funcName: "{dataStore}.findById",
                args: ["{arguments}.0.id"]
            }],
            onCloudSafeUnlock: [{
                func: "{expressUserUtils}.unlockUser",
                args: ["{arguments}.0.username", "{arguments}.0.password"], // username, password
                namespace: "unlockUser"
            }, {
                func: "{dataStore}.findSafeByExpressUserLookup",
                args: ["{arguments}.0._id"],
                namespace: "findSafeByExpressUserLookup"
            }, {
                func: "{dataStore}.findById",
                args: ["{arguments}.0.prefsSafeId"],
                namespace: "findById"
            }],
            // onUpdatePrefsSafe is a pseudoevent for a promise chain. The primary method call is
            // `dataStore.updatePrefsSafe` which is flanked by calls to `getPrefsSafe` in order to confirm
            // existence of the safe, and then to return the final contents
            "onUpdatePrefsSafe.checkPrefsSetExist": {
                func: "{that}.getPrefsSafe",
                args: "{arguments}.1.id"
            },
            "onUpdatePrefsSafe.updatePrefsSafe": {
                func: "{dataStore}.updatePrefsSafe",
                args: ["{arguments}.1.id", "{arguments}.1"],
                priority: "after:checkPrefsSetExist"
            },
            "onUpdatePrefsSafe.getPrefsSafe": {
                func: "{that}.getPrefsSafe",
                args: "{arguments}.1.id",
                priority: "after:updatePrefsSafe"
            }
        }
    });

    // APIs for Preferences and Preferences Safes

    gpii.preferencesServer.preferencesService.errors = fluid.freezeRecursive({
        gpiiKeyMissing: "GPII key \"%gpiiKey\" does not exist",
        gpiiKeyExisted: "GPII key \"%gpiiKey\" already exists",
        noUpdateOnSnapset: "Cannot update:  GPII key \"%gpiiKey\" is a snapset"
    });

    /**
     * Returns a preferences safe using it's id. If the safe is not found an error object
     * is returned.
     *
     * @param {Object} dataStore - Instance of `gpii.dbOperation.dataStore`
     * @param {String} prefsSafeId - Prefs Safe ID
     * @return {Promise} Returns a promise resolving with the preferences safe,
     * or rejecting with an error payload containing an error `message`.
     */
    gpii.preferencesServer.preferencesService.getPrefsSafe = function (dataStore, prefsSafeId) {
        var promiseTogo = fluid.promise();
        dataStore.findById(prefsSafeId).then(
            function (data) {
                if ($.isEmptyObject(data) || data.type !== "prefsSafe") {
                    promiseTogo.reject({
                        isError: true,
                        errorCode: gpii.preferencesServer.errors.missingPrefsSafe.errorCode,
                        message: gpii.preferencesServer.errors.missingPrefsSafe.message
                    });
                }
                else {
                    promiseTogo.resolve(data);
                }
            },
            function (err) {
                fluid.log("Error looking up prefsSafe: ", err);
                promiseTogo.reject({
                    isError: true,
                    errorCode: gpii.preferencesServer.errors.errorAccessingPrefsSafe.errorCode,
                    message: gpii.preferencesServer.errors.errorAccessingPrefsSafe.message
                });
            }
        );
        return promiseTogo;
    };

    /**
     * Adds a new preferences safe to CouchDB using the preferences safe format.
     *
     * @param {Object} that - Instance of `gpii.preferencesServer.preferencesService`.
     * @param {Object} dataStore - Instance of `gpii.dbOperation.dataStore`
     * @param {Object} prefsSafeData - Preferences safe to add to system. The following fields
     * are not required as part of this payload, and will be automatically created upon add:
     * `id`, `timestampCreated`, and `timestampUpdated` properties.
     * @return {Promise} Returns a promise resolving with the newly created
     * preferences safe, or rejecting with an error payload containing an error `message`.
     */
    gpii.preferencesServer.preferencesService.addPrefsSafe = function (that, dataStore, prefsSafeData) {
        var promiseTogo = fluid.promise();
        if (prefsSafeData.type !== "prefsSafe") {
            promiseTogo.reject({
                isError: true,
                errorCode: gpii.preferencesServer.errors.errorNotPrefsSafe.errorCode,
                message: gpii.preferencesServer.errors.errorNotPrefsSafe.message
            });
        }
        else {
            // TODO This will have json schema validation when the scaffolding is all in.
            dataStore.addPrefsSafe(prefsSafeData).then(
                function (updatedReturn) {
                    that.getPrefsSafe(updatedReturn.id).then(promiseTogo.resolve, promiseTogo.reject);
                },
                promiseTogo.reject);
        };
        return promiseTogo;
    };

    /**
     * Updates a preferences safe in CouchDB.
     *
     * @param {Object} that - Instance of `gpii.preferencesServer.preferencesService`.
     * @param {Object} dataStore - Instance of `gpii.dbOperation.dataStore`
     * @param {Object} prefsSafeData - Preferences safe to add to system.
     * @return {Promise} Returns a promise resolving with the newly created
     * preferences safe, or rejecting with an error payload containing an error `message`.
     */
    gpii.preferencesServer.preferencesService.updatePrefsSafe = function (that, dataStore, prefsSafeData) {
        var promiseTogo = fluid.promise();
        if (!prefsSafeData.id || prefsSafeData.type !== "prefsSafe") {
            promiseTogo.reject({
                isError: true,
                errorCode: gpii.preferencesServer.errors.errorNotPrefsSafeMissingId.errorCode,
                message: gpii.preferencesServer.errors.errorNotPrefsSafeMissingId.message
            });
        }
        else {
            fluid.promise.fireTransformEvent(that.events.onUpdatePrefsSafe, {}, prefsSafeData).then(
                function (data) {
                    promiseTogo.resolve(data);
                },
                function (err) {
                    fluid.log(err);
                    promiseTogo.reject({
                        isError: true,
                        errorCode: gpii.preferencesServer.errors.missingPrefsSafe.errorCode,
                        message: gpii.preferencesServer.errors.missingPrefsSafe.message
                    });
                }
            );
        }
        return promiseTogo;
    };

    /**
     * Handler for creating cloud safe credentials.
     *
     * This handler will first fetch the preferences safe to make sure it
     * exists and is active.  It will then take the username and password and
     * create a new gpii-express-user entry.  With that we will then create
     * the cloudsafe credential document that will contain the ID's of both
     * the prefssafe and the user record.
     *
     * Currently this method does only a small amount of validation on the username
     * and password, requiring that both fields are included and of length greater than
     * length zero.
     *
     * @param {Object} that - Instance of `gpii.preferencesServer.preferencesService`.
     * @param {Object} options - Data used to create the new credentials.
     * @param {String} options.prefsSafeId - Id for the preferences safe we are adding
     * credentials to.
     * @param {String} options.username - Login username for these credentials.
     * @param {String} options.password - Password for these new credentials.
     * @return {Promise} Promise containing the new cloud credentials document.
     */
    gpii.preferencesServer.preferencesService.cloudSafeCredCreate = function (that, options) {
        var promiseTogo = fluid.promise();

        if (!options.username || !options.password) {
            promiseTogo.reject({
                isError: true,
                errorCode: gpii.preferencesServer.errors.errorCreateCredBadUsernamePassword.errorCode,
                message: gpii.preferencesServer.errors.errorCreateCredBadUsernamePassword.message
            });
            return promiseTogo;
        }

        fluid.promise.fireTransformEvent(that.events.onCloudSafeCredCreate, options.prefsSafeId, options).then(
            promiseTogo.resolve,
            function (err) {
                // Create a slightly more meaningful error message for the gpii-express-user reject when
                // the username is already used.
                // {
                //     "isError": true,
                //     "message": {
                //         "error": "conflict",
                //         "reason": "Document update conflict"
                //     }
                // }
                if (err.message && err.message.error === "conflict") {
                    fluid.log("Error adding cloud safe credential", err);
                    promiseTogo.reject({
                        isError: true,
                        errorCode: gpii.preferencesServer.errors.errorCreateCredBadUsernamePassword.errorCode,
                        message: gpii.preferencesServer.errors.errorCreateCredBadUsernamePassword.message
                    });
                }
                else {
                    promiseTogo.reject(err);
                }
            });
        return promiseTogo;
    };

    /**
     * Handler for unlocking a prefs safe.
     *
     * Steps:
     * 1. Try to unlock a gpii-express-user acct using the username/password.
     * 2. If successful, take the gpii-express-user.id and look up a cloud credentials doc for it.
     * 3. Fetch the Safe for that and return it.
     *
     * TODO: In the future the number of couch calls may by optimized.
     *
     * @param {Object} that - Instance of `gpii.preferencesServer.preferencesService`.
     * @param {Object} options - Data used to unlock the safe.
     * @param {String} options.username - Username to unlock the Preferences Safe.
     * @param {String} options.password - Password to unlock the Preferences Safe.
     * @return {Promise} Returns a promise containing either the unlocked Preferences Safe
     * record, or an error payload with a message.
     */
    gpii.preferencesServer.preferencesService.cloudSafeUnlock = function (that, options) {
        var promiseTogo = fluid.promise();
        fluid.promise.fireTransformEvent(that.events.onCloudSafeUnlock, {
            username: options.username,
            password: options.password
        }).then(promiseTogo.resolve,
            function (err) {
                fluid.log(err);
                promiseTogo.reject({
                    isError: true,
                    errorCode: gpii.preferencesServer.errors.errorUnlockingPrefsSafeCredentials.errorCode,
                    message: gpii.preferencesServer.errors.errorUnlockingPrefsSafeCredentials.message
                });
            }
        );
        return promiseTogo;
    };

    /**
     * Grant an authorization for the give GPII app installation. The gpii key will be verified before the access token is returned.
     * @param {Component} findPrefsSafeByGpiiKey - An instance of gpii.preferencesServer.preferencesService.
     * @param {String} gpiiKey - A GPII key.
     * @return {Promise} A promise object whose resolved value is the entire preferences associated with the GPII key.
     * An error will be returned if the GPII key is not found or there is no preferences defined for the GPII key.
     */
    gpii.preferencesServer.preferencesService.getPreferencesByGpiiKey = function (findPrefsSafeByGpiiKey, gpiiKey) {
        var promiseTogo = fluid.promise();
        var dataPromise = findPrefsSafeByGpiiKey(gpiiKey);

        dataPromise.then(function (data) {
            if (data === undefined) {
                fluid.log("Preferences Service, getPreferencesByGpiiKey() rejected: missing GPII key: " + gpiiKey);
                promiseTogo.reject(gpii.preferencesServer.errors.missingGpiiKey);
            } else {
                promiseTogo.resolve(data.prefsSafe ? fluid.get(data, ["prefsSafe", "preferences"]) : undefined);
            }
        }, function (err) {
            promiseTogo.reject(err);
        });
        return promiseTogo;
    };

    /**
     * The entry point of createPreferences() API. Fires the transforming promise workflow by triggering onCreatePreferences event.
     * It handles:
     * 1. If no GPII key is provided, auto generate and create a GPII key. Also create a new prefs safe to associate with this key;
     * 2. If a GPII key is provided and does not exist, create it. Also create a new prefs safe to associate with this key;
     * 3. If a GPII key is provided and already exists, reject with an error.
     * @param {Component} that - An instance of gpii.preferencesServer.preferencesService component.
     * @param {Object} preferences - The prefs safe data
     * {
     *     prefsSafeType: {String}
     *     name: {String}
     *     email: {String}
     *     preferences: {Object}  // must be provided
     * }
     * @param {String} [gpiiKey] - [optional] The new GPII key, an UUID will be generated if it's not provided
     * @return {Promise} A promise that will be resolved with the results of the transform event.
     */
    gpii.preferencesServer.preferencesService.createPreferences = function (that, preferences, gpiiKey) {
        return fluid.promise.fireTransformEvent(that.events.onCreatePreferences, {
            gpiiKey: gpiiKey,
            prefsSafeData: {
                preferences: preferences
            }
        });
    };

    /**
     * The first step in the promise transforming chain for implementing createPreferences() API.
     * Verify the provided GPII key. Reject the creation if the key already exists.
     * @param {Function} findGpiiKey - The findGpiiKey() API provided by preferencesServer.preferencesService.
     * @param {Object} input - The data passed on from the entry function gpii.preferencesServer.preferencesService.createPreferences(). Its structure:
     *  {
     *      gpiiKey: {String},   // Optional
     *      prefsSafeData: {
     *          prefsSafeType: {String}
     *          name: {String}
     *          email: {String}
     *          preferences: {Object}  // must be provided
     *      }
     *  }
     * @return {Promise} A promise object that carries the given input value with the created prefsSafeId being added.
     */
    gpii.preferencesServer.preferencesService.verifyGpiiKey = function (findGpiiKey, input) {
        var promiseTogo = fluid.promise();
        var gpiiKey = input.gpiiKey;

        if (gpiiKey) {
            // verify the uniqueness of the provided GPII key
            var gpiiKeyPromise = findGpiiKey(gpiiKey);
            gpiiKeyPromise.then(function (data) {
                if (data) {
                    // reject if the GPII key already exists
                    var gpiiKeyExistsMsg = fluid.stringTemplate(gpii.preferencesServer.errors.gpiiKeyExists.message, {
                        gpiiKey: gpiiKey
                    });
                    fluid.log("Preferences Service, verifyGpiiKey() rejected: ", gpiiKeyExistsMsg);
                    promiseTogo.reject({
                        errorCode: gpii.preferencesServer.errors.gpiiKeyExists.errorCode,
                        message: gpiiKeyExistsMsg
                    });
                } else {
                    promiseTogo.resolve(input);
                }
            }, function (err) {
                promiseTogo.reject(err);
            });
        } else {
            promiseTogo.resolve(input);
        }
        return promiseTogo;
    };

    /**
     * Shared function in the promise transforming chain for implementing createPreferences() and updatePreferences() API.
     * Create a prefsSafe record with the provided prefsSafeData.
     * @param {Function} addPrefsSafe - The addPrefsSafe() API provided by gpii.oauth2.dbDataStore.
     * @param {Object} input - The data passed on from the entry function gpii.preferencesServer.preferencesService.createPreferences(). Its structure:
     *  {
     *      gpiiKey: {String} or {Object},  // {String} for createPreferences(), {Object} for updatePreferences()
     *      prefsSafeData: {
     *          prefsSafeType: {String},  // optional
     *          name: {String},  // optional
     *          email: {String},  // optional
     *          preferences: {Object}  // must be provided
     *      }
     *  }
     * @return {Promise} A promise object that carries the given input value with the created prefsSafeId being added.
     */
    gpii.preferencesServer.preferencesService.createPrefsSafe = function (addPrefsSafe, input) {
        var promiseTogo = fluid.promise();
        var prefsSafeData = input.prefsSafeData;
        var prefsSafeDataAdded = {
            prefsSafeType: prefsSafeData.prefsSafeType || gpii.preferencesServer.prefsSafeType.user,
            name: prefsSafeData.name || null,
            email: prefsSafeData.email || null,
            preferences: prefsSafeData.preferences
        };

        var addPrefsSafePromise = addPrefsSafe(prefsSafeDataAdded);
        addPrefsSafePromise.then(function (addPrefsSafeResponse) {
            fluid.log("Preferences Service, created a new prefs safe with id: ", addPrefsSafeResponse.id);
            promiseTogo.resolve({
                gpiiKey: input.gpiiKey,
                prefsSafeId: addPrefsSafeResponse.id,
                prefsSafeDataAdded: prefsSafeDataAdded
            });
        }, function (err) {
            promiseTogo.reject(err);
        });
        return promiseTogo;
    };

    /**
     * Stand alone method to add a `gpiiKey` document in the system. `prefsSafeId` and `prefSetId` are
     * required fields. Optionally you can specify the `gpiiKey` otherwise a new one will be generated.
     * This key must not exist yet.
     * @param {Object} that - Instance of `gpii.preferencesServer.preferencesService`.
     * @param {Object} dataStore - Instance of `gpii.dbOperation.dataStore`
     * @param {Object} keyData - Data for the new `gpiiKey` document.
     * @return {Promise} A promise object that resolves to the new saved document, or rejects with a
     * standard error payload.
     */
    gpii.preferencesServer.preferencesService.addGpiiKey = function (that, dataStore, keyData) {
        var promTogo = fluid.promise();

        if (!keyData.prefsSafeId || !keyData.prefsSetId) {
            promTogo.reject({
                isError: true,
                errorCode: gpii.preferencesServer.errors.errorMissingPrefsSafeAndSetId.errorCode,
                message: gpii.preferencesServer.errors.errorMissingPrefsSafeAndSetId.message
            });
        }
        else {
            // Preferences Safe must exist to add this key
            that.getPrefsSafe(keyData.prefsSafeId).then(function () {
                // TODO This will have json schema validation when the scaffolding is all in.
                // Add the new key...
                dataStore.addGpiiKey({
                    gpiiKey: keyData.gpiiKey, // Can be undefined
                    prefsSafeId: keyData.prefsSafeId,
                    prefsSetId: keyData.prefsSetId
                }).then(
                    // ...and then fetch the newly added key and return it.
                    function (newKeyData) {
                        dataStore.findById(newKeyData.id).then(promTogo.resolve, promTogo.reject);
                    },
                    function (error) {
                        fluid.log("Error adding key to preferences safe: ", keyData, error);
                        promTogo.reject({
                            isError: true,
                            errorCode: gpii.preferencesServer.errors.errorAddingGpiiKey.errorCode,
                            message: gpii.preferencesServer.errors.errorAddingGpiiKey.message
                        });
                    }
                );
            },
            function (error) {
                fluid.log("Error in addGpiiKey prefSafe Lookup", error);
                promTogo.reject({
                    isError: true,
                    errorCode: gpii.preferencesServer.errors.missingPrefsSafe.errorCode,
                    message: gpii.preferencesServer.errors.missingPrefsSafe.message
                });
            });
        }

        return promTogo;
    };

    /**
     * The last step in the promise transforming chain for implementing createPreferences() API.
     * Create a gpiiKey record with the provided input.
     * @param {Function} addGpiiKey - The addGpiiKey() API provided by gpii.oauth2.dbDataStore.
     * @param {Object} input - The data passed on from the previous step. Its structure:
     *  {
     *      gpiiKey: {String},
     *      prefsSafeId: {String},
     *      prefsSafeDataAdded: {
     *          prefsSafeType: {String}
     *          name: {String}
     *          email: {String}
     *          preferences: {Object}  // must be provided
     *      }
     *  }
     * @return {Promise} A promise object whose resolved value is:
     *  {
     *      gpiiKey: {String},
     *      preferences: {Object}
     *  }
     */
    gpii.preferencesServer.preferencesService.createGpiiKey = function (addGpiiKey, input) {
        var addGpiiKeyPromise = addGpiiKey({
            gpiiKey: input.gpiiKey,
            prefsSafeId: input.prefsSafeId,
            prefsSetId: gpii.preferencesServer.defaultPrefsSetId
        });

        var mapper = function (addGpiiKeyResponse) {
            fluid.log("Preferences Service, created a new GPII key with id: ", addGpiiKeyResponse.id);
            return {
                gpiiKey: addGpiiKeyResponse.id,
                preferences: input.prefsSafeDataAdded.preferences
            };
        };
        return fluid.promise.map(addGpiiKeyPromise, mapper);
    };

    /**
     * The entry point of updatePreferences() API.
     * It handles:
     * 1. If an existing prefs safe already associates with the GPII key, update the prefs safe;
     * 2. If no prefs safe is associated with the GPII key, create the prefs safe and associate with the GPII key.
     * @param {Component} that - An instance of gpii.preferencesServer.preferencesService
     * @param {Object} preferences - The preferences to be updated
     * @param {String} [gpiiKey] - [optional] The new GPII key, an UUID will be generated if it's not provided
     * @param {Boolean} [merge] - [optional] A flag that indicates whether to merge the incoming preferences with the existing preferences
     * @return {Promise} A promise object whose resolved value is:
     *  {
     *      gpiiKey: {String},
     *      preferences: {Object}
     *  }
     */
    gpii.preferencesServer.preferencesService.updatePreferences = function (that, preferences, gpiiKey, merge) {
        var promiseTogo = fluid.promise();
        var gpiiKeyPromise = that.dataStore.findPrefsSafeByGpiiKey(gpiiKey);

        gpiiKeyPromise.then(function (data) {
            var updatePromise = fluid.promise();
            var prefsSafeId = fluid.get(data, ["gpiiKeyDetails", "prefsSafeId"]);

            if (prefsSafeId) {
                if (data.prefsSafe.prefsSafeType !== gpii.preferencesServer.prefsSafeType.user) {
                    fluid.log("Preferences Service, reject the update request on a snapset key: ", gpiiKey);
                    var readOnlyMsg = fluid.stringTemplate(gpii.preferencesServer.errors.readOnly.message, {
                        gpiiKey: gpiiKey
                    });
                    updatePromise.reject({
                        errorCode: gpii.preferencesServer.errors.readOnly.errorCode,
                        message: readOnlyMsg
                    });
                } else {
                    // The merge flag determines whether to merge the new preferences with the existing preferences
                    var prefsSafeData = fluid.extend(merge, {}, data.prefsSafe, {preferences: preferences});
                    // Update the associated prefs safe
                    var updatePrefsSafePromise = that.dataStore.updatePrefsSafe(prefsSafeId, prefsSafeData);
                    var mapper = function () {
                        return {
                            gpiiKey: gpiiKey,
                            preferences: preferences
                        };
                    };
                    updatePromise = fluid.promise.map(updatePrefsSafePromise, mapper);
                }
            } else {
                // Create a prefs safe and associate it with the GPII key
                updatePromise = fluid.promise.fireTransformEvent(that.events.onAssociatePreferences, {
                    gpiiKey: data.gpiiKeyDetails,
                    prefsSafeData: {
                        preferences: preferences
                    }
                });
            }
            fluid.promise.follow(updatePromise, promiseTogo);
        }, function (err) {
            promiseTogo.reject(err);
        });
        return promiseTogo;
    };

    /**
     * The last step in the promise transforming chain for implementing fireTransformEvent onAssociatePreferences event.
     * Update gpiiKey record with the created prefs safe id.
     * @param {Function} updateGpiiKey - The updateGpiiKey() API provided by gpii.oauth2.dbDataStore
     * @param {Object} input - The data passed on from the previous step. Its structure:
     *  {
     *      gpiiKey: {String},
     *      prefsSafeId: {String},
     *      prefsSafeDataAdded: {
     *          prefsSafeType: {String}
     *          name: {String}
     *          email: {String}
     *          preferences: {Object}  // must be provided
     *      }
     *  }
     * @return {Promise} A promise object whose resolved value is:
     *  {
     *      gpiiKey: {String},
     *      preferences: {Object}
     *  }
     */
    gpii.preferencesServer.preferencesService.updateGpiiKey = function (updateGpiiKey, input) {
        var gpiiKeyRec = fluid.copy(input.gpiiKey);
        fluid.set(gpiiKeyRec, ["prefsSafeId"], input.prefsSafeId);
        fluid.set(gpiiKeyRec, ["prefsSetId"], gpii.preferencesServer.defaultPrefsSetId);
        var updateGpiiKeyPromise = updateGpiiKey(fluid.get(input, ["gpiiKey", "id"]), gpiiKeyRec);

        var mapper = function (response) {
            fluid.log("Preferences Service, updated GPII key with id: ", response.id);
            return {
                gpiiKey: response.id,
                preferences: response.preferences
            };
        };
        return fluid.promise.map(updateGpiiKeyPromise, mapper);
    };

    /**
     * Verify if the preference server is running and the database connection is
     * good.
     * @param {Function} findAllViews - The findAllViews() API provided by
     *                                  gpii.oauth2.dbDataStore
     * @return {Promise} resolves to {isReady: true} if the database connection
     *                   is ok. Otherwise, resolves to {isReady: false}.
     */
    gpii.preferencesServer.preferencesService.isLive = function (findAllViews) {
        var promiseTogo = fluid.promise();
        var viewsPromise = findAllViews();
        viewsPromise.then(function (views) {
            promiseTogo.resolve({isReady: fluid.isPlainObject(views)});
        }, function () {
            promiseTogo.resolve({isReady: false});
        });
        return promiseTogo;
    };
})();
