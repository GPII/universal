/*
GPII Serverside renderer component.

Copyright 2012 OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

(function () {

    "use strict";

    var fluid = require("infusion"),
        gpii = fluid.registerNamespace("gpii");

    fluid.registerNamespace("gpii.renderer");

    gpii.renderer.render = function (source, options) {
        var rendererOptions = options.rendererOptions;
        rendererOptions.document = typeof document !== "undefined" ? document : {
            getElementById: function () {}
        };
        var templates = fluid.parseTemplates({
            base: {
                resourceText: source,
                href: ".",
                resourceKey: ".",
                cutpoints: rendererOptions.cutpoints
            }
        }, ["base"], rendererOptions);
        return fluid.renderTemplates(templates, options.tree,
            rendererOptions, rendererOptions.fossils);
    };

    fluid.defaults("gpii.renderer", {
        gradeNames: ["autoInit", "fluid.modelComponent",
            "fluid.eventedComponent"],
        mergePolicy: {
            protoTree: "noexpand, replace",
            parentBundle: "nomerge",
            "envAdd.styles": "styles",
            ELstyle: "noexpand",
            instantiator: "nomerge"
        },
        resolverGetConfig: undefined,
        resolverSetConfig: undefined,
        autoBind: false,
        fossils: {},
        components: {
            messageResolver: {
                type: "fluid.messageResolver",
                options: {
                    messageBase: "{gpii.renderer}.options.strings",
                    resolveFunc: "{gpii.renderer}.options.messageResolverFunction",
                    parents: ["{gpii.renderer}.options.parentBundle"]
                }
            }
        },
        instantiator: "{instantiator}",
        parentComponent: "{that}",
        selectors: {},
        styles: {},
        ELstyle: "${}",
        events: {
            prepareModelForRender: null,
            onRenderTree: null,
            afterRender: null,
            produceTree: "unicast"
        },
        listeners: {
            produceTree: [
                "{that}.onProduceTree"
            ]
        },
        cutpointGenerator: "fluid.renderer.selectorsToCutpoints"
    });

    gpii.renderer.preInit = function (that) {
        that.onProduceTree = function () {
            return that.options.protoTree;
        };

        if (that.options.produceTree) {
            that.options.listeners.produceTree.push(that.options.produceTree);
        }

        if (that.options.resources && that.options.resources.template) {
            that.source = that.options.resources.template.resourceText;
        }

        that.expand = fluid.renderer.makeProtoExpander(that.options);
    };

    gpii.renderer.finalInit = function (that) {
        that.options.messageSource = {
            type: "resolver", resolver: that.messageResolver
        };

        that.options.cutpoints = fluid.invokeGlobalFunction(
            that.options.cutpointGenerator, [that.options.selectors,
            that.options]);

        that.render = function (source) {
            source = source || that.source;
            that.events.prepareModelForRender.fire(that.model, that.applier,
                that);
            var tree = that.events.produceTree.fire(that);
            tree = that.expand(tree);
            that.events.onRenderTree.fire(that, tree);
            var rendered = gpii.renderer.render(source, {
                rendererOptions: that.options,
                tree: tree
            });
            that.events.afterRender.fire(that);
            return rendered;
        };

        if (that.options.renderOnInit) {
            that.render();
        }
    };

})();