/*
GPII Serverside renderer component.

Copyright 2012 OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

var fluid = fluid || require("infusion"),
    gpii = fluid.registerNamespace("gpii");

(function () {

    "use strict";

    fluid.registerNamespace("gpii.renderer");

    gpii.renderer.renderImpl = function (source, options) {
        var rendererOptions = options.rendererOptions;
        rendererOptions.document = typeof document !== "undefined" ? document : {
            getElementById: function () {}
        };
        var templates = fluid.parseTemplates({
            base: {
                resourceText: source,
                href: ".",
                resourceKey: ".",
                cutpoints: rendererOptions.cutpoints
            }
        }, ["base"], rendererOptions);
        return fluid.renderTemplates(templates, options.tree,
            rendererOptions, rendererOptions.fossils);
    };

    fluid.defaults("gpii.renderer", {
        gradeNames: ["autoInit", "fluid.modelComponent",
            "fluid.eventedComponent"],
        mergePolicy: {
            protoTree: "noexpand, replace",
            parentBundle: "nomerge",
            "envAdd.styles": "styles",
            ELstyle: "noexpand"
        },
        resolverGetConfig: undefined,
        resolverSetConfig: undefined,
        autoBind: false,
        fossils: {},
        components: {
            messageResolver: {
                type: "fluid.messageResolver",
                options: {
                    messageBase: "{gpii.renderer}.options.strings",
                    resolveFunc: "{gpii.renderer}.options.messageResolverFunction",
                    parents: ["{gpii.renderer}.options.parentBundle"]
                }
            }
        },
        selectors: {},
        styles: {},
        ELstyle: "${}",
        events: {
            prepareModelForRender: null,
            onRenderTree: null,
            afterRender: null,
            produceTree: "unicast"
        },
        listeners: {
            produceTree: [
                "{that}.onProduceTree"
            ],
            onCreate: "{that}.onCreate"
        },
        invokers: {
            onProduceTree: {
                funcName: "fluid.identity",
                args: "{that}.options.protoTree"
            },
            render: {
                funcName: "gpii.renderer.render",
                args: ["{arguments}.0", "{that}"]
            },
            onCreate: {
                funcName: "gpii.renderer.renderOnInit",
                args: ["{that}.options.renderOnInit", "{that}.render"]
            }
        },
        messageSource: {
            type: "resolver",
            resolver: "{that}.messageResolver"
        },
        members: {
            source: "{that}.options.resources.template.resourceText",
            expand: {
                expander: {
                    func: "fluid.renderer.makeProtoExpander",
                    args: "{that}.options"
                }
            }
        },
        cutpoints: {
            expander: {
                func: "{that}.options.cutpointGenerator",
                args: ["{that}.options.selectors", "{that}.options"]
            }
        },
        cutpointGenerator: "fluid.renderer.selectorsToCutpoints"
    });

    fluid.defaults("gpii.renderer.injector", {
        gradeNames: ["autoInit", "fluid.eventedComponent"],
        listeners: {
            "{gpii.renderer}.events.afterRender": "{that}.inject"
        },
        invokers: {
            inject: {
                funcName: "gpii.renderer.injector.inject",
                args: ["{that}.options.template", "{gpii.renderer}"]
            }
        },
        template: '<script type="text/javascript">' +
            'fluid.defaults("fluid.injectedRendererComponent", {gradeNames: ["autoInit", "fluid.rendererComponent"]});' +
            'fluid.injectedRendererComponent("body", %options);</script>'
    });

    gpii.renderer.injector.inject = function (template, renderer) {
        var toInject = fluid.stringTemplate(template, {
            options: JSON.stringify({
                selectors: renderer.options.selectors,
                strings: renderer.options.strings,
                fossils: renderer.options.fossils,
                styles: renderer.options.styles,
                protoTree: renderer.options.protoTree
            })
        });
        var bodyEndPos = renderer.rendered.indexOf("</body>");
        renderer.rendered = renderer.rendered.substring(0, bodyEndPos - 1) +
            toInject + renderer.rendered.substring(bodyEndPos);
    };

    gpii.renderer.render = function (source, that) {
        source = source || that.source;
        that.events.prepareModelForRender.fire(that.model, that.applier,
            that);
        var tree = that.events.produceTree.fire(that);
        tree = that.expand(tree);
        that.events.onRenderTree.fire(that, tree);
        that.rendered = gpii.renderer.renderImpl(source, {
            rendererOptions: that.options,
            tree: tree
        });
        that.events.afterRender.fire(that);
        return that.rendered;
    };

    gpii.renderer.renderOnInit = function (renderOnInit, render) {
        if (!renderOnInit) {
            return;
        }
        render();
    };

    gpii.renderer.preInit = function (that) {
        if (that.options.produceTree) {
            that.options.listeners.produceTree.push(that.options.produceTree);
        }
    };

})();