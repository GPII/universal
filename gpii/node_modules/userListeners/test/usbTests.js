/*
 * USB User listener tests
 *
 * Copyright 2017 Raising the Floor - International
 * Copyright 2019 OCAD University
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";
var fluid = require("infusion"),
    path = require("path"),
    fs = require("fs"),
    rimraf = require("rimraf");

var jqUnit = fluid.require("node-jqunit");
var gpii = fluid.registerNamespace("gpii");
fluid.registerNamespace("gpii.tests.userListener");

require("../index.js");
require("./shared/lifecycleManagerTestGrade.js");

fluid.defaults("gpii.tests.userListener.usbListener", {
    gradeNames: ["gpii.userListeners.usb"],
    components: {
        lifecycleManager: {
            type: "gpii.tests.userListener.lifecycleManager"
        }
    },
    invokers: {
        startListener: "fluid.identity",
        stopListener: "fluid.identity"
    }
});

var teardowns = [];
jqUnit.module("gpii.tests.userListener.usb", {
    teardown: function () {
        while (teardowns.length) {
            teardowns.pop()();
        }
    }
});

gpii.tests.userListener.insertTests = [
    // Device added
    {
        current: null,
        device: "token1",
        expect: "token1"
    },
    // Device added
    {
        current: null,
        device: "token2",
        expect: "token2"
    },
    // Empty device added
    {
        current: null,
        device: "empty",
        expect: null
    },
    // Already a device, another added
    {
        current: "token1",
        device: "token2",
        expect: null
    },
    // Already a device, empty added
    {
        current: "token1",
        device: "empty",
        expect: null
    },
    // Same device re-added (abnormal)
    {
        current: "token1",
        device: "token1",
        expect: null
    }
];

gpii.tests.userListener.removeTests = [
    // Device removed
    {
        current: "token1",
        device: "token1",
        expect: true
    },
    // Empty device removed
    {
        current: "token1",
        device: "empty",
        expect: false
    },
    // Different device removed
    {
        current: "token1",
        device: "token2",
        expect: false
    },
    // Device removed - no current
    {
        current: null,
        device: "token1",
        expect: false
    }
];


/**
 * Perform the device add/remove tests - tests reading the token file from the mount point, with the correct reaction.
 *
 * @param {Array} tests - An array of test data objects.
 * @param {Function} func - The function to test - gpii.userListeners.usb.readUSBToken or deviceRemoved.
 * @param {Boolean} createFiles - True to create the directories for the devices.
 * @param {Number} expectedNumOfAsserts - The expected number of assertions.
 */
gpii.tests.userListener.deviceMountTests = function (tests, func, createFiles, expectedNumOfAsserts) {
    jqUnit.expect(expectedNumOfAsserts);
    var tokenFile = ".gpii-user-token.txt";
    var usbListener = gpii.tests.userListener.usbListener();

    var testDir = fs.mkdtempSync(path.join(process.env.temp || "/tmp", "gpii-usb-test"));
    teardowns.push(function () {
        rimraf.sync(testDir);
    });

    // Create some fake device mount points
    var devices = {};
    fluid.each([ "token1", "token2", "empty" ], function (name) {
        var dir = path.join(testDir, name);
        devices[name] = {
            dir: dir
        };

        if (createFiles) {
            fs.mkdirSync(dir);

            if (name !== "empty") {
                fs.writeFileSync(path.join(dir, tokenFile), name);
            }
        }
    });

    var testWork = fluid.transform(tests, function (test) {
        return function () {
            var promise = fluid.promise();
            fluid.log(test);

            // Set up the current state.
            usbListener.currentDevice = {
                path: test.current && devices[test.current].dir,
                token: test.current
            };

            // Add/remove the device.
            var p = func(usbListener, devices[test.device].dir);
            fluid.toPromise(p).then(
                function (value) {
                    jqUnit.assertEquals("token should match the expected", test.expect, value);
                },
                function (value) {
                    if (test.expect) {
                        fluid.log(value);
                    }
                    jqUnit.assertNull("readUSBToken should reject", test.expect);
                }
            ).then(promise.resolve, promise.resolve);

            return promise;
        };
    });

    fluid.promise.sequence(testWork).then(jqUnit.start, jqUnit.fail);
};

// Tests USB device insertion.
jqUnit.asyncTest("USB listener - device inserted", function () {
    gpii.tests.userListener.deviceMountTests(
        gpii.tests.userListener.insertTests,  gpii.userListeners.usb.readUSBToken, true, 8);
});

// Tests USB device removal.
jqUnit.asyncTest("USB listener - device removed", function () {
    // The directories are not created with these tests, as the mount point shouldn't exist when the device has gone.
    gpii.tests.userListener.deviceMountTests(
        gpii.tests.userListener.removeTests,  gpii.userListeners.usb.deviceRemoved, false, 5);
});
