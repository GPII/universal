/*
 * userFolder User listener tests
 *
 * Copyright 2017 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";
var fluid = require("infusion"),
    os = require("os"),
    path = require("path"),
    fs = require("fs");

var jqUnit = fluid.require("node-jqunit");
var gpii = fluid.registerNamespace("gpii");
fluid.registerNamespace("gpii.tests.userListener");

require("../index.js");
require("./shared/lifecycleManagerTestGrade.js");

fluid.defaults("gpii.tests.userListener.userFolderListener", {
    gradeNames: ["gpii.userListeners.userFolder"],
    components: {
        lifecycleManager: {
            type: "gpii.tests.userListener.lifecycleManager"
        }
    },
    invokers: {
        startListener: "fluid.identity",
        stopListener: "fluid.identity"
    }
});

var teardowns = [];
jqUnit.module("gpii.tests.userListener.userFolder", {
    teardown: function () {
        while (teardowns.length) {
            teardowns.pop()();
        }
    }
});

gpii.tests.userListener.tokenFileTests = fluid.freezeRecursive([
    {
        filename: "test1",
        content: "test-key1",
        expect: "test-key1"
    },
    {
        filename: "test2",
        content: " \n \t test-key2 \n \t \r",
        expect: "test-key2"
    },
    {
        filename: "test3",
        content: "",
        expect: "reject"
    },
    {
        filename: "test4",
        content: " \r\n\t",
        expect: "reject"
    },
    {
        directory: "/does/not/exist",
        filename: "a",
        expect: "reject"
    },
    {
        directory: "/",
        filename: "",
        expect: "reject"
    },
    {
        directory: "",
        filename: "",
        expect: "reject"
    }
]);

/**
 * Get an instance of the gpii.userListeners.userFolder component.
 * @return {Component} The gpii.userListeners.userFolder component.
 */
gpii.tests.userListener.getUserFolderListener = function () {
    var userListeners = gpii.userListeners({
        listeners: {
            "onCreate.startListeners": "fluid.identity"
        },
        events: {
            "onListenersStart": null
        },
        distributeOptions: {
            userFolder: {
                record: "gpii.tests.userListener.userFolderListener",
                target: "{that userFolder}.options.gradeNames"
            }
        }
    });

    return userListeners.userFolder;
};

jqUnit.asyncTest("userFolder readTokenFile", function () {

    var tests = gpii.tests.userListener.tokenFileTests;

    jqUnit.expect(tests.length * 2);
    var tempDir = path.join(os.tmpdir(), "gpii-listener-tests" + Math.random());
    fs.mkdirSync(tempDir);
    var tempFiles = [];

    teardowns.push(function () {
        while (tempFiles.length) {
            fs.unlinkSync(tempFiles.pop());
        }
        fs.rmdirSync(tempDir);
    });

    var doTest = function (index) {
        if (index >= tests.length) {
            jqUnit.start();
        } else {
            var currentTest = tests[index];
            var messagePrefix = " - test index " + index;

            if (currentTest.hasOwnProperty("content")) {
                var tempFile = path.join(tempDir, currentTest.filename);
                fs.writeFileSync(tempFile, currentTest.content, "utf8");
                tempFiles.push(tempFile);
            }

            var directory = currentTest.hasOwnProperty("directory") ? currentTest.directory : tempDir;
            var file = currentTest.filename;

            var p = gpii.userListeners.readTokenFile(directory, file);

            jqUnit.assertTrue("readTokenFile must return a promise" + messagePrefix, fluid.isPromise(p));

            p.then(function (token) {
                jqUnit.assertEquals("readTokenFile should resolve with the expected value" + messagePrefix,
                    currentTest.expect, token);

                doTest(index + 1);
            }, function () {
                jqUnit.assertEquals("readTokenFile should reject if expected" + messagePrefix,
                    currentTest.expect, "reject");

                doTest(index + 1);
            });
        }
    };

    doTest(0);
});

jqUnit.asyncTest("userFolder writeTokenFile", function () {

    var tempDir = os.tmpdir();
    var tokenFile = "test-token-file" + Math.random();
    var tokenPath = path.join(tempDir, tokenFile);

    teardowns.push(function () {
        try {
            fs.unlinkSync(tokenPath);
        } catch (e) {
            // ignore
        }
    });

    fluid.promise.sequence([
        function () {
            var p = gpii.userListeners.writeTokenFile(tempDir, tokenFile, "token1", true);
            jqUnit.assertTrue("1st writeTokenFile should return a promise", fluid.isPromise(p));

            return p.then(function () {
                var content = fs.readFileSync(tokenPath, "utf8");
                jqUnit.assertEquals("Token in file should match what was written", "token1", content);
            });
        },
        function () {
            // Using the same path as before also tests over-writing.
            var p = gpii.userListeners.writeTokenFile(tokenPath, null, "token2", true);
            jqUnit.assertTrue("2nd writeTokenFile should return a promise", fluid.isPromise(p));

            return p.then(function () {
                var content = fs.readFileSync(tokenPath, "utf8");
                jqUnit.assertEquals("Token in file should match what was written", "token2", content);
            });
        },
        function () {
            var p = gpii.userListeners.writeTokenFile("does/not/exist", tokenFile, "token3", true);
            jqUnit.assertTrue("3rd writeTokenFile should return a promise", fluid.isPromise(p));

            var promiseTogo = fluid.promise();
            p.then(function () {
                jqUnit.fail("writeTokenFile with a bad path should reject");
                promiseTogo.reject();
            }, promiseTogo.resolve);
        }
    ]).then(jqUnit.start, jqUnit.fail);
});

// Test if the login on startup gets called.
jqUnit.asyncTest("Test attemptLogin", function () {

   jqUnit.expect(3);

   var testToken = "test-token" + Math.random();

   // Write the test token file.
   var tempDir = os.tmpdir();
   var tokenFile = "test-token-file" + Math.random();
   var tokenPath = path.join(tempDir, tokenFile);
   fs.writeFileSync(tokenPath, testToken, "utf8");

   teardowns.push(function () {
       try {
           fs.unlinkSync(tokenPath);
       } catch (e) {
           // ignore
       }
   });

   var userFolder = gpii.tests.userListener.getUserFolderListener();

   userFolder.tokenDirectory = tempDir;
   userFolder.tokenFile = tokenFile;

   var eventRaised = false;

   userFolder.events.onTokenArrive.addListener(function (that, token) {
       jqUnit.assertFalse("Token event should only fire once", eventRaised);
       eventRaised = true;
       jqUnit.assertEquals("Token in event should match the test token", testToken, token);
   });

   gpii.userListeners.userFolder.attemptLogin(userFolder).then(function () {
       // try it again - it should reject.
       gpii.userListeners.userFolder.attemptLogin(userFolder).then(function () {
           jqUnit.fail("Second call to attemptLogin should reject");
       }, jqUnit.start);
   });
});

// Tests that the onSessionStart event would be listened upon if configured to.
jqUnit.test("test addLoginListener", function () {

    jqUnit.expect(3);

    var tokenValue = "test-token";
    var tokenWrote = false;

    var userFolder = gpii.tests.userListener.getUserFolderListener();

    // Fake the storeToken routine.
    userFolder.storeToken = function (token) {
        tokenWrote = true;
        jqUnit.assertEquals("Correct token should be written", tokenValue, token);
    };

    var firer = fluid.makeEventFirer();

    // Test when saving is disabled
    userFolder.options.saveLastLogin = false;
    gpii.userListeners.userFolder.addLoginListener(userFolder, firer);
    firer.fire("dummy", tokenValue);

    jqUnit.assertFalse("Token should not have been written", tokenWrote);

    // Test when saving is enabled
    userFolder.options.saveLastLogin = true;
    gpii.userListeners.userFolder.addLoginListener(userFolder, firer);
    firer.fire("dummy", tokenValue);

    jqUnit.assertTrue("Token should have been written", tokenWrote);

    userFolder.destroy();
});
