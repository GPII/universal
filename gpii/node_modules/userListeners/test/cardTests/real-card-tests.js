/*
 * Tests that use a real card - not invoked by CI.
 *
 * Copyright 2017 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";
var fluid = require("infusion"),
    kettle = fluid.require("kettle");

kettle.loadTestingSupport();

var jqUnit = fluid.require("node-jqunit");
var gpii = fluid.registerNamespace("gpii");
fluid.registerNamespace("gpii.tests.card");

var teardowns = [];
jqUnit.module("gpii.tests.cards", {
    teardown: function () {
        while (teardowns.length) {
            teardowns.pop()();
        }
    }
});

require("../../index.js");

var Pcsclite = require("@pokusew/pcsclite");

fluid.defaults("gpii.userListeners.pcsc.test", {
    invokers: {
        getPCSCLite: "gpii.tests.card.getPCSCLite",
        startListener: "fluid.identity"
    }
});

/**
 * Get an instance of the gpii.userListeners.pcsc component.
 */
gpii.tests.card.getPcscListener = function () {
    var userListeners = gpii.userListeners({
        listeners: {
            "onCreate.startListeners": "fluid.identity"
        },
        distributeOptions: {
            record: "gpii.userListeners.pcsc.test",
            target: "{that pcsc}.options.gradeNames"
        }
    });

    return userListeners.pcsc;
};

gpii.tests.card.getPCSCLite = function () {
    return new Pcsclite();
};

gpii.tests.card.connectToCard = function (pcsc) {
    var promise = fluid.promise();

    pcsc.on("reader", function (reader) {
        fluid.log("Got card reader", reader.name);

        reader.on("status", function (status) {
            var action = gpii.userListeners.pcsc.getCardAction(reader.state, status.state);
            if (action === "presented" && !promise.disposition) {
                reader.connect({share_mode: reader.SCARD_SHARE_SHARED}, function (err, proto) {
                    if (err) {
                        promise.reject(err);
                    } else {
                        process.nextTick(promise.resolve, { reader: reader, atr: status.atr, protocol: proto });
                    }
                });
            }
        });
    });

    pcsc.on("error", function (err) {
        fluid.log("PCSC error", err);
    });

    teardowns.push(function () {
        pcsc.close();
    });

    return promise;
};

// Tests connectToCard and readNDEF (and the lower level functions) using a real card.
jqUnit.asyncTest("Card connect and read", function () {

    jqUnit.expect(2);
    var pcsc = gpii.tests.card.getPCSCLite();

    var timeout = setTimeout(jqUnit.fail, 5000, "timed out waiting for card");
    teardowns.push(function () {
        clearTimeout(timeout);
    });

    // Connect to it.
    gpii.tests.card.connectToCard(pcsc).then(function (result) {
        var atr = result.atr,
            reader = result.reader;

        fluid.log("ATR", atr.toString("hex"));

        jqUnit.assert("connected to card");

        // See if the card is one of the known ones.
        var cardType = gpii.userListeners.pcsc.detectCard(atr);

        jqUnit.assertNotNull("card should be a known type", card);

        if (!cardType) {
            // Best not to perform any more tests if it's an unknown card.
            fluid.log(fluid.logLevel.FATAL, "Not continuing with an unknown card.");
            process.exit(1);
            return;
        }

        fluid.log("Card type:", cardType.name);
        var card = Object.assign({
            transmit: function (data, expectedLength, callback) {
                return reader.transmit(data, expectedLength, result.protocol, callback);
            }
        }, cardType);

        gpii.userListeners.pcsc.readNDEF(card).then(function (ndef) {
            fluid.log("NDEF: ", ndef.toString("hex"));
            fluid.log("TAG: ", gpii.userListeners.decodeNDEF(ndef));
            jqUnit.start();
        }, function (err) {
            jqUnit.fail(err);
        }).then(function () {
            reader.disconnect(fluid.identity);
        });

    });
});

// Tests the user listener with a real card.
jqUnit.asyncTest("Card user listener", function () {
    jqUnit.expect(3);
    var listener = gpii.tests.card.getPcscListener();

    listener.events.onTokenArrive.addListener(function (that, token) {
        jqUnit.assert("got token");
        jqUnit.assertEquals("that", listener, that);
        jqUnit.assertNotNull("token", token);
        jqUnit.start();
    });

    gpii.userListeners.pcsc.startListener(listener);
});

