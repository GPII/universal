/*
 * Generates transaction logs from a real card.
 * This uses a real card, and isn't invoked by CI.
 *
 * Copyright 2017 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";
var fluid = require("infusion");
var gpii = fluid.registerNamespace("gpii");
fluid.registerNamespace("gpii.tests.card");

require("../../index.js");
var Pcsclite = require("@pokusew/pcsclite");

fluid.setLogLevel(fluid.logLevel.INFO);

var pcsc = new Pcsclite();

gpii.tests.card.connectToCard = function () {
    var promise = fluid.promise();

    pcsc.on("reader", function (reader) {
        fluid.log("Got card reader", reader.name);

        reader.on("status", function (status) {
            var action = gpii.userListeners.pcsc.getCardAction(reader.state, status.state);
            if (action === "presented" && !promise.disposition) {
                reader.connect({share_mode: reader.SCARD_SHARE_SHARED}, function (err, proto) {
                    if (err) {
                        promise.reject(err);
                    } else {
                        process.nextTick(promise.resolve, { reader: reader, atr: status.atr, protocol: proto });
                    }
                });
            }
        });
    });

    pcsc.on("error", function (err) {
        fluid.log("PCSC error", err);
    });

    return promise;
};

// Connect to the card.
gpii.tests.card.connectToCard().then(function (result) {
    var atr = result.atr,
        reader = result.reader;

    fluid.log("connected to card");

    // See if the card is one of the known ones.
    var cardType = gpii.userListeners.pcsc.detectCard(atr);

    var log = {
        atr: atr,
        cardType: cardType.name,
        commands: {}
    };

    var card = Object.assign({
        transmit: function (data, expectedLength, callback) {
            return reader.transmit(data, expectedLength, result.protocol, function (err, response) {
                log.commands[data.toString("hex")] = response;
                callback(err, response);
            });
        }
    }, cardType);

    gpii.userListeners.pcsc.readNDEF(card).then(function (tagBuffer) {
        var text = gpii.userListeners.decodeNDEF(tagBuffer);

        log.expect = {
            //ndef: tagBuffer,
            text: text
        };
        var json = JSON.stringify(log, function (key, value) {
            if (value && value.type === "Buffer") {
                return fluid.transform(value.data, function (value) {
                    return (value <= 0xf ? "0" : "") + value.toString(16);
                }).join("");
            } else {
                return value;
            }
        }, "  ");

        fluid.log("Transaction log:\n", json);

    }, function (err) {
        fluid.fail(err);

    }).then(function () {
        reader.disconnect(fluid.identity);
        pcsc.close();
        process.exit();
    });
});
