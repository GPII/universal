/*
 * PCSC User listener tests
 *
 * Copyright 2017 Raising the Floor - International
 * Copyright 2019 OCAD University
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";
var fluid = require("infusion");

var jqUnit = fluid.require("node-jqunit");
var gpii = fluid.registerNamespace("gpii");
fluid.registerNamespace("gpii.tests.userListener");

require("../index.js");
require("./shared/lifecycleManagerTestGrade.js");

jqUnit.module("gpii.tests.userListener.pcsc");

require("json5/lib/register");

gpii.tests.userListener.detectCardTest = require("./testData/detectCard.json5");
gpii.tests.userListener.cardStateTests = require("./testData/cardStates.json5");
gpii.tests.userListener.APDUtests = require("./testData/apdu.json5");
gpii.tests.userListener.cardTests = require("./testData/cards.json5");

jqUnit.test("PC/SC listener - Detect card", function () {

    var index = 0;
    fluid.each(gpii.tests.userListener.detectCardTest, function (test) {
        var messageSuffix = " - index=" + index++;

        var atrBuffer = Buffer.from(test.atr.replace(/\s+/g, ""), "hex");

        var result = gpii.userListeners.pcsc.detectCard(atrBuffer);

        if (test.expect === null) {
            jqUnit.assertNull("card should not be detected" + messageSuffix, result);
        } else {
            jqUnit.assertNotNull("card should be detected" + messageSuffix, result);
            jqUnit.assertEquals("card should be correctly detected" + messageSuffix, test.expect, result.name);
        }
    });
});

jqUnit.test("PC/SC listener - getCardAction", function () {

    var states = {
        SCARD_STATE_EMPTY: gpii.userListeners.pcsc.SCARD_STATE_EMPTY,
        SCARD_STATE_PRESENT: gpii.userListeners.pcsc.SCARD_STATE_PRESENT
    };

    var resolveState = function (value) {
        return states.hasOwnProperty(value) ? states[value] : value;
    };

    var index = 0;
    fluid.each(gpii.tests.userListener.cardStateTests, function (test) {
        var old = resolveState(test.old);
        var current = resolveState(test.current);
        var result = gpii.userListeners.pcsc.getCardAction(old, current);
        jqUnit.assertEquals("getCardAction should return the expected action - index " + index++, test.expect, result);
    });
});

jqUnit.test("PC/SC listener - sendAPDU", function () {

    var messageSuffix;
    var index = 0;

    fluid.each(gpii.tests.userListener.APDUtests, function (test) {
        messageSuffix = " - index " + index++;
        if (test.apdu && test.apdu.text) {
            messageSuffix += ": " + test.apdu.text;
        }

        // Check the correct data is sent to the card.
        var card = {
            transmit: function (data, responseLength, callback) {
                jqUnit.assertTrue("data is a Buffer" + messageSuffix, data instanceof Buffer);
                var dataString = data.toString("hex");
                jqUnit.assertEquals("data must match expected" + messageSuffix, test.expect.data, dataString);

                jqUnit.assertEquals("responseLength matches expected (+ 2 byte status)" + messageSuffix,
                    test.expect.responseLength + 2, responseLength);

                jqUnit.assertTrue("callback must be a function" + messageSuffix, callback instanceof Function);

                callback(test.error, Buffer.from(test.responseData, "hex"));
            }
        };

        var promise = gpii.userListeners.pcsc.sendAPDU(card, test.apdu);

        jqUnit.assertTrue("sendAPDU must return a promise" + messageSuffix, fluid.isPromise(promise));

        // Check how it resolves
        promise.then(function (responseData) {
            jqUnit.assertFalse("must only resolve on non-error" + messageSuffix, test.expect.error);

            var responseString = responseData.toString("hex");
            jqUnit.assertEquals("responseData must match expected" + messageSuffix,
                test.expect.responseData, responseString);

        }, function () {
            jqUnit.assertTrue("must only reject on error" + messageSuffix, test.expect.error);
        });
    });

});

fluid.defaults("gpii.test.userListeners.pcsc", {
    gradeNames: ["gpii.userListeners.pcsc"],
    invokers: {
        getPCSCLite: "fluid.identity",
        startListener: "fluid.identity"
    },
    components: {
        lifecycleManager: {
            type: "gpii.tests.userListener.lifecycleManager"
        }
    }
});

/**
 * Creates a card reader that emulates a real reader, by returning a canned response to commands.
 *
 * @param {Object} options - Options.
 * @param {Function} options.onDisconnect - The callback.
 * @return {CardReader} The card reader.
 */
gpii.tests.userListener.mockReader = function (options) {
    options = Object.assign({}, options);

    var EventEmitter = require("events");
    var reader = new EventEmitter();

    reader.name = "Mock reader";
    reader.state = gpii.userListeners.pcsc.SCARD_STATE_EMPTY;

    // Send a command.
    reader.transmit = function (data, responseLength, protocol, callback) {
        if (reader.commands.fail) {
            reader.testFail();
            return;
        }
        var dataString = data.toString("hex");
        // Return 6300 (a general failure response) if the command isn't recognised.
        var response = reader.commands[dataString] || Buffer.from([0x63, 0x00]);
        process.nextTick(callback, null, response);
    };

    // Connect to the card.
    reader.connect = function (options, callback) {
        process.nextTick(callback, null, "T1");
    };

    reader.disconnect = function (callback) {
        options.onDisconnect && options.onDisconnect();
        callback && callback();
    };

    // Simulate an error.
    reader.testFail = function () {
        reader.emit("error", {message: "test failure"});
    };

    // Pretend a card has been presented.
    reader.setCard = function (atr, commands) {
        if (commands.fail) {
            if (commands.fail === "presented") {
                reader.testFail();
                return;
            }
            reader.commands = commands;
        } else {
            reader.commands = {};
            fluid.each(commands, function (response, command) {
                reader.commands[command] = Buffer.from(response, "hex");
            });
        }
        reader.state = gpii.userListeners.pcsc.SCARD_STATE_EMPTY;

        reader.emit("status", {
            state: gpii.userListeners.pcsc.SCARD_STATE_PRESENT,
            atr: Buffer.from(atr, "hex")
        });
        reader.state = gpii.userListeners.pcsc.SCARD_STATE_PRESENT;
    };

    // Remove the card.
    reader.removeCard = function () {
        reader.emit("status", {
            state: gpii.userListeners.pcsc.SCARD_STATE_EMPTY,
            atr: null
        });
    };

    return reader;
};

// Test the user listener, with a mock card.
jqUnit.asyncTest("PC/SC listener - mock card", function () {

    jqUnit.expect(gpii.tests.userListener.cardTests.length * 3 + 20);
    var index = 0;

    var listener = gpii.test.userListeners.pcsc();
    var reader;

    var messageSuffix;
    var currentTest;
    var testIndex = -1;
    var disconnected = false;

    var nextTest = function () {
        if (currentTest) {
            if (!disconnected) {
                fluid.fail("onDisconnect wasn't fired");
            }
        }
        disconnected = false;

        testIndex++;
        if (testIndex >= gpii.tests.userListener.cardTests.length) {
            jqUnit.start();
        } else {
            currentTest = gpii.tests.userListener.cardTests[testIndex];
            messageSuffix = " - test: " + currentTest.test + ", index " + index++;
            reader.setCard(currentTest.atr, currentTest.commands);
        }
    };

    listener.events.onCardRejected.addListener(function () {
        jqUnit.assertNotEquals("listener trigger should only fire onCardRejected when a card is presented"
            + messageSuffix, -1, testIndex);

        jqUnit.assertNull("cards with a token should succeed" + messageSuffix, currentTest.expect.text);

        jqUnit.assert("balance the numbers for jqUnit.expect");
        nextTest();
    });
    listener.events.onTokenArrive.addListener(function (that, token) {
        jqUnit.assertNotEquals("listener trigger should only fire onTokenArrive when a card is presented"
            + messageSuffix, -1, testIndex);

        jqUnit.assertNotNull("cards with no token should not succeed" + messageSuffix, currentTest.expect.text);
        jqUnit.assertEquals("token should match expected" + messageSuffix, currentTest.expect.text, token);
        nextTest();
    });
    listener.events.onFail.addListener(function (that, err) {
        jqUnit.assertTrue("listener should only fail when expected", !!currentTest.expect.fail);
        jqUnit.assertEquals("listener should only fail with the expected error", "test failure", err.message);

        jqUnit.assert("balance the numbers for jqUnit.expect");

        // onDisconnect will not have been called.
        disconnected = true;

        setTimeout(nextTest, 500);
    });

    reader = gpii.tests.userListener.mockReader({
        onDisconnect: function () {
            disconnected = true;
        }
    });

    listener.monitorReader(reader);
    listener.options.failDelay = 0;

    reader.removeCard();

    nextTest();
});
