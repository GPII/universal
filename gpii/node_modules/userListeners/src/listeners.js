/* User listeners
 *
 * Copyright 2017 Raising the Floor - International
 * Copyright 2019 OCAD University
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion"),
    request = require("request"),
    fs = require("fs"),
    path = require("path");

var gpii = fluid.registerNamespace("gpii");

require("../../lifecycleManager/");

fluid.registerNamespace("gpii.userListeners");

// The user listeners.
fluid.defaults("gpii.userListeners", {
    gradeNames: ["fluid.component", "fluid.contextAware"],
    contextAwareness: {
        platform: {
            checks: {
                windows: {
                    contextValue: "{gpii.contexts.windows}",
                    gradeNames: ["gpii.userListeners.windows"]
                }
            }
        }
    },
    components: {
        pcsc: {
            type: "gpii.userListeners.pcsc",
            options: {
                events: {
                    onListenersStart: "{userListeners}.events.onListenersStart",
                    onListenersStop: "{userListeners}.events.onListenersStop"
                }
            }
        },
        usb: {
            type: "gpii.userListeners.usb",
            options: {
                events: {
                    onListenersStart: "{userListeners}.events.onListenersStart",
                    onListenersStop: "{userListeners}.events.onListenersStop"
                }
            }
        },
        userFolder: {
            type: "gpii.userListeners.userFolder",
            options: {
                events: {
                    onListenersStart: "{userListeners}.events.onListenersStart",
                    onListenersStop: "{userListeners}.events.onListenersStop"
                }
            }
        }
    },
    events: {
        // The listeners are starting.
        "onListenersStart": null,
        // The listeners are stopping.
        "onListenersStop": null
    },
    listeners: {
        "onCreate.startListeners": "{that}.events.onListenersStart"
    }
});

// A user listener.
fluid.defaults("gpii.userListener", {
    gradeNames: ["fluid.component"],
    components: {
        lifecycleManager: {
            type: "gpii.lifecycleManager"
        }
    },
    events: {
        onListenersStart: null,
        onListenersStop: null,

        // A token has arrived.
        "onTokenArrive": null,
        // A token has removed.
        "onTokenRemove": null,
        // The listener has failed.
        "onFail": null
    },
    invokers: {
        // Start the listener, returning a Promise
        startListener: "fluid.notImplemented",
        // Stop the listener, returning a Promise
        stopListener: "fluid.notImplemented",
        // Parse a Buffer containing an NDEF message, returning a string.
        decodeNDEF: {
            funcName: "gpii.userListeners.decodeNDEF",
            args: [
                "{arguments}.0" // NDEF buffer
            ]
        },
        // The listener has failed, and should be restarted.
        failed: {
            funcName: "gpii.userListeners.failed",
            args: [
                "{that}",
                "{arguments}.0" // The error.
            ]
        },
        readTokenFile: {
            funcName: "gpii.userListeners.readTokenFile",
            args: [ "{arguments}.0", "{arguments}.1" ] // directory, file
        },
        writeTokenFile: {
            funcName: "gpii.userListeners.writeTokenFile",
            args: [ "{arguments}.0", "{arguments}.1", "{arguments}.2" ] // directory, file, token
        }
    },
    members: {
        // Set to true to call proximityTriggered, otherwise login/logout.
        proximity: false,
        // Indicates that the logins by this listener are environmental logons (such as auto-logons) [GPII-3988]
        environmental: false,
        // Override to provide the name of the listener.
        listenerName: "no-name",
        // Number of failures
        failCount: 0
    },
    listeners: {
        // Start/stop this listener
        "onListenersStart.startListener":  "{that}.startListener",
        "onListenersStop.stopListener": "{that}.stopListener",

        "onTokenArrive.callFlowManager": {
            funcName: "gpii.userListeners.tokenArrived",
            args: [
                "{that}",
                "{arguments}.1" // token
            ]
        },
        "onTokenRemove.callFlowManager": {
            funcName: "gpii.userListeners.tokenRemoved",
            args: [
                "{that}",
                "{arguments}.1" // token
            ]
        }
    },

    // Seconds (multiplied by failureCount) to wait before restarting.
    failDelay: 10
});

/**
 * Handles the onTokenArrive event.
 *
 * It calls the "login" action for non-proximity devices, otherwise "proximityTriggered".
 *
 * @param {Component} that - An instance of gpii.userListener.
 * @param {String} token - The token from the user listener.
 * @param {Object} loginInfo - [optional] Extra login information
 */
gpii.userListeners.tokenArrived = function (that, token) {
    fluid.log(that.listenerName + " token arrived: " + token);
    var loginInfo = {
        isEnvironmentalLogin: that.environmental
    };
    if (that.environmental && that.proximity) {
        // proximity listeners are for momentary triggers, which isn't compatible with an environmental state.
        fluid.fail("A listener can not be both 'environmental' and 'proximity'");
    } else {
        that.lifecycleManager[that.proximity ? "performProximityTriggered" : "performLogin"](token, loginInfo);
    }
};

/**
 * Handles the onTokenRemove event.
 *
 * It calls the "logout" action for non-proximity devices, otherwise it does nothing.
 *
 * @param {Component} that - An instance of gpii.userListener.
 * @param {String} token - The token from the user listener.
 */
gpii.userListeners.tokenRemoved = function (that, token) {
    fluid.log(that.listenerName + " token removed: " + token);

    if (!that.proximity) {
        // Temporary workaround for GPII-3769
        setTimeout(function () {
            that.lifecycleManager.performLogout(token);
        }, 0);
    }
};

/**
 * The listener has failed, and needs to be restarted. To avoid fast repeating failures, the restart will have a delay
 * which increases each time.
 *
 * @param {Component} that - An instance of gpii.userListener.
 * @param {Any} err - The error.
 */
gpii.userListeners.failed = function (that, err) {
    var delay = Math.min(that.failCount++, 10) * that.options.failDelay;

    fluid.log(fluid.logLevel.WARN,
        "Listener " + that.listenerName + " has failed. Restarting in " + delay + " seconds");

    that.events.onFail.fire(that, err);

    process.nextTick(function () {
        that.stopListener().then(function () {
            setTimeout(function () {
                fluid.log("Restarting " + that.listenerName + " listener");
                that.startListener();
            }, delay * 1000);
        });
    });
};

/**
 * Reads a token from the file.
 *
 * @param {String} tokenDirectory - The directory containing the token file.
 * @param {String} tokenFile [optional] The file, in tokenDirectory, containing the token. Can be omitted if the first
 *   argument is the full path to the file.
 * @return {Promise} resolves when the token is read, rejects if there's no file (or there was an error reading it).
 */
gpii.userListeners.readTokenFile = function (tokenDirectory, tokenFile) {
    var promise = fluid.promise();

    // Try to read the token file.
    var tokenPath = path.join(tokenDirectory, tokenFile || "");
    fluid.log("Reading token file: ", tokenPath);
    fs.readFile(tokenPath, "utf8", function (err, data) {
        if (err) {
            if (err.code === "ENOENT") {
                fluid.log("Token file not found");
                promise.reject();
            } else {
                var message = "Error reading token file " + tokenPath + ": " + err.message;
                fluid.log(message);
                promise.reject({
                    isError: true,
                    message: message,
                    error: err
                });
            }
        } else {
            var token = data.trim();
            if (token.length > 0) {
                fluid.log("Got token: ", token);
                promise.resolve(token);
            } else {
                fluid.log("Empty token file");
                promise.reject();
            }
        }
    });

    return promise;
};

/**
 * Writes a token to a file.
 *
 * @param {String} tokenDirectory - The directory containing the token file.
 * @param {String} tokenFile [optional] The file, in tokenDirectory, containing the token. Can be omitted if the first
 *   argument is the full path to the file.
 * @param {String} tokenValue - The token's value.
 * @return {Promise} resolves when complete, with a value of true if it was written.
 */
gpii.userListeners.writeTokenFile = function (tokenDirectory, tokenFile, tokenValue) {
    var promise = fluid.promise();

    var tokenPath = path.join(tokenDirectory, tokenFile || "");
    fluid.log("Writing token '" + tokenValue + "' to ", tokenPath);

    fs.writeFile(tokenPath, tokenValue, "utf8", function (err) {
        if (err) {
            var message = "Error writing token file " + tokenPath + ": " + err.message;
            fluid.log(message);
            promise.reject({
                isError: true,
                message: message,
                error: err
            });
        } else {
            promise.resolve(true);
        }
    });

    return promise;
};
