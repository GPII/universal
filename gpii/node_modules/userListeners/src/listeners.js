/* User listeners
 *
 * Copyright 2017 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion"),
    request = require("request");

var gpii = fluid.registerNamespace("gpii");

fluid.registerNamespace("gpii.userListeners");

// The user listeners.
fluid.defaults("gpii.userListeners", {
    gradeNames: ["fluid.component", "fluid.contextAware"],
    contextAwareness: {
        platform: {
            checks: {
                windows: {
                    contextValue: "{gpii.contexts.windows}",
                    gradeNames: ["gpii.userListeners.windows"]
                }
            }
        }
    },
    components: {
        pcsc: {
            type: "gpii.userListeners.pcsc"
        },
        usb: {
            type: "gpii.userListeners.usb"
        }
    },
    events: {
        // The listeners are starting.
        "onListenersStart": null,
        // The listeners are stopping.
        "onListenersStop": null
    },
    listeners: {
        "onCreate.startListeners": "{that}.events.onListenersStart"
    }
});

// A user listener.
// Listeners can have either "momentary", "maintained", or "hybrid" gesture modes:
// - Momentary: token is presented to key-in, then presented again to key-out, like a caps-lock key. (momentary = true)
// - Maintained: token is presented to key-in, then removed to key-out, like the shift key. (momentary = false)
// - Hybrid mode detects what the user is trying to do, based on how soon the token is removed. (detectMode = true)
fluid.defaults("gpii.userListener", {
    gradeNames: ["fluid.component"],
    events: {
        // A token has arrived.
        "onTokenArrive": null,
        // A token has removed.
        "onTokenRemove": null,
        // The listener has failed.
        "onFail": null
    },
    invokers: {
        // Start the listener, returning a Promise
        startListener: "fluid.notImplemented",
        // Stop the listener, returning a Promise
        stopListener: "fluid.notImplemented",
        // Parse a Buffer containing an NDEF message, returning a string.
        decodeNDEF: {
            funcName: "gpii.userListeners.decodeNDEF",
            args: [
                "{arguments}.0" // NDEF buffer
            ]
        },
        // The listener has failed, and should be restarted.
        failed: {
            funcName: "gpii.userListeners.failed",
            args: [
                "{that}",
                "{arguments}.0" // The error.
            ]
        },
        callFlowManager: {
            funcName: "gpii.userListeners.callFlowManager",
            args: [
                "{that}",
                "{arguments}.0", // Token.
                "{arguments}.1"  // Action ("login", "logout", or "proximityTriggered").
            ]
        }
    },
    members: {
        // True to auto-detect momentary or maintained key token usage, based on how soon it was removed. Otherwise,
        // use {that}.momentary.
        detectMode: true,
        // Set to true to call proximityTriggered, otherwise login/logout (ignored if that.detectMode is true).
        momentary: false,
        // Override to provide the name of the listener.
        listenerName: "no-name",
        // Number of failures
        failCount: 0
    },
    listeners: {
        // Start/stop this listener
        "{userListeners}.events.onListenersStart":  "{that}.startListener",
        "{userListeners}.events.onListenersStop": "{that}.stopListener",

        "onTokenArrive.callFlowManager": {
            funcName: "gpii.userListeners.tokenArrived",
            args: [
                "{that}",
                "{arguments}.1" // token
            ]
        },
        "onTokenRemove.callFlowManager": {
            funcName: "gpii.userListeners.tokenRemoved",
            args: [
                "{that}",
                "{arguments}.1" // token
            ]
        }
    },

    // Seconds (multiplied by failureCount) to wait before restarting.
    failDelay: 10,
    // If the token is removed before the timeout (seconds), then "momentary mode" is used. Otherwise, "maintained mode"
    // is used.
    detectModeTimeout: 4
});

gpii.userListeners.state = {};
/**
 * Handles the onTokenArrive event.
 *
 * It calls the "login" action for maintained key tokens, "proximityTriggered" for momentary.
 *
 * @param that {Component} An instance of gpii.userListener.
 * @param token {string} The token from the user listener.
 */
gpii.userListeners.tokenArrived = function (that, token) {
    fluid.log(that.listenerName + " token arrived: " + token);

    var momentary = that.momentary;

    if (that.detectMode) {
        if (gpii.userListeners.state.momentaryDetected) {
            // A token has previously been presented (and quickly removed).
            momentary = true;
        }

        gpii.userListeners.state.arrivalTime = process.hrtime();
        delete gpii.userListeners.state.momentaryDetected;
    }

    that.callFlowManager(token, momentary ? "proximityTriggered" : "login");
};

/**
 * Handles the onTokenRemove event.
 *
 * It calls the "logout" action for maintained key tokens, "proximityTriggered" for momentary.
 *
 * @param that {Component} An instance of gpii.userListener.
 * @param token {string} The token from the user listener.
 */
gpii.userListeners.tokenRemoved = function (that, token) {
    fluid.log(that.listenerName + " token removed: " + token);

    var momentary = that.momentary;

    if (that.detectMode) {
        // If the token was removed before the timeout, then ignore the removal (key-out will be performed when the next
        // token is presented).
        var time = process.hrtime(gpii.userListeners.state.arrivalTime)[0];
        gpii.userListeners.state.momentaryDetected = time < that.options.detectModeTimeout;
        momentary = gpii.userListeners.state.momentaryDetected;
        delete gpii.userListeners.state.arrivalTime;
    }

    // Don't logout for momentary
    if (!momentary) {
        that.callFlowManager(token, "logout");
    }
};

/**
 * Calls the flow manager with the user token and action.
 *
 * @param that {Component} An instance of gpii.userListener.
 * @param token {string} The token from the user listener.
 * @param action {String} Action to invoke ("login", "logout", or "proximityTriggered").
 */
gpii.userListeners.callFlowManager = function (that, token, action) {
    fluid.log("userListener: sending " + token + "/" + action);
    request("http://localhost:8081/user/" + token + "/" + action, function (error, response, body) {
        fluid.log("userListener: received " + body);
        if (!error && action === "login") {
            var result = JSON.parse(body);
            // If a login failed due to already being logged in, send proximityTriggered to cause a log out+in.
            // This occurs when trying to login while already logged in via another listener device (and user listeners
            // aren't to keep the "logged in" state).
            if (result.isError && result.message && result.message.indexOf("already logged in") > 0) {
                gpii.userListeners.callFlowManager(that,  token,  "proximityTriggered");
            }
        }
    });
};

/**
 * The listener has failed, and needs to be restarted. To avoid fast repeating failures, the restart will have a delay
 * which increases each time.
 *
 * @param that {Component} An instance of gpii.userListener.
 * @param that {Error} The error.
 */
gpii.userListeners.failed = function (that, err) {
    var delay = Math.min(that.failCount++, 10) * that.options.failDelay;

    fluid.log(fluid.logLevel.WARN,
        "Listener " + that.listenerName + " has failed. Restarting in " + delay + " seconds");

    that.events.onFail.fire(that, err);

    process.nextTick(function () {
        that.stopListener().then(function () {
            setTimeout(function () {
                fluid.log("Restarting " + that.listenerName + " listener");
                that.startListener();
            }, delay * 1000);
        });
    });
};
