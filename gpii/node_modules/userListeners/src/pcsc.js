/* PC/SC user listener.
 *
 * Copyright 2017 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

/**
 * The cards supported are NTAG-203/213/216, Mifare Ultralight, and Mifare classic 1k/4k
 *
 * References:
 * [ACR-API] "ACR1251U-A1 Application Programming Interface V1.08",
 *   The spec used for the card commands (the official NXP specs are NDA classified).
 *   https://www.acs.com.hk/download-manual/4414/API-ACR1251U-1.08.pdf
 *
 * Mifare classic card memory layout:
 *
 * [                         card                                                       ...]
 * [  sector 0  ][             sector 1             ][         sector 2                   ] ...
 * [  reserved  ][block 4][block 5][block 6][block 7][block 8][block 9][block 10][block 11] ...
 *               [ NDEF TLV Tag         ...]reserved [... NDEF tag       ]       [reserved]
 *               [ NDEF Records                                              ...]
 *               [ NDEF Record 1                                     ][Rec 2 ...]
 *               [header][ GPII Token                                ][other ...]
 *
 * Blocks are 16 bytes, the last block of each sector is reserved.
 *
 * NTAG memory is roughly the same, but no trailer block. Blocks (called pages) are only 4 bytes.
 *
 */

var fluid = require("infusion"),
    ndef = require("ndef");

var gpii = fluid.registerNamespace("gpii");

// The PCSC user listener.
fluid.defaults("gpii.userListeners.pcsc", {
    gradeNames: ["fluid.component", "fluid.contextAware", "gpii.userListener"],
    contextAwareness: {
        platform: {
            checks: {
                // The PC/SC is an OS specific library, so these mixins are used to perform the actual loading.
                windows: {
                    contextValue: "{gpii.contexts.windows}",
                    gradeNames: "gpii.userListeners.pcsc.windows"
                },
                linux: {
                    contextValue: "{gpii.contexts.linux}",
                    gradeNames: "gpii.userListeners.pcsc.linux"
                }
            }
        }
    },
    events: {
        // A card is presented that doesn't have a tag (or some other problem).
        onCardRejected: null
    },
    members: {
        currentToken: null,
        active: false
    },
    invokers: {
        startListener: {
            funcName: "gpii.userListeners.pcsc.startListener",
            args: ["{that}"]
        },
        stopListener: {
            funcName: "gpii.userListeners.pcsc.stopListener",
            args: ["{that}"]
        },
        getPCSCLite: "fluid.identity",
        monitorReader: {
            funcName: "gpii.userListeners.pcsc.monitorReader",
            args: ["{that}", "{arguments}.0"]
        }
    }
});

// https://pcsclite.alioth.debian.org/api/pcsclite_8h.html
gpii.userListeners.pcsc.SCARD_STATE_EMPTY = 0x0010;
gpii.userListeners.pcsc.SCARD_STATE_PRESENT  = 0x0020;
gpii.userListeners.pcsc.SCARD_SHARE_SHARED  = 0x0002;

/**
 * Recognised cards and their characteristics.
 * @typedef {Object} Card
 */
gpii.userListeners.pcsc.knownCards = [
    {
        name: "Mifare",
        atr: [
            // Mifare 1k
            "3B 8F 80 01 80 4F 0C A0 00 00 03 06 03 00 01 00 00 00 00 6A",
            // Mifare 4k
            "3B 8F 80 01 80 4F 0C A0 00 00 03 06 03 00 02 00 00 00 00 69"
        ],
        startBlock: 4, // first sector (4 blocks) is reserved.
        blockLength: 16,
        skipBlocks: 3, // bit mask. Every 4th block is ignored (The trailer block of a sector).
        authenticate: true
    },
    {
        // NTAG 203/213/216, Mifare ultralight
        name: "NTAG",
        atr: "3B 8F 80 01 80 4F 0C A0 00 00 03 06 03 00 03 00 00 00 00 68",
        startBlock: 4,
        blockLength: 4,
        skipBlocks: 0,
        authenticate: false
    }
];

// Convert the ATR strings into buffers.
fluid.each(gpii.userListeners.pcsc.knownCards, function (card) {
    card.atrs = [];
    fluid.each(fluid.makeArray(card.atr), function (atr) {
        card.atrs.push(Buffer.from(atr.replace(/\s+/g, ""), "hex"));
    });
});

/**
 * Start the user listener.
 *
 * @param that {Component} The gpii.userListeners.pcsc instance.
 * @return {Promise} A resolved promise if it succeeds.
 */
gpii.userListeners.pcsc.startListener = function (that) {

    var promise = fluid.promise();

    that.active = true;
    if (!that.pcsclite) {
        that.pcsclite = that.getPCSCLite();

        if (that.pcsclite) {
            that.pcsclite.on("reader", function (reader) {
                that.monitorReader(reader);
            });
            that.pcsclite.on("error", function (err) {
                fluid.log(fluid.logLevel.ERROR, "PCSC error", err);
                that.failed(err);
            });
            promise.resolve();
        } else {
            fluid.log(fluid.logLevel.WARN, "PC/SC user listener is not available.");
            promise.reject({
                isError: true,
                message: "PC/SC user listener is not available."
            });
        }
    }
    return promise;
};

/**
 * Stop the user listener
 *
 * @param that {Component} The gpii.userListeners.pcsc instance.
 * @returns {Promise} Resolved with a value of true if the listener was stopped, false if it wasn't running.
 */
gpii.userListeners.pcsc.stopListener = function (that) {
    var promise = fluid.promise();
    var value = false;
    if (that.pcsclite) {
        that.pcsclite.close();
        that.pcsclite = null;
        value = true;
    }
    that.active = false;
    promise.resolve(value);
    return promise;
};

/**
 * Monitors a card reader. When a card is presented to the reader, read it and raise the onTokenArrive event when
 * a token is found.
 *
 * @param that {Component} The gpii.userListeners.pcsc instance.
 * @param reader {CardReader} The reader.
 */
gpii.userListeners.pcsc.monitorReader = function (that, reader) {
    fluid.log("Got card reader: ", reader.name);

    reader.on("status", function (status) {
        var action = gpii.userListeners.pcsc.getCardAction(reader.state, status.state);
        if (action === "presented") {
            // Get the data from it.
            gpii.userListeners.pcsc.readCard(that, reader, status.atr).then(function (tag) {
                that.currentToken = tag;
                that.events.onTokenArrive.fire(that, that.currentToken);
            }, function (err) {
                fluid.log(err);
                that.events.onCardRejected.fire(that);
            });
        } else if (action === "removed") {
            if (that.currentToken) {
                that.events.onTokenRemove.fire(that, that.currentToken);
                that.currentToken = null;
            }
        }
    });

    reader.on("end", function () {
        fluid.log("Lost card reader: ", reader.name);
    });
    reader.on("error", function (e) {
        // The device has gone, or is in an unknown state - restart the user listener.
        fluid.log("Card reader error (" + reader.name + "): ", e.message);
        that.failed(e);
    });
};

/**
 * Get the card action, based on the state change.
 *
 * @param oldState {number} Bit-mask of the old state.
 * @param newState {number} Bit-mask of the new state.
 * @return {string} Action of the card: "presented", "removed", or "unchanged".
 */
gpii.userListeners.pcsc.getCardAction = function (oldState, newState) {

    // Get the states that have changed to on.
    var newStates = (oldState ^ newState) & newState;
    var action;
    if (newStates & gpii.userListeners.pcsc.SCARD_STATE_EMPTY) {
        // The "empty" bit has been set.
        action = "removed";
    } else if (newStates & gpii.userListeners.pcsc.SCARD_STATE_PRESENT) {
        // The "present" bit has been set.
        action = "presented";
    } else {
        action = "unchanged";
    }
    return action;
};

/**
 * Detect a card based on the ATR (Answer to reset), returning the appropriate member of knownCards.
 *
 * (contact-less cards don't actually have an ATR; it's emulated by the reader)
 *
 * @param atr {Buffer} The card's ATR.
 * @return {Object} Item from gpii.userListeners.pcsc.knownCards, or null if unrecognised.
 */
gpii.userListeners.pcsc.detectCard = function (atr) {
    if (!atr instanceof Buffer) {
        fluid.fail("atr needs to be a Buffer.");
    }

    var knownCards = gpii.userListeners.pcsc.knownCards;

    var card = fluid.find(knownCards, function (card) {
        return fluid.find(card.atrs, function (atrTest) {
            return atrTest.equals(atr) ? card : undefined;
        });
    });

    return card || null;
};

/**
 * Reads a card for the NDEF message. Resolves with the first text record from the first NDEF text message.
 *
 * @param that {Component} The gpii.userListeners.pcsc instance.
 * @param reader {CardReader} The card reader.
 * @param atr {Buffer} The card's ATR.
 * @return {Promise} Resolves with the NDEF message text.
 */
gpii.userListeners.pcsc.readCard = function (that, reader, atr) {
    var promise = fluid.promise();

    var cardType = gpii.userListeners.pcsc.detectCard(atr);
    if (cardType) {
        gpii.userListeners.pcsc.connectToCard(reader, cardType).then(function (card) {
            gpii.userListeners.pcsc.readNDEF(card).then(function (tagBuffer) {
                var text = that.decodeNDEF(tagBuffer);
                if (text) {
                    promise.resolve(text);
                } else {
                    promise.reject({
                        isError: true,
                        message: "No tag found on card"
                    });
                }
            }, promise.reject);
        }, promise.reject);

        promise.then(function () {
            reader.disconnect(fluid.identity);
        }, function () {
            reader.disconnect(fluid.identity);
        });
    } else {
        promise.reject({
            isError: true,
            message: "Unrecognised card"
        });
    }

    return promise;
};

/**
 * Connect to a card.
 *
 * @param reader {CardReader} The card reader.
 * @param cardType {Object} Card information, from detectCard
 * @return {Promise} Resolves when a connection has been established.
 */
gpii.userListeners.pcsc.connectToCard = function (reader, cardType) {
    var promise = fluid.promise();
    reader.connect({share_mode: reader.SCARD_SHARE_SHARED}, function (err, proto) {
        if (err) {
            promise.reject({
                isError: true,
                message: "Couldn't connect to card",
                error: err
            });
        } else {
            var card = Object.assign({}, cardType);
            card.transmit = function (data, expectedLength, callback) {
                try {
                    reader.transmit(data, expectedLength, proto, callback);
                } catch (e) {
                    callback(e, null);
                }
            };
            promise.resolve(card);
        }
    });

    return promise;
};

/**
 * Sends an APDU to the card, resolving with the response buffer.
 *
 * The status code (last two bytes) is removed from the response, and a status code of not 9000 (success) will reject.
 *
 * See https://en.wikipedia.org/wiki/Smart_card_application_protocol_data_unit
 *
 * @param card {Card}
 * @param apdu {Object} The APDU.
 * @param apdu.cla {byte} Instruction class (CLA)
 * @param apdu.ins {byte} Instruction code (INS)
 * @param apdu.p1 {byte} Parameter 1 (P1)
 * @param apdu.p2 {byte} Parameter 2 (P2)
 * @param apdu.lc {byte} [Optional] Command data length (Lc)
 * @param apdu.data {byte|byte[]} [Optional] Command data
 * @param apdu.le {byte} [Optional] Response length expected (Le)
 * @param apdu.text {string} [Optional] Ignored - used for logging.
 * @param ignoreStatusCode {boolean} true to ignore the status code (don't reject fail, and keep it in the response).
 * @return {Promise} Resolves with the response.
 * @typedef {number} byte
 */
gpii.userListeners.pcsc.sendAPDU = function (card, apdu, ignoreStatusCode) {
    // The order in which the bytes go.
    var order = ["cla", "ins", "p1", "p2", "lc", "data", "le"];
    // The required bytes.
    var required = ["cla", "ins", "p1", "p2"];
    var bytes = [];

    var promise = fluid.promise();

    // Assemble the bytes.
    order.forEach(function (field) {
        var gotValue = apdu.hasOwnProperty(field);
        var value = gotValue && apdu[field];
        if (!gotValue && required.indexOf(field) > -1) {
            // If a required byte is omitted, use zero.
            value = 0x00;
            gotValue = true;
        }

        if (gotValue) {
            // Add the byte to the buffer.
            if (Array.isArray(value)) {
                bytes.push.apply(bytes, value);
            } else {
                bytes.push(value);
            }

        }
    });

    var maxResponseLength = apdu.le || 0;

    var data = Buffer.from(bytes);
    var statusCodeLength = 2;
    var successResponse = 0x9000;

    fluid.log("APDU: ", data.toString("hex").replace(/(..)/g, "$1 "), apdu.text || " ");

    // Send it to the card.
    card.transmit(data, maxResponseLength + statusCodeLength, function (err, buf) {
        if (err) {
            promise.reject({
                isError: true,
                message: "Unable to send command to card",
                error: err
            });
        } else {
            fluid.log("Response: ", buf.toString("hex"));
            if (ignoreStatusCode) {
                promise.resolve(buf);
            } else {
                // Status code is the last 2 bytes (and cards are big endian).
                var statusCode;
                if (buf.length >= statusCodeLength) {
                    statusCode = buf.readUInt16BE(buf.length - statusCodeLength);
                    buf = buf.slice(0, -2);
                }

                if (statusCode === successResponse) {
                    promise.resolve(buf);
                } else {
                    promise.reject({
                        isError: true,
                        message: "Non-successful status code from card: " + (statusCode && statusCode.toString(16)),
                        statusCode: statusCode,
                        response: buf.toString("hex")
                    });
                }
            }
        }
    });

    return promise;
};

/**
 * Load the authentication keys for a particular block.
 *
 * @param card {Card} The card.
 * @param block {number} The block to authenticate.
 * @param keyType {number} Key type: 0x60 (type A) or 0x61 (type B).
 * @param keyNumber {number} Key number: 0 or 1.
 * @return {Promise} Resolves when successfully authenticated, rejects on failure.
 */
gpii.userListeners.pcsc.loadAuthenticationKeys = function (card, block, keyType, keyNumber) {
    // [ACR-API] 5.4.2 Authentication for MIFARE Classic (1K/4K)
    var apdu = {
        text: "Load Authentication Keys (block " + block + ", key " + keyType.toString(16) + ", keyNumber " + keyNumber + ")",
        cla: 0xff,
        ins: 0x86,
        p1: 0x00,
        p2: 0x00,
        lc: 0x05,
        data: [
            0x01, // version: 1
            0x00, // always 0
            block, // block number
            keyType, // key type
            keyNumber // key number
        ]
    };

    return gpii.userListeners.pcsc.sendAPDU(card, apdu);
};

/**
 * Authenticate a block, if required, so it can be read from.
 *
 * @param card {Card} The card.
 * @param block {number} The block to authenticate.
 * @return {Promise} Resolves when it's done.
 */
gpii.userListeners.pcsc.authenticateBlock = function (card, block) {

    var authRequired = false;
    if (card.authenticate) {
        // Mifare: Only need to authenticate once per sector - When a block is authenticated, the other blocks in the
        // sector are also accessible.
        var sectorSize = 4;
        var sector = Math.floor(block / sectorSize);
        card.authed = card.authed || {};
        authRequired = !card.authed[sector];
        card.authed[sector] = true;
    }

    var promise = fluid.promise();
    if (authRequired) {
        // There are two keys (0 and 1), and there are two types of key (TYPE A or B). Try each one until it successful.
        var typeA = 0x60,
            typeB = 0x61;
        var keys = [
            { type: typeA, number: 0 },
            { type: typeB, number: 0 },
            { type: typeA, number: 1 },
            { type: typeB, number: 1 }
        ];

        // Try each key until successful.
        var tryKey = function (keyIndex, attempt) {
            keyIndex = keyIndex % keys.length;
            gpii.userListeners.pcsc.loadAuthenticationKeys(card, block, keys[keyIndex].type, keys[keyIndex].number)
                .then(function () {
                    // Use the same one next time.
                    gpii.userListeners.pcsc.keyIndex = keyIndex;
                    promise.resolve();
                }, function (err) {
                    if (attempt > keys.length) {
                        promise.reject({
                            isError: true,
                            message: "Unable to authenticate block.",
                            error: err
                        });
                    } else {
                        tryKey(keyIndex + 1, attempt + 1);
                    }
                });
        };

        tryKey(gpii.userListeners.pcsc.lastKeyIndex || 0, 0);
    } else {
        promise.resolve();
    }

    return promise;
};

/**
 * Reads the next block from the card.
 *
 * The block is authenticated, and the data is cached.
 *
 * @param card {Card} The card.
 * @return {Promise} Resolves with the data.
 */
gpii.userListeners.pcsc.readNextBlock = function (card) {
    var promise = fluid.promise();

    var block = card.nextBlock || card.startBlock;
    if (card.skipBlocks && (block & card.skipBlocks) === card.skipBlocks) {
        // Ignore the trailer block (Mifare)
        block++;
    }

    card.nextBlock = block + 1;

    if (!card.blockCache) {
        card.blockCache = {};
    }

    if (card.blockCache[block]) {
        promise.resolve(card.blockCache[block]);
    } else {
        // [ACR-API] 5.4.3. Read Binary Blocks
        gpii.userListeners.pcsc.authenticateBlock(card, block).then(function () {
            gpii.userListeners.pcsc.sendAPDU(card, {
                text: "Read block " + block,
                cla: 0xFF,
                ins: 0xB0,
                p1: 0x00,
                p2: block,
                le: card.blockLength
            }).then(function (data) {
                card.blockCache[block] = data;
                promise.resolve(data);
            }, promise.reject);
        }, promise.reject);
    }
    return promise;
};

/**
 * Read some bytes from the card, starting at the start block.
 *
 * @param card {Card} The card.
 * @param length {number} Number of bytes to read.
 * @return {Promise} Resolves with the data.
 */
gpii.userListeners.pcsc.readBytes = function (card, length) {
    var promise = fluid.promise();
    var sequence = [];
    card.nextBlock = card.startBlock;

    for (var bytes = 0, block = 0; bytes < length; bytes += card.blockLength, block++) {
        sequence.push(gpii.userListeners.pcsc.readNextBlock);
    }

    fluid.promise.sequence(sequence, card).then(function (result) {
        var allData = Buffer.concat(result);
        promise.resolve(allData);
    }, promise.reject);

    return promise;
};

/**
 * Get the NDEF tag from a card.
 *
 * @param card {Card}
 */
gpii.userListeners.pcsc.readNDEF = function (card) {
    var promise = fluid.promise();

    gpii.userListeners.pcsc.readBytes(card, 16).then(function (buf) {
        var offset = 0;
        var tagType;

        // Get the first TLV that's an NDEF
        //  Tag:    1 byte (0x03 for NDEF)
        //  Length: 1 byte, or 2 bytes if at least 0xff
        //  Value:  <Length> bytes (the NDEF message)

        var tagLength;
        while (offset <= buf.length - 3) {
            // Skip leading 0's
            do {
                tagType = buf[offset++];
            } while (!tagType && offset < buf.length - 2);

            tagLength = buf[offset++];
            if (tagLength === 0xff) {
                // Length is 2 bytes, 0xff to 0xffff
                tagLength |= (buf[offset++] << 8);
            }

            if (tagType === 0x03) {
                break;
            } else {
                // ignore this tag
                offset += tagLength;
            }
        }

        if (tagType === 0x03) {
            gpii.userListeners.pcsc.readBytes(card, offset + tagLength).then(function (buf) {
                promise.resolve(buf.slice(offset, offset + tagLength));
            }, promise.reject);
        } else {
            promise.resolve(null);
        }

    }, promise.reject);

    return promise;
};

/**
 * Decodes an NDEF message (the tag from a card), returning the value of the first text record.
 *
 * @param tagBuffer
 * @return {string} The text value, or null if none.
 */
gpii.userListeners.decodeNDEF = function (tagBuffer) {
    var text = null;
    if (tagBuffer) {
        // Parse the NDEF buffer.
        var bytes = Array.prototype.slice.call(tagBuffer);
        var records = ndef.decodeMessage(bytes);
        // Get the first text record.
        var textRecord = records.find(function (record) {
            return record.type === ndef.RTD_TEXT;
        });

        if (textRecord) {
            text = textRecord.value;
        }
    }

    return text;
};
