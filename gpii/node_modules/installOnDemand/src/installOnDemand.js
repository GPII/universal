/*
 * Install on Demand.
 *
 * Copyright 2018 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion");

var path = require("path"),
    os = require("os"),
    fs = require("fs");

var gpii = fluid.registerNamespace("gpii");
fluid.registerNamespace("gpii.iod");

require("./packageInstaller.js");

/**
 * The stages of installation:
 * - getInfo: Retrieves the package information (eg download location, installation instructions)
 * - download: Downloads the package.
 * - check: Checks the downloaded package.
 * - prepareInstall: Generates the installation commands.
 * - install: Installs the package.
 * - cleanup: Cleans the files.
 */

fluid.defaults("gpii.iod", {
    gradeNames: ["fluid.component"],
    contextAwareness: {
        platform: {
            checks: {
                windows: {
                    contextValue: "{gpii.contexts.windows}",
                    gradeNames: ["gpii.windows.iod"]
                }
            }
        }
    },
    invokers: {
        requirePackage: {
            funcName: "gpii.iod.requirePackage",
            args: ["{that}", "{arguments}.0"]
        },
        startRemoval: {
            funcName: "gpii.iod.startRemoval",
            args: ["{that}", "{arguments}.0"]
        },
        findInstaller: {
            funcName: "gpii.iod.findInstaller",
            args: ["{that}", "{arguments}.0"]
        },
        getWorkingPath: {
            funcName: "gpii.iod.getWorkingPath",
            args: ["{arguments}.0"]
        },
        // Remaining invokers are part of the installation pipe-line. Each one is passed the installation and returns
        // a installation, either directly or via a promise.
        getPackageInfo: {
            funcName: "gpii.iod.getPackageInfo",
            args: ["{that}", "{arguments}.0"]
        },
        downloadPackage: {
            funcName: "gpii.iod.downloadPackage",
            args: ["{that}", "{arguments}.0"]
        },
        checkPackage: {
            funcName: "gpii.iod.checkPackage",
            args: ["{that}", "{arguments}.0"]
        },
        prepareInstall: {
            funcName: "gpii.iod.prepareInstall",
            args: ["{that}", "{arguments}.0"]
        },
        installPackage: {
            funcName: "gpii.iod.installPackage",
            args: ["{that}", "{arguments}.0"]
        },
        cleanup: {
            funcName: "gpii.iod.cleanup",
            args: ["{that}", "{arguments}.0", "{arguments}.1"]
        },
        uninstallPackage: {
            funcName: "gpii.iod.uninstallPackage",
            args: ["{that}", "{arguments}.0"]
        }
    },
    events: {
        // Dummy events for the installation pipe-lines
        onRequirePackage: null,
        onRemovePackage: null
    },
    listeners: {
        "onRequirePackage.getInfo": {
            func: "{that}.getPackageInfo",
            priority: "first"
        },
        "onRequirePackage.download": {
            func: "{that}.downloadPackage",
            priority: "after:getInfo"
        },
        "onRequirePackage.check": {
            func: "{that}.checkPackage",
            priority: "after:download"
        },
        "onRequirePackage.prepareInstall": {
            func: "{that}.prepareInstall",
            priority: "after:check"
        },
        "onRequirePackage.install": {
            func: "{that}.installPackage",
            priority: "after:prepareInstall"
        },
        "onRequirePackage.cleanup": {
            func: "{that}.cleanup",
            priority: "after:install"
        },
        "onRemovePackage.uninstallPackage": {
            func: "{that}.uninstallPackage",
            priority: "first"
        }
    },

    members: {
        installations: {}
    }
});

/**
 * Create a directory where packages are temporarily stored.
 * @param packageName {String} Name of the package for which the directory is being created.
 */
gpii.iod.getWorkingPath = function (packageName) {
    var parts = [
        os.tmpdir(),
        "gpii-iod",
        packageName && packageName.replace(/[^a-z0-9]/, "_"),
        Math.random().toString(36)
    ];

    return parts.reduce(function (parent, child) {
        var dir = path.join(parent, child);
        try {
            fs.mkdirSync(dir);
        } catch (e) {
            if (e.code !== "EEXIST") {
                throw e;
            }
        }
        return dir;
    }, "");
};

/**
 * Finds a package installer component that handles the given type of package.
 *
 * @param that {Component} The gpii.iod instance.
 * @param packageType {string} The package type identifier.
 * @return {Component} A gpii.iod.installer component that handles the requested type of package.
 */
gpii.iod.findInstaller = function (that, packageType) {
    var packageInstallers = fluid.queryIoCSelector(that, "gpii.iod.packageInstaller");

    return fluid.find(packageInstallers, function (installer) {
        var packageTypes = fluid.makeArray(installer.options.packageTypes);
        return packageTypes.indexOf(packageType) >= 0
            ? installer
            : undefined;
    });
};


/**
 * Starts the process of installing a package.
 *
 * @param that {Component} The gpii.iod instance.
 * @param packageName {string} The package name.
 */
gpii.iod.requirePackage = function (that, packageName) {
    fluid.log("IoD: Requiring " + packageName);

    var installation = {
        id: "aaa",
        packageName: packageName
    };
    that.installations[installation.id] = installation;

    var promise = fluid.promise.fireTransformEvent(that.events.onRequirePackage, installation);

    return promise.then(function () {
        fluid.log("IoD: Installation complete");
    }, function (err) {
        fluid.log("IoD: Installation failed:", err.error || err);
        var installation = err.installation;
        if (!installation) {
            installation = that.installations[packageName];
        }
        if (installation) {
            installation.failed = true;
            that.cleanup(installation);
        }
    });
};

/**
 * Retrieve the package metadata.
 *
 * @param that {Component} The gpii.iod instance.
 * @param installation {object} The installation state.
 * @return {Promise} Resolves to an object containing package information and installation state.
 */
gpii.iod.getPackageInfo = function (that, installation) {
    fluid.log("IoD: Getting package info for " + installation.packageName);

    var packages = {
        "wget": {
            name: "wget",
            url: "e:\\Wget.1.19.4.nupkg",
            //url: "https://chocolatey.org/api/v2/package/Wget/1.19.4",
            filename: "Wget.1.19.4.nupkg",
            packageType: "chocolatey"
        }
    };

    installation.packageInfo = Object.assign({}, packages[installation.packageName]);

    var promise = fluid.promise();
    if (installation.packageInfo) {
        promise.resolve(installation);
    } else {
        promise.reject({
            isError: true,
            error: "no such package: " + installation.packageName
        });
    }

    return promise;
};

/**
 * Downloads a package from the server.
 *
 * @param that {Component} The gpii.iod instance.
 * @param installation {object} The installation state.
 * @return {Promise} Resolves to an object containing package information and installation state.
 */
gpii.iod.downloadPackage = function (that, installation) {
    fluid.log("IoD: Downloading package " + installation.packageInfo.url);

    var promise = fluid.promise();

    installation.tempDir = that.getWorkingPath(installation.packageName);
    installation.localPackage = path.join(installation.tempDir, installation.packageInfo.filename);

    fs.copyFile(installation.packageInfo.url, installation.localPackage, function (err) {
        if (err) {
            promise.reject({
                isError: true,
                message: "Unable to download package"
            });
        } else {
            promise.resolve(installation);
        }
    });

    return promise;
};

/**
 * Checks that a downloaded package is ok.
 *
 * @param that {Component} The gpii.iod instance.
 * @param installation {object} The installation state.
 * @return {Promise} Resolves to an object containing package information and installation state.
 */
gpii.iod.checkPackage = function (that, installation) {
    fluid.log("IoD: Checking downloaded package file " + installation.packageInfo.filename);
    return installation;
};

/**
 * Generate the installation instructions.
 *
 * @param that {Component} The gpii.iod instance.
 * @param installation {object} The installation state.
 * @return {Promise} Resolves to an object containing package information and installation state.
 */
gpii.iod.prepareInstall = function (that, installation) {
    fluid.log("IoD: Preparing installation for " + installation.packageName);

    installation.installer = that.findInstaller(installation.packageInfo.packageType);

    var promise = fluid.promise();
    if (installation.installer) {
        promise = installation.installer.prepareInstall(installation);
    } else {
        promise = fluid.promise();
        promise.reject({
            isError: true,
            error: "Unable to find a package installer for packageType '" + installation.packageInfo.packageType + "'"
        });
    }

    return promise;
};

/**
 * Installs the package.
 *
 * @param that {Component} The gpii.iod instance.
 * @param installation {object} The installation state.
 * @return {Promise} Resolves to an object containing package information and installation state.
 */
gpii.iod.installPackage = function (that, installation) {
    fluid.log("IoD: Installing package " + installation.packageInfo.filename);
    return installation.installer.installPackage(installation);
};

/**
 * Cleans up things that are no longer required.
 *
 * @param that {Component} The gpii.iod instance.
 * @param installation {object} The installation state.
 * @return {Promise} Resolves to an object containing package information and installation state.
 */
gpii.iod.cleanup = function (that, installation) {
    fluid.log("IoD: Cleaning installation of " + installation.packageName);

    var result = installation.installer.cleanup(installation);
    return fluid.toPromise(result).then(function () {
        delete that.installations[installation];
    });
};

/**
 * Starts the package removal routine.
 *
 * @param that {Component} The gpii.iod instance.
 * @param installation {object} The installation state.
 * @return {Promise} Resolves to an object containing package information and installation state.
 */
gpii.iod.startRemoval = function (that, installation) {
    if (typeof(installation) === "string") {
        installation = that.installations[installation];
    }

    if (!installation.installer) {
        installation.installer = that.findInstaller(installation.packageInfo.packageType);
    }

    fluid.log("IoD: Removing installation of " + installation.packageName);
    var promise = fluid.promise.fireTransformEvent(that.events.onRequirePackage, installation);
    return promise;
};

gpii.iod.uninstallPackage = function (that, installation) {
    installation.installer.uninstallPackage(installation);
};
