/*
 * Install on Demand.
 *
 * Copyright 2018 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion");

var path = require("path"),
    os = require("os"),
    fs = require("fs");

var gpii = fluid.registerNamespace("gpii");
fluid.registerNamespace("gpii.iod");

require("./packageInstaller.js");

fluid.defaults("gpii.iod", {
    gradeNames: ["fluid.component"],
    contextAwareness: {
        platform: {
            checks: {
                windows: {
                    contextValue: "{gpii.contexts.windows}",
                    gradeNames: ["gpii.windows.iod"]
                }
            }
        }
    },
    components: {
        "packageData": {
            createOnEvent: "onServiceFound",
            type: "gpii.iod.packageDataSource"
        },
        "packageDataFallback": {
            type: "gpii.iod.packageDataSource"
        }
    },
    events: {
        onServiceFound: null,
        onServiceLost: null
    },
    listeners: {
        "onCreate.discoverServer": "{that}.discoverServer"
    },
    invokers: {
        discoverServer: {
            funcName: "gpii.iod.discoverServer",
            args: ["{that}"]
        },
        requirePackage: {
            funcName: "gpii.iod.requirePackage",
            args: ["{that}", "{arguments}.0"]
        },
        getPackageInfo: {
            funcName: "gpii.iod.getPackageInfo",
            args: ["{that}", "{arguments}.0"]
        },
        startRemoval: {
            funcName: "gpii.iod.startRemoval",
            args: ["{that}", "{arguments}.0"]
        },
        getInstaller: {
            funcName: "gpii.iod.getInstaller",
            args: ["{that}", "{arguments}.0"]
        },
        getWorkingPath: {
            funcName: "gpii.iod.getWorkingPath",
            args: ["{arguments}.0"]
        }
    },

    members: {
        installations: {},
        endpoint: "http://gpii-iod:8087"
    }
});

fluid.defaults("gpii.iod.packageDataSource", {
    gradeNames: ["fluid.component"],
    readOnlyGrade: "gpii.iod.packageDataSource"
});

/**
 * Create a directory where packages are temporarily stored.
 *
 * @param packageName {String} Name of the package for which the directory is being created.
 * @return {Object} Contains the full path (fullPath), and the first path that was created (createdPath), for cleanup
 */
gpii.iod.getWorkingPath = function (packageName) {
    var createdPath = null;


    var parts = [
        os.tmpdir(),
        "gpii-iod",
        packageName && packageName.replace(/[^-a-z0-9]/, "_"),
        Math.random().toString(36)
    ];

    // Create a new directory
    var createDirectory = function (parent, child) {
        var dir = path.join(parent, child);
        try {
            fs.mkdirSync(dir);
            if (!createdPath) {
                createdPath = dir;
            }
        } catch (e) {
            if (e.code !== "EEXIST") {
                throw e;
            }
        }
        return dir;
    };

    // Create the parents of the path. (mkdirp isn't used because the first non-existing path is required to be known)
    var fullPath = parts.reduce(createDirectory, "");

    return {
        fullPath: fullPath,
        createdPath: createdPath
    };
};

/**
 * Finds a package installer component that handles the given type of package.
 *
 * @param that {Component} The gpii.iod instance.
 * @param packageType {string} The package type identifier.
 * @return {Component} A new instance of the gpii.iod.installer component that handles the requested type of package.
 */
gpii.iod.getInstaller = function (that, packageType) {
    var packageInstallers = fluid.queryIoCSelector(that, "gpii.iod.packageInstaller");

    var installerComponent = fluid.find(packageInstallers, function (installer) {
        var packageTypes = fluid.makeArray(installer.options.packageTypes);
        return packageTypes.indexOf(packageType) >= 0
            ? installer
            : undefined;
    });

    return installerComponent && fluid.invokeGlobalFunction(installerComponent.typeName);
};

/**
 * Starts the process of installing a package.
 *
 * @param that {Component} The gpii.iod instance.
 * @param packageRequest {string|Object} Package name, or object containing packageName, language, version.
 * @param packageRequest.packageName {string} Name of the package.
 * @param packageRequest.version {string} Name of the package.
 * @param packageRequest.language {string|string[]} Language.
 * @return {Promise} Resolves when the installation is complete.
 */
gpii.iod.requirePackage = function (that, packageRequest) {
    if (typeof(packageRequest) === "string") {
        packageRequest = {
            packageName: packageRequest
        };
    }

    fluid.log("IoD: Requiring " + packageRequest.packageName);

    var installation = {
        id: fluid.allocateGuid(),
        packageName: packageRequest.packageName,
        packageRequest: packageRequest
    };
    that.installations[installation.id] = installation;

    var promise = fluid.promise();

    // Get the package info.
    that.getPackageInfo(packageRequest).then(function (packageInfo) {
        // Create the installer instance.
        installation.packageInfo = packageInfo;
        installation.installer = that.getInstaller(packageInfo.packageType);
        if (installation.installer) {
            // Start the installer.
            var result = installation.installer.startInstaller(installation);
            fluid.promise.follow(result, promise);
        } else {
            promise.reject({
                isError: true,
                error: "Unable to find an installer for package type " + packageInfo.packageTypes
            });
        }
    }, promise.reject);

    return promise.then(function () {
        fluid.log("IoD: Installation complete");
    }, function (err) {
        fluid.log("IoD: Installation failed:", err.error || err);
        installation.failed = true;
    });
};

/**
 * Retrieve the package metadata.
 *
 * @param that {Component} The gpii.iod instance.
 * @param packageRequest {Object} Containing packageName, language, version.
 * @param packageRequest.packageName {string} Name of the package.
 * @param packageRequest.version {string} [optional] Version.
 * @param packageRequest.language {string} [optional] Language code with optional country code (en, en-US, es-ES).
 * @return {Promise} Resolves to an object containing package information.
 */
gpii.iod.getPackageInfo = function (that, packageRequest) {
    fluid.log("IoD: Getting package info for " + packageRequest.packageName);

    var promise = fluid.promise();

    var dataSource = that.packageData || (that.packageDataFallback.options.path && that.packageDataFallback);

    if (dataSource) {
        dataSource.get({
            packageName: packageRequest.packageName,
            language: packageRequest.language,
            version: packageRequest.version,
            server: that.remoteServer
        }).then(function (packageInfo) {
            if (packageRequest.language && packageInfo.languages) {
                // Merge the language-specific info.
                var lang = gpii.iod.matchLanguage(Object.keys(packageInfo.languages), packageRequest.language);
                if (lang) {
                    Object.assign(packageInfo, packageInfo.languages[lang]);
                    packageInfo.language = lang;
                }
            }

            promise.resolve(packageInfo);
        }, function (err) {
            promise.reject({
                isError: true,
                message: "Unknown package " + packageRequest.packageName,
                error: err
            });
        });
    } else {
        promise.reject({
            isError: true,
            message: "No package data source for IoD"
        });
    }

    return promise;
};

/**
 * Finds the best language from a list of available languages, using the following priority:
 * - Exact match with country code
 * - Exact match without country code
 * - First language, ignoring country code.
 *
 * @param languages {string[]} The list of available languages, with optional country code (en, en-US, es-ES)
 * @param language {string} The preferred language.
 * @return {string} The closest matching item from languages.
 */
gpii.iod.matchLanguage = function (languages, language) {
    languages = fluid.makeArray(languages);

    // Exact match.
    var index = languages.indexOf(language);
    var match = index >= 0 && languages[index];

    if (!match) {
        var langCode = language.substr(0, 2);
        // Language without country.
        if (language.length > 2) {
            index = languages.indexOf(language);
            match = index >= 0 && languages[index];
        }

        if (!match) {
            // Ignore the country.
            match = languages.find(function (lang) {
                return lang.substr(0, 2) === langCode;
            });
        }
    }

    return match;
};

/**
 * Starts the package removal routine.
 *
 * @param that {Component} The gpii.iod instance.
 * @param installation {object} The installation state.
 * @return {Promise} Resolves to an object containing package information and installation state.
 */
gpii.iod.startRemoval = function (that, installation) {
    if (typeof(installation) === "string") {
        installation = that.installations[installation];
    }

    if (!installation.installer) {
        installation.installer = that.getInstaller(installation.packageInfo.packageType);
    }

    fluid.log("IoD: Removing installation of " + installation.packageName);
    var promise = fluid.promise.fireTransformEvent(that.events.onRequirePackage, installation);
    return promise;
};

/**
 * Uninstall a package.
 *
 * @param that {Component} The gpii.iod instance.
 * @param installation {object} The installation state.
 */
gpii.iod.uninstallPackage = function (that, installation) {
    installation.installer.uninstallPackage(installation);
};

/**
 * Discovers the IoD server.
 *
 * @param that
 */
gpii.iod.discoverServer = function (that) {

    var addr = process.env.GPII_IOD_ENDPOINT;

    if (!addr) {
        var bonjour = that.bonjourInstance || (that.bonjourInstance = require("bonjour")());
        if (bonjour) {
            var b = bonjour.find({type: "gpii-iod"});
            b.on("up", function (service) {
                that.endpoint = "https://" + service.host + ":" + service.port;
                that.endpointService = service.fqdn;
                fluid.log("IoD: Found service '" + that.endpointService + "': " + that.endpoint);
                that.events.onServiceFound.fire();
            });

            b.on("down", function (service) {
                if (that.endpoint && that.endpointService === service.fqdn) {
                    fluid.log("IoD: Lost service '" + that.endpointService + "': " + that.endpoint);
                    that.endpoint = null;
                    that.endpointService = null;
                    that.events.onServiceLost.fire();
                    that.packageData.destroy();
                }
            });

        }
    }

    that.endpoint = addr;
};
