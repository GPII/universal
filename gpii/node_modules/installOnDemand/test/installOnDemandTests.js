/*
 * IoD Tests.
 *
 * Copyright 2018 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var os = require("os"),
    fs = require("fs"),
    path = require("path");

var fluid = require("gpii-universal");
var kettle = fluid.require("kettle");
kettle.loadTestingSupport();
var jqUnit = fluid.require("node-jqunit");
var gpii = fluid.registerNamespace("gpii");

fluid.registerNamespace("gpii.tests.iod");

require("../index.js");

jqUnit.module("gpii.tests.iod");

gpii.tests.iod.getInstallerTests = fluid.freezeRecursive([
    {
        packageType: "testPackageType1",
        expect: "gpii.tests.iod.testInstaller1"
    },
    {
        packageType: "testPackageType2a",
        expect: "gpii.tests.iod.testInstaller2"
    },
    {
        packageType: "testPackageType2b",
        expect: "gpii.tests.iod.testInstaller2"
    },
    {
        // Fails at installation, not during initialisation.
        packageType: "testFailPackageType",
        expect: "gpii.tests.iod.testInstallerFail"
    },
    {
        packageType: "testPackageType-not-exist",
        expect: undefined
    }
]);

gpii.tests.iod.getPackageInfoTests = fluid.freezeRecursive([
    {
        id: "No matching package",
        request: {
            packageName: "package-not-exists"
        },
        expect: "reject"
    },
    {
        id: "Single language package",
        request: {
            packageName: "package1"
        },
        expect: require("./testPackages/package1.json")
    },
    {
        id: "Single language package, with language specified",
        request: {
            packageName: "package1",
            language: "fr-FR"
        },
        expect: require("./testPackages/package1.json")
    },
    {
        id: "Multi-language package, language not specified",
        request: {
            packageName: "languages"
        },
        expect: {
            "name": "languages",
            "packageType": "testPackageType1",
            "filename": "example.filename"
        }
    },
    {
        id: "Multi-language package, unknown language specified",
        request: {
            packageName: "languages",
            language: "xx-YY"
        },
        expect: {
            "name": "languages",
            "packageType": "testPackageType1",
            "filename": "example.filename"
        }
    },
    {
        id: "Multi-language package, unknown language, no country specified",
        request: {
            packageName: "languages",
            language: "xx"
        },
        expect: {
            "name": "languages",
            "packageType": "testPackageType1",
            "filename": "example.filename"
        }
    },
    {
        id: "Multi-language package, full language specified",
        request: {
            packageName: "languages",
            language: "es-ES"
        },
        expect: {
            "name": "languages",
            "packageType": "testPackageType1",
            "filename": "file.es-es",
            "language": "es-ES"
        }
    },
    {
        id: "Multi-language package, full language specified 2",
        request: {
            packageName: "languages",
            language: "es-MX"
        },
        expect: {
            "name": "languages",
            "packageType": "testPackageType1",
            "filename": "file.es-mx",
            "language": "es-MX"
        }
    },
    {
        id: "Multi-language package, no country specified",
        request: {
            packageName: "languages",
            language: "es"
        },
        expect: {
            "name": "languages",
            "packageType": "testPackageType1",
            "filename": "file.es",
            "language": "es"
        }
    },
    {
        id: "Multi-language package, unknown country specified",
        request: {
            packageName: "languages",
            language: "es-YY"
        },
        expect: {
            "name": "languages",
            "packageType": "testPackageType1",
            "filename": "file.es",
            "language": "es"
        }
    },
    {
        id: "Multi-language package, no country specified, no non-country package",
        request: {
            packageName: "languages",
            language: "zh"
        },
        expect: {
            "name": "languages",
            "packageType": "testPackageType1",
            "filename": "file.zh-cn",
            "language": "zh-CN"
        }
    },
    {
        id: "Multi-language package, unknown country specified, no non-country package",
        request: {
            packageName: "languages",
            language: "zh-YY"
        },
        expect: {
            "name": "languages",
            "packageType": "testPackageType1",
            "filename": "file.zh-cn",
            "language": "zh-CN"
        }
    }
]);

gpii.tests.iod.startInstallerTests = fluid.freezeRecursive([
    {
        packageRequest: "no-such-package",
        expect: "reject"
    },
    {
        packageRequest: "unknownType",
        expect: "reject"
    },
    {
        packageRequest: "package1",
        expect: {
            installer: "gpii.tests.iod.testInstaller1",
            packageName: "package1"
        }
    },
    {
        packageRequest: {
            packageName: "package1"
        },
        expect: {
            installer: "gpii.tests.iod.testInstaller1",
            packageName: "package1"
        }
    },
    {
        packageRequest: {
            packageName: "package2"
        },
        expect: {
            installer: "gpii.tests.iod.testInstaller2",
            packageName: "package2"
        }
    },
    {
        packageRequest: {
            packageName: "languages",
            language: "es-ES"
        },
        expect: {
            installer: "gpii.tests.iod.testInstaller1",
            packageName: "languages"
        }
    },
    {
        packageRequest: {
            packageName: "languages",
            language: "nl-NL"
        },
        expect: {
            installer: "gpii.tests.iod.testInstaller2",
            packageName: "languages"
        }
    },
    {
        packageRequest: "failInstall",
        expect: "reject"
    }
]);

fluid.defaults("gpii.tests.iod", {
    gradeNames: [ "gpii.iod" ],
    components: {
        "testInstaller1": {
            type: "gpii.tests.iod.testInstaller1"
        },
        "testInstaller2": {
            type: "gpii.tests.iod.testInstaller2"
        },
        "testInstallerFail": {
            type: "gpii.tests.iod.testInstallerFail"
        },
        "packageDataSource": {
            type: "kettle.dataSource.file",
            options: {
                path: __dirname + "/testPackages/%packageName.json"
            }
        }
    }
});

fluid.defaults("gpii.tests.iod.testInstaller1", {
    gradeNames: ["fluid.component", "gpii.iod.packageInstaller"],

    invokers: {
        installPackage: "fluid.identity",
        uninstallPackage: "fluid.identity",
        startInstaller: {
            funcName: "gpii.tests.iod.testInstaller1.startInstaller",
            args: ["{that}", "{iod}", "{arguments}.0"]
        }
    },

    packageTypes: "testPackageType1"
});

fluid.defaults("gpii.tests.iod.testInstaller2", {
    gradeNames: [ "gpii.tests.iod.testInstaller1"],
    packageTypes: ["testPackageType2a", "testPackageType2b"]
});

fluid.defaults("gpii.tests.iod.testInstallerFail", {
    gradeNames: ["gpii.tests.iod.testInstaller1"],
    testReject: true,
    packageTypes: "testFailPackageType"
});

/**
 * Test function for packageInstaller.startInstaller.
 * @param that {Component} The gpii.tests.iod.testInstaller1 instance.
 * @param iod {Component} The gpii.test.iod instance.
 * @param packageInfo {object} The package to install.
 * @return {Promise} A resolved promise.
 */
gpii.tests.iod.testInstaller1.startInstaller = function (that, iod, packageInfo) {
    if (iod.startInstallerCalled) {
        jqUnit.fail("startInstaller called twice");
    }
    iod.startInstallerCalled = {
        installer: that.typeName,
        packageName: packageInfo.packageName
    };

    var promise = fluid.promise();
    if (that.options.testReject) {
        promise.reject({
            isError: true,
            error: "Test failure"
        });
    } else {
        promise.resolve();
    }

    return promise;
};


jqUnit.test("test getWorkingPath", function () {

    var safeToRemove = false;
    var packageName = "test" + Math.random().toString(36).substring(2);
    var result = gpii.iod.getWorkingPath(packageName);

    jqUnit.assertTrue("getWorkingPath must return something", !!result);
    jqUnit.assertEquals("fullPath must be a string", "string", typeof result.fullPath);
    jqUnit.assertEquals("createdPath must be a string", "string", typeof result.createdPath);

    try {
        jqUnit.assertNotEquals("fullPath must contain the package name", result.fullPath.indexOf(packageName));

        var isParent = result.fullPath.startsWith(result.createdPath + path.sep);
        jqUnit.assertTrue("The first created directory must be a parent of the full path", isParent);

        safeToRemove = isParent;

        var isTempDirParent = result.fullPath.startsWith(os.tmpdir());
        jqUnit.assertTrue("The path must be a subdirectory of the system's temporary directory", isTempDirParent);

        safeToRemove = safeToRemove && isTempDirParent;


        // These two aren't supposed to be guaranteed, however using a random package name should have ensured this.
        jqUnit.assertNotEquals("The first created directory must not be the full path",
            result.createdPath, result.fullPath);
        jqUnit.assertNotEquals("fullPath must contain the package name", result.fullPath.indexOf(packageName));

        try {
            var stats = fs.lstatSync(result.fullPath);
            jqUnit.assertTrue("fullPath must be a directory", stats.isDirectory());
        } catch (e) {
            fluid.log("Error checking the existence of result.fullPath");
            jqUnit.fail(e);
        }

        var fullPathContents = fs.readdirSync(result.fullPath);
        jqUnit.assertEquals("fullPath must be an empty directory", 0, fullPathContents.length);

        var createdPathContents = fs.readdirSync(result.createdPath);
        jqUnit.assertEquals("createdPath must only contain a single file", 1, createdPathContents.length);

    } finally {
        // Remove directories. If the test failed, the paths could point to anything. So, rimraf is not used which will
        // ensure only the directories are removed, and any other content remain.
        if (safeToRemove) {
            var parts = result.fullPath.split(path.sep);
            var tmpDir = os.tmpdir();
            while (parts.length > 0) {
                var dir = parts.join(path.sep);
                parts.pop();
                if ((dir === result.createdPath) || (dir === tmpDir)) {
                    break;
                } else {
                    fs.rmdirSync(dir);
                }
            }
        }
    }
});

// Test getInstaller returns the correct installer
jqUnit.test("test getInstaller", function () {

    var tests = gpii.tests.iod.getInstallerTests;

    var iod = gpii.tests.iod();

    fluid.each(tests, function (test) {

        var installer = iod.getInstaller(test.packageType);

        if (test.expect) {
            jqUnit.assertEquals("getInstaller should return the correct installer for packageType=" + test.packageType,
                test.expect, installer && installer.typeName);
        } else {
            jqUnit.assertFalse("getInstaller should return nothing for packageType=" + test.packageType, !!installer);
        }

        if (installer) {
            installer.destroy();
        }
    });
});

// Test getPackageInfo returns correct information
jqUnit.asyncTest("test getPackageInfo", function () {

    var tests = gpii.tests.iod.getPackageInfoTests;
    jqUnit.expect(tests.length * 2);

    var iod = gpii.tests.iod();

    var testIndex = -1;
    var nextTest = function () {
        if (++testIndex >= tests.length) {
            jqUnit.start();
            return;
        }

        var test = tests[testIndex];
        var suffix = " - test:" + test.id;

        fluid.log("getPackage: " + test.request.packageName + ", " + test.request.language);

        var p = iod.getPackageInfo(test.request);

        jqUnit.assertTrue("getPackageInfo must return a promise" + suffix, fluid.isPromise(p));

        p.then(function (packageInfo) {
            delete packageInfo.languages;
            jqUnit.assertDeepEq("packageInfo must match expected" + suffix, test.expect, packageInfo);
            nextTest();
        }, function () {
            jqUnit.assertEquals("packageInfo must only reject if expected" + suffix, test.expect, "reject");
            nextTest();
        });

    };

    nextTest();
});

// Test requirePackage correctly starts the installer.
jqUnit.asyncTest("test requirePackage", function () {
    var tests = gpii.tests.iod.startInstallerTests;
    jqUnit.expect(tests.length * 3);
    var iod = gpii.tests.iod();

    var testIndex = -1;
    var nextTest = function () {
        if (++testIndex >= tests.length) {
            jqUnit.start();
            return;
        }

        var test = tests[testIndex];
        var suffix = " - test:" + test.id;

        iod.startInstallerCalled = null;
        var p = iod.requirePackage(test.packageRequest);

        jqUnit.assertTrue("requirePackage must return a promise" + suffix, fluid.isPromise(p));

        p.then(function () {
            jqUnit.assertTrue("startInstaller must have been called" + suffix, !!iod.startInstallerCalled);
            jqUnit.assertDeepEq("startInstaller must have been called correctly" + suffix,
                test.expect, iod.startInstallerCalled);
            nextTest();
        }, function () {
            jqUnit.assertEquals("packageInfo must only reject if expected" + suffix, test.expect, "reject");
            jqUnit.assert("balance the assert count");
            nextTest();
        });

    };

    nextTest();
});
