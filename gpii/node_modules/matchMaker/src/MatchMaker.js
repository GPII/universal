/*!
GPII Default Matchmaker

Copyright 2012 OCAD University
Copyright 2012 Antranig Basman

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

(function () {

    "use strict";

    var fluid = require("infusion"),
        path = require("path"),
        semver = require("semver"),
        gpii = fluid.registerNamespace("gpii");

    fluid.require("gpiiFramework", require);
    fluid.require("./MatchPost.js", require);
    fluid.require("transformer", require);

    fluid.defaults("gpii.matchMaker", {
        gradeNames: ["gpii.app", "autoInit"],
        handlers: {
            matchPost: {
                route: "/match",
                type: "post"
            }
        },
        strategies: {
            flat: {
                strategy: "gpii.matchMaker.flat.disposeStrategy"
            }
        },
        solutionsReporterUrl: "",
        components: {
            rawSolutionsReporter: {
                type: "gpii.dataSource"
            },
            solutionsReporter: {
                type: "gpii.callbackWrappingDataSource"
            },
            transformer: {
                type: "gpii.transformer"
            }
        },
        invokers: {
            match: "gpii.matchMaker.match",
            prefilterSolutions: "gpii.matchMaker.prefilterSolutions",
            filterSolutionsByVersion: "gpii.matchMaker.filterSolutionsByVersion"
        }
    });

    fluid.demands("gpii.urlExpander", ["matchMaker.development", "gpii.matchMaker"], {
        options: {
            vars: {
                port: "{gpii.server}.options.port",
                root: path.join(__dirname, "..")
            }
        }
    });

    fluid.demands("rawSolutionsReporter", "gpii.matchMaker", {
        funcName: "gpii.dataSource.URL",
        options: {
            url: "{gpii.matchMaker}.options.solutionsReporterUrl",
            termMap: {
                os: "%os",
                version: "%version"
            }
        }
    });
    fluid.demands("solutionsReporter", "gpii.matchMaker", {
        options: {
            components: {
                rawSource: "{rawSolutionsReporter}"
            }
        }
    });

    fluid.demands("gpii.matchMaker.match", "gpii.matchMaker", {
        funcName: "gpii.matchMaker.match",
        args: ["{arguments}.0", "{arguments}.1", "{arguments}.2"]
    });

    fluid.demands("gpii.matchMaker.prefilterSolutions", "gpii.matchMaker", {
        funcName: "gpii.matchMaker.prefilterSolutions",
        args: ["{arguments}.0", "{arguments}.1"]
    });

    fluid.demands("gpii.matchMaker.filterSolutionsByVersion", "gpii.matchMaker", {
        funcName: "gpii.matchMaker.filterSolutionsByVersion",
        args: ["{arguments}.0", "{arguments}.1", "{arguments}.2"]
    });

    gpii.matchMaker.prefilterSolutions = function (solutions, device) {
        return fluid.remove_if(fluid.copy(solutions), function (solution) {
            // Match on device solutions.
            var matchesSolutions = fluid.find(device.solutions, function (devSolution) {
                if (devSolution.id === solution.id && 
                    (!solution.version || 
                     !devSolution.version || 
                     semver.satisfies(devSolution.version, solution.version)
                    )) {
                    return true;
                }
            });
            if (!matchesSolutions) {
                return solutions;
            }
        });
    };

    gpii.matchMaker.filterSolutionsByVersion = function (solutions, os, version) {
        if (!version) {
            return;
        }
        fluid.remove_if(solutions, function (solution) {
            var solutionOSVersion = fluid.find(fluid.get(solution, "contexts.OS"), function(OSEntry) {
                return OSEntry.id === os ? OSEntry.version : undefined;
            });
            if (!semver.satisfies(version, solutionOSVersion)) {
                return true;
            }
        });
    };

    gpii.matchMaker.match = function (preferences, solutions, strategy) {
        var disposed = gpii.matchMaker.disposeSolutions(preferences, solutions, strategy);
        var togo = [];
        fluid.each(disposed, function(solrec) {
            if (solrec.disposition === "accept") {
                togo.push(solrec.solution);
            }
        });
        return togo;
    };

})();