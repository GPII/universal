/*!
GPII Default Matchmaker

Copyright 2012 OCAD University
Copyright 2012 Antranig Basman

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

(function () {

    "use strict";

    var fluid = require("infusion"),
        path = require("path"),
        semver = require("semver"),
        when = require("when"),
        gpii = fluid.registerNamespace("gpii"),
        $ = fluid.registerNamespace("jQuery");

    fluid.require("kettle", require);
    fluid.require("./MatchPost.js", require);
    fluid.require("transformer", require);
    
    fluid.registerNamespace("gpii.matchMaker");
    
    gpii.matchMaker.appToISO24751 = require(path.resolve(__dirname, "appToISO24751.json"));

    fluid.defaults("gpii.matchMaker", {
        gradeNames: ["kettle.app", "autoInit"],
        mergePolicy: {
            appToISO24751: "nomerge"
        },
        handlers: {
            matchPost: {
                route: "/match",
                type: "post"
            }
        },
        ontologyRules: gpii.matchMaker.appToISO24751,
        strategy: "gpii.matchMaker.flat.disposeStrategy",
        solutionsReporterUrl: "",
        ontologyServerUrl: "",
        root: path.join(__dirname, ".."),
        components: {
            solutionsReporter: {
                type: "kettle.dataSource.URL",
                options: {
                    gradeNames: ["kettle.dataSource.simpleCallbackWrapper"],
                    url: "{gpii.matchMaker}.options.solutionsReporterUrl",
                    termMap: {
                        "os": "%os",
                        "version": "%version"
                    }
                }
            },
            ontologyServer: {
                type: "kettle.dataSource.URL",
                options: {
                    gradeNames: ["kettle.dataSource.simpleCallbackWrapper"],
                    url: "{gpii.matchMaker}.options.ontologyServerUrl",
                    writable: true
                }
            },
            transformer: {
                type: "gpii.transformer"
            }
        },
        invokers: {
            match: {
                funcName: "gpii.matchMaker.match",
                args: ["{arguments}.0", "{arguments}.1", "{arguments}.2", "{that}.options.ontologyRules"]
            },
            prefilterSolutions: {
                funcName: "gpii.matchMaker.prefilterSolutions",
                args: ["{arguments}.0", "{arguments}.1"]
            },
            filterSolutionsByVersion: {
                funcName: "gpii.matchMaker.filterSolutionsByVersion",
                args: ["{arguments}.0", "{arguments}.1", "{arguments}.2"]
            }
        }
    });

    fluid.defaults("gpii.matchMaker.dev", {
        gradeNames: ["autoInit", "fluid.littleComponent"],
        components: {
            ontologyServer: {
                type: "gpii.ontologyServer.development"
            }
        },
        distributeOptions: {
            source: "{that}.options.urlExpanderGradeNames",
            target: "{that urlExpander}.options.gradeNames"
        },
        urlExpanderGradeNames: ["kettle.urlExpander.development"]
    });

    fluid.defaults("gpii.matchMakerProxy", {
        gradeNames: ["kettle.app", "autoInit"],
        handlers: {
            proxyMatchPost: {
                route: "/match",
                type: "post"
            }
        },
        root: path.join(__dirname, ".."),
        components: {
            matchMakerSource: {
                type: "kettle.dataSource.URL",
                options: {
                    gradeNames: ["kettle.dataSource.simpleCallbackWrapper"],
                    url: "{gpii.matchMakerProxy}.options.matchMakerUrl",
                    writable: true,
                    termMap: {
                        matchMakerPath: "%matchMakerPath"
                    }
                }
            }
        },
        matchMakerPathMap: {},
        matchMakerUrl: "%matchMakerPath/match"
    });

    gpii.matchMaker.prefilterSolutions = function (solutions, device) {
        return fluid.remove_if(fluid.copy(solutions), function (solution) {
            // Match on device solutions.
            var matchesSolutions = fluid.find(device.solutions, function (devSolution) {
                if (devSolution.id === solution.id &&
                    (!solution.version ||
                     !devSolution.version ||
                     semver.satisfies(devSolution.version, solution.version)
                    )) {
                    return true;
                }
            });
            if (!matchesSolutions) {
                return solutions;
            }
        });
    };

    gpii.matchMaker.filterSolutionsByVersion = function (solutions, os, version) {
        if (!version) {
            return;
        }
        fluid.remove_if(solutions, function (solution) {
            var solutionOSVersion = fluid.find(fluid.get(solution, "contexts.OS"), function (OSEntry) {
                return OSEntry.id === os ? OSEntry.version : undefined;
            });
            if (!semver.satisfies(version, solutionOSVersion)) {
                return true;
            }
        });
    };

    gpii.matchMaker.match = function (preferences, solutions, strategy, ontRules) {
        // these rules should be operated instead by the ontology server - see GPII-672
        fluid.each(preferences.applications, function (val, id) {
            var trans = ontRules[id];
            if (!trans) {
                return;
            }
            var new_pref = fluid.model.transformWithRules(val.parameters, trans);
            $.extend(true, preferences, new_pref);
        });

        return when(gpii.matchMaker.disposeSolutions(preferences, solutions, strategy), function (disposed) {
            var togo = [];
            fluid.each(disposed, function(solrec) {
                if (solrec.disposition === "accept") {
                    togo.push(solrec.solution);
                }
            });
            return togo;
        });
    };

})();