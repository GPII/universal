/**
 * GPII Match Maker Proxy Tests
 *
 * Copyright 2013 OCAD University
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/kettle/LICENSE.txt
 */

"use strict";

var fluid = require("infusion"),
    jqUnit = fluid.require("jqUnit"),
    kettle = fluid.registerNamespace("kettle"),
    gpii = fluid.registerNamespace("gpii");

require("matchMaker");
require("ontologyHandler");

kettle.loadTestingSupport();

fluid.registerNamespace("gpii.tests.matchMaker.inverse");

// TODO: create a unified scheme for locating preferences sets
gpii.tests.matchMaker.inverse.os_win7 =   require("universal/testData/preferences/acceptanceTests/os_win7.json");
gpii.tests.matchMaker.inverse.os_gnome =  require("universal/testData/preferences/acceptanceTests/os_gnome.json");
gpii.tests.matchMaker.inverse.os_common = require("universal/testData/preferences/acceptanceTests/os_common.json");
gpii.tests.matchMaker.inverse.rules =     require("matchMaker/src/inverseCapabilities.json");

gpii.tests.matchMaker.inverse.ontologyISO24751 = require("universal/testData/ontologies/ISO24751-flat.json");
gpii.tests.matchMaker.inverse.ontologyFlat = fluid.model.transform.invertConfiguration(gpii.tests.matchMaker.inverse.ontologyISO24751);

fluid.defaults("gpii.tests.matchMaker.inverse.env", {
    gradeNames: ["fluid.test.testEnvironment", "autoInit"],
    components: {
        tester: {
            type: "fluid.test.testCaseHolder",
            options: {
                modules: [{
                    name: "Inverse Capabilities tests",
                    tests: [{
                        name: "os_win7 inversion",
                        expect: 1,
                        func: "gpii.tests.matchMaker.inverse.testInversion",
                        args: ["os_win7"]
                    }, {
                        name: "os_gnome inversion",
                        expect: 1,
                        func: "gpii.tests.matchMaker.inverse.testInversion",
                        args: ["os_gnome"]
                    }, {
                        name: "os_common inversion",
                        expect: 1,
                        func: "gpii.tests.matchMaker.inverse.testInversion",
                        args: ["os_common"]
                    }]
                }]
            }
        }
    }
});

gpii.tests.matchMaker.inverse.testInversion = function (prefName) {
    var root = gpii.tests.matchMaker.inverse;
    var prefs = root[prefName].flat;
    var rules = root.rules;
    var hierarchical = gpii.ontologyHandler.doSuppliedTransform(prefs, gpii.tests.matchMaker.inverse.ontologyFlat);
    var transformed = gpii.matchMaker.supplyOntologizedPreferences(hierarchical, rules);
    var expected = require("matchMaker/test/inverseCapabilities/" + prefName + "_expected");
    jqUnit.assertDeepEq("Expected inversion for capabilities transformation", expected, transformed);
};

module.exports = kettle.test.bootstrap("gpii.tests.matchMaker.inverse.env");
