/*!
GPII Untrusted Settings Data Source Tests

Copyright 2017 OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

"use strict";

var fluid = require("infusion"),
    gpii = fluid.registerNamespace("gpii"),
    kettle = require("kettle"),
    jqUnit = fluid.registerNamespace("jqUnit"),
    nock = require("nock");

require("flowManager");

// To reuse gpii.tests.oauth2.invokePromiseProducer()
fluid.require("%universal/gpii/node_modules/gpii-oauth2/gpii-oauth2-datastore/test/js/DataStoreTestsUtils.js");

fluid.require("%universal/gpii/node_modules/testing/src/NockUtils.js");

kettle.loadTestingSupport();

fluid.registerNamespace("gpii.tests.untrustedSettingsDataSource");

gpii.tests.untrustedSettingsDataSource.hostname = "http://gpii.net";
gpii.tests.untrustedSettingsDataSource.accessTokenUrl = "/access_token";
gpii.tests.untrustedSettingsDataSource.untrustedSettingsUrl = "/%userToken/untrusted-settings/%device";
gpii.tests.untrustedSettingsDataSource.userToken = "gpii-token-test";
gpii.tests.untrustedSettingsDataSource.device = {
    "OS": "windows 10"
};

gpii.tests.untrustedSettingsDataSource.nockConfig = {
    accessToken: {
        url: gpii.tests.untrustedSettingsDataSource.accessTokenUrl,
        data: {
            "grant_type": "password",
            "password": "dummy",
            "client_id": "pilot-computer",
            "client_secret": "pilot-computer-secret",
            "username": gpii.tests.untrustedSettingsDataSource.userToken
        },
        status: 200,
        response: {
            access_token: "access-token-test-in-untrustedSettingsDataSource",
            expiresIn: 3600,
            token_type: "Bearer"
        }
    },
    untrustedSettings: {
        url: fluid.stringTemplate(gpii.tests.untrustedSettingsDataSource.untrustedSettingsUrl, {
            userToken: gpii.tests.untrustedSettingsDataSource.userToken,
            device: encodeURIComponent(JSON.stringify(gpii.tests.untrustedSettingsDataSource.device))
        }),
        authHeader: {
            header: "Authorization",
            value: /Bearer .*/
        },
        status: 200,
        response: {
            settings: "user settings in success"
        }
    }
};

// Set up mock ajax responses
gpii.tests.untrustedSettingsDataSource.setUpNock = function (config) {
    var cloudMock = nock(gpii.tests.untrustedSettingsDataSource.hostname);

    // log nock matches
    cloudMock.log(console.log);

    // mock POST requests to "/access_token"
    cloudMock.post(config.accessToken.url, config.accessToken.data)
        .reply(config.accessToken.status, config.accessToken.response);
    // mock GET requests to "/untrusted-settings"
    cloudMock.get(config.untrustedSettings.url)
        .matchHeader(config.untrustedSettings.authHeader.header, config.untrustedSettings.authHeader.value)
        .reply(config.untrustedSettings.status, config.untrustedSettings.response);
};

// The customized untrustedSettingsDataSource component for tests
fluid.defaults("gpii.tests.untrustedSettingsDataSource", {
    gradeNames: ["gpii.flowManager.untrustedSettingsDataSource"],
    untrustedSettingsUrl: gpii.tests.untrustedSettingsDataSource.hostname + gpii.tests.untrustedSettingsDataSource.untrustedSettingsUrl,
    accessTokenUrl: gpii.tests.untrustedSettingsDataSource.hostname + gpii.tests.untrustedSettingsDataSource.accessTokenUrl,
    clientCredentialFilePath: "%universal/gpii/node_modules/flowManager/test/data/clientCredential-correct.json"
});

// The base testEnvironment grade to be inherited by all tests
fluid.defaults("gpii.tests.untrustedSettingsDataSourceTests", {
    gradeNames: ["fluid.test.testEnvironment", "gpii.test.testWithNock"],
    settingsDataSourceGrade: "gpii.tests.untrustedSettingsDataSource",   // supplied by individual tests
    testCaseHolderGrade: null,   // supplied by individual tests
    invokers: {
        setUpNock: {
            funcName: "gpii.tests.untrustedSettingsDataSource.setUpNock",
            args: gpii.tests.untrustedSettingsDataSource.nockConfig
        }
    },
    distributeOptions: {
        settingsDataSourceGrade: {
            source: "{that}.options.settingsDataSourceGrade",
            target: "{that > untrustedSettingsDataSource}.type"
        },
        testCaseHolderGrade: {
            source: "{that}.options.testCaseHolderGrade",
            target: "{that > testCaseHolder}.type"
        }
    },
    components: {
        untrustedSettingsDataSource: {
            type: "gpii.tests.untrustedSettingsDataSource"
        },
        testCaseHolder: {
            type: "fluid.test.testCaseHolder"
        }
    }
});

// The base testCaseHolder grade to be inherited by test case holders used by all tests
fluid.defaults("gpii.tests.untrustedSettingsDataSource.testCaseHolder", {
    gradeNames: "fluid.test.testCaseHolder",
    events: {
        onResponse: null,
        onError: null
    }
});

// 1. No saved access token: retrieve and save an access token that then is used to retrieve user settings
fluid.defaults("gpii.tests.untrustedSettingsDataSource.testCaseHolder.noSavedAccessToken", {
    gradeNames: "gpii.tests.untrustedSettingsDataSource.testCaseHolder",
    modules: [{
        name: "A workflow with undefined initial access token: an access token is requested, saved and used to retrieve user settings",
        expect: 4,
        tests: [{
            name: "Settings received with the initial new token being fetched and saved",
            sequence: [{
                func: "jqUnit.assertDeepEq",
                args: ["No saved access token", {}, "{untrustedSettingsDataSource}.accessTokens"]
            }, {
                func: "gpii.tests.oauth2.invokePromiseProducer",
                args: ["{untrustedSettingsDataSource}.get", [gpii.tests.untrustedSettingsDataSource.userToken, gpii.tests.untrustedSettingsDataSource.device], "{that}"]
            }, {
                listener: "jqUnit.assertValue",
                args: ["The user settings are received", "{arguments}.0.settings"],
                event: "{that}.events.onResponse"
            }, {
                func: "jqUnit.assertValue",
                args: ["The access token is received and saved", "{untrustedSettingsDataSource}.accessTokens.gpii-token-test.accessToken"]
            }, {
                func: "jqUnit.assertValue",
                args: ["The expiresIn is received and saved", "{untrustedSettingsDataSource}.accessTokens.gpii-token-test.timestampExpires"]
            }]
        }]
    }]
});

fluid.defaults("gpii.tests.untrustedSettingsDataSourceTests.noSavedAccessToken", {
    gradeNames: ["gpii.tests.untrustedSettingsDataSourceTests"],
    testCaseHolderGrade: "gpii.tests.untrustedSettingsDataSource.testCaseHolder.noSavedAccessToken"
});

// 2. Has unexpired access token: use saved access token to retrieve user settings
fluid.defaults("gpii.tests.untrustedSettingsDataSource.validSavedAccessToken", {
    gradeNames: ["gpii.tests.untrustedSettingsDataSource"],
    members: {
        accessTokens: {
            "gpii-token-test": {
                accessToken: "a-valid-initial-access-token",
                timestampExpires: new Date(new Date().getTime() + 3600 * 1000).toISOString()  // expires in 1 hour
            }
        }
    }
});

fluid.defaults("gpii.tests.untrustedSettingsDataSource.testCaseHolder.validSavedAccessToken", {
    gradeNames: "gpii.tests.untrustedSettingsDataSource.testCaseHolder",
    modules: [{
        name: "A workflow with a valid saved access token: the saved access token is used to retrieve user settings",
        expect: 5,
        tests: [{
            name: "Settings received with the initial new token being fetched and saved",
            sequence: [{
                func: "gpii.tests.untrustedSettingsDataSource.assertInitialAccessToken",
                args: ["{that}", "{untrustedSettingsDataSource}", false]
            }, {
                func: "gpii.tests.oauth2.invokePromiseProducer",
                args: ["{untrustedSettingsDataSource}.get", [gpii.tests.untrustedSettingsDataSource.userToken, gpii.tests.untrustedSettingsDataSource.device], "{that}"]
            }, {
                listener: "jqUnit.assertValue",
                args: ["The user settings are received", "{arguments}.0.settings"],
                event: "{that}.events.onResponse"
            }, {
                func: "jqUnit.assertEquals",
                args: ["The saved access token is same as the initial saved value", "{that}.initialSavedAccessToken", "{untrustedSettingsDataSource}.accessTokens.gpii-token-test.accessToken"]
            }, {
                func: "jqUnit.assertEquals",
                args: ["The saved timestampExpires is same as the initial saved value", "{that}.initialSavedTimestampExpires", "{untrustedSettingsDataSource}.accessTokens.gpii-token-test.timestampExpires"]
            }]
        }]
    }]
});

fluid.defaults("gpii.tests.untrustedSettingsDataSourceTests.validSavedAccessToken", {
    gradeNames: ["gpii.tests.untrustedSettingsDataSourceTests"],
    settingsDataSourceGrade: "gpii.tests.untrustedSettingsDataSource.validSavedAccessToken",
    testCaseHolderGrade: "gpii.tests.untrustedSettingsDataSource.testCaseHolder.validSavedAccessToken"
});

// 2. Has unexpired access token: use saved access token to retrieve user settings
fluid.defaults("gpii.tests.untrustedSettingsDataSource.expiredSavedAccessToken", {
    gradeNames: ["gpii.tests.untrustedSettingsDataSource"],
    members: {
        accessTokens: {
            "gpii-token-test": {
                accessToken: "a-valid-initial-access-token",
                timestampExpires: new Date(new Date().getTime() - 10 * 1000).toISOString()  // already expired 10 secs ago
            }
        }
    }
});

fluid.defaults("gpii.tests.untrustedSettingsDataSource.testCaseHolder.expiredSavedAccessToken", {
    gradeNames: "gpii.tests.untrustedSettingsDataSource.testCaseHolder",
    modules: [{
        name: "A workflow with expired saved access token: a new access token is requested, saved and used to retrive user settings",
        expect: 5,
        tests: [{
            name: "Settings received with the initial new token being fetched and saved",
            sequence: [{
                func: "gpii.tests.untrustedSettingsDataSource.assertInitialAccessToken",
                args: ["{that}", "{untrustedSettingsDataSource}", true]
            }, {
                func: "gpii.tests.oauth2.invokePromiseProducer",
                args: ["{untrustedSettingsDataSource}.get", [gpii.tests.untrustedSettingsDataSource.userToken, gpii.tests.untrustedSettingsDataSource.device], "{that}"]
            }, {
                listener: "jqUnit.assertValue",
                args: ["The user settings are received", "{arguments}.0.settings"],
                event: "{that}.events.onResponse"
            }, {
                func: "jqUnit.assertNotEquals",
                args: ["The saved access token is different from the initial saved value", "{that}.initialSavedAccessToken", "{untrustedSettingsDataSource}.accessTokens.gpii-token-test.accessToken"]
            }, {
                func: "jqUnit.assertNotEquals",
                args: ["The saved timestampExpires is different from the initial saved value", "{that}.initialSavedTimestampExpires", "{untrustedSettingsDataSource}.accessTokens.gpii-token-test.timestampExpires"]
            }]
        }]
    }]
});

fluid.defaults("gpii.tests.untrustedSettingsDataSourceTests.expiredSavedAccessToken", {
    gradeNames: ["gpii.tests.untrustedSettingsDataSourceTests"],
    settingsDataSourceGrade: "gpii.tests.untrustedSettingsDataSource.expiredSavedAccessToken",
    testCaseHolderGrade: "gpii.tests.untrustedSettingsDataSource.testCaseHolder.expiredSavedAccessToken"
});

// Shared utility functions
gpii.tests.untrustedSettingsDataSource.assertInitialAccessToken = function (that, untrustedSettingsDataSource, isExpired) {
    var initialAccessToken = fluid.get(untrustedSettingsDataSource, ["accessTokens", gpii.tests.untrustedSettingsDataSource.userToken, "accessToken"]);
    var initialTimestampExpires = fluid.get(untrustedSettingsDataSource, ["accessTokens", gpii.tests.untrustedSettingsDataSource.userToken, "timestampExpires"]);

    jqUnit.assertValue("A saved access token is in place", initialAccessToken);
    jqUnit[isExpired ? "assertTrue" : "assertFalse"]("A saved access token is not expired", gpii.oauth2.getExpiresIn(new Date(), initialTimestampExpires) === 0);
    that.initialSavedAccessToken = initialAccessToken;
    that.initialSavedTimestampExpires = initialTimestampExpires;
};

// Run all tests
fluid.test.runTests([
    "gpii.tests.untrustedSettingsDataSourceTests.noSavedAccessToken",
    "gpii.tests.untrustedSettingsDataSourceTests.validSavedAccessToken",
    "gpii.tests.untrustedSettingsDataSourceTests.expiredSavedAccessToken"
]);
