/**
 * GPII Flow Manager Update Tests
 *
 * Copyright 2013 OCAD University
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/kettle/LICENSE.txt
 */

"use strict";

var fluid = require("infusion"),
    path = require("path"),
    jqUnit = fluid.require("jqUnit"),
    configPath = path.resolve(__dirname, "./configs"),
    kettle = require("kettle"),
    gpii = fluid.registerNamespace("gpii"),
    $ = fluid.registerNamespace("jQuery");
    
kettle.loadTestingSupport();

fluid.registerNamespace("gpii.tests.flowManager.update");

gpii.tests.flowManager.update.token = "testUser1";

gpii.tests.flowManager.update.tokenDefaultPrefs = require("../../../../testData/preferences/testUser1.json");

gpii.tests.flowManager.update.tokenPrefs = $.extend(true, {}, gpii.tests.flowManager.update.tokenDefaultPrefs, {
    "http://registry.gpii.org/common/setting1": [{ value: 14 }]
});

gpii.tests.flowManager.update.tokenPrefsUpdate = {
    success: true
};

gpii.tests.flowManager.update.tokenPrefsUpdated = $.extend(true, {}, gpii.tests.flowManager.update.tokenDefaultPrefs, {
    "http://registry.gpii.org/common/setting1": [{ value: 16 }]
});

gpii.tests.flowManager.update.testLoginResponse = function (data) {
    jqUnit.assertEquals("Response is correct", "User with token " +
        gpii.tests.flowManager.update.token + " was successfully logged in.", data);
};

gpii.tests.flowManager.update.testLogoutResponse = function (data) {
    jqUnit.assertEquals("Response is correct", "User with token " +
        gpii.tests.flowManager.update.token + " was successfully logged out.", data);
};

gpii.tests.flowManager.update.testInvalidUpdateRequest = function () {
    jqUnit.assertTrue("Authorization failed as expected", true);
};

function testUpdateRequest(expected, data) {
    jqUnit.assertDeepEq("Response is correct", expected, data);
}

// TODO: These tests DO NOT EXERCISE THE UPDATE CYCLE OF THE LIFECYCLE MANAGER AT ALL!
// Since they only attempt to set settings which correspond to no solution, none of the rest of
// the lifecycle executes at all. We urgently need to either i) improve the return payload of
// the update method so that it returns something on which we can make some assertions 
// (it currently just consists of "success: true") or else ii) apply white-box testing from
// here based on the contents of the LifecycleManager's session state

gpii.tests.flowManager.update.testFirstUpdateRequest = function (data) {
    testUpdateRequest(gpii.tests.flowManager.update.tokenPrefsUpdate, data);
};

gpii.tests.flowManager.update.testSecondUpdateRequest = function (data) {
    testUpdateRequest(gpii.tests.flowManager.update.tokenPrefsUpdate, data);
};

gpii.tests.flowManager.update.clearActiveSessions = function (activeSessions) {
    delete activeSessions.testUser1;
    fluid.pushSoftFailure(function testCondition() {
        fluid.builtinFail(false, ["This failure is expected (flow manager update tests)."]);
    });
};

gpii.tests.flowManager.update.testUpdateRequestFailure = function (data) {
    jqUnit.assertTrue("Received error as expected", data.isError);
    jqUnit.assertTrue("Message is correct", data.message.indexOf("none was active") > -1);
    fluid.pushSoftFailure(-1);
};

var testDefs = [{
    name: "Flow Manager update tests",
    expect: 8,
    config: {
        configName: "update",
        configPath: configPath
    },
    components: {
        invalidUpdateRequest: {
            type: "kettle.test.request.io",
            options: {
                requestOptions: {
                    path: "/update",
                    port: "{configuration}.options.port"
                }
            }
        },
        login: {
            type: "kettle.test.request.http",
            options: {
                requestOptions: {
                    path: "/user/%token/login",
                    port: "{configuration}.options.port"
                },
                termMap: {
                    token: gpii.tests.flowManager.update.token
                }
            }
        },
        logout: {
            type: "kettle.test.request.http",
            options: {
                requestOptions: {
                    path: "/user/%token/logout",
                    port: "{configuration}.options.port"
                },
                termMap: {
                    token: gpii.tests.flowManager.update.token
                }
            }
        },
        updateRequest: {
            type: "kettle.test.request.io",
            options: {
                requestOptions: {
                    path: "/update",
                    port: "{configuration}.options.port"
                }
            }
        }
    },
    sequence: [{
        func: "{invalidUpdateRequest}.send",
        args: "You shall not pass!!"
    }, {
        event: "{invalidUpdateRequest}.events.onError",
        listener: "gpii.tests.flowManager.update.testInvalidUpdateRequest"
    }, {
        func: "{login}.send"
    }, {
        event: "{login}.events.onComplete",
        listener: "gpii.tests.flowManager.update.testLoginResponse"
    }, {
        func: "{updateRequest}.send",
        args: gpii.tests.flowManager.update.tokenPrefs
    }, {
        event: "{updateRequest}.events.onComplete",
        listener: "gpii.tests.flowManager.update.testFirstUpdateRequest"
    }, {
        func: "{updateRequest}.send",
        args: gpii.tests.flowManager.update.tokenPrefsUpdated
    }, {
        event: "{updateRequest}.events.onComplete",
        listener: "gpii.tests.flowManager.update.testSecondUpdateRequest"
    }, {
        func: "{logout}.send"
    }, {
        event: "{logout}.events.onComplete",
        listener: "gpii.tests.flowManager.update.testLogoutResponse"
    }, {
        func: "{login}.send"
    }, {
        event: "{login}.events.onComplete",
        listener: "gpii.tests.flowManager.update.testLoginResponse"
    }, {
        func: "gpii.tests.flowManager.update.clearActiveSessions",
        args: "{tests}.configuration.server.flowManager.lifecycleManager.activeSessions"
    }, {
        func: "{updateRequest}.send",
        args: gpii.tests.flowManager.update.tokenPrefs
    }, {
        event: "{updateRequest}.events.onError",
        listener: "gpii.tests.flowManager.update.testUpdateRequestFailure"
    }]
}];

module.exports = kettle.test.bootstrapServer(testDefs);
