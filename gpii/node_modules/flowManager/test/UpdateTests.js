/*
 * GPII Flow Manager Update Tests
 *
 * Copyright 2013 OCAD University
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion"),
    jqUnit = fluid.require("node-jqunit", require, "jqUnit"),
    kettle = require("kettle"),
    gpii = fluid.registerNamespace("gpii");

fluid.require("%universal");

kettle.loadTestingSupport();

fluid.registerNamespace("gpii.tests.flowManager.update");

gpii.tests.flowManager.update.userToken = "testUser1";

gpii.tests.flowManager.update.payload1 = {
    "test.dummy": {
        "settings": {
            "http://registry.gpii.net/common/fontSize": 18
        }
    }
};

gpii.tests.flowManager.update.tokenPrefsUpdate = {
    success: true
};

gpii.tests.flowManager.update.payload2 = {
    "test.dummy": {
        "settings": {
            "http://registry.gpii.net/common/magnification": 2
        }
    }
};

gpii.tests.flowManager.update.testLoginResponse = function (data) {
    jqUnit.assertEquals("Response is correct", "User with token " +
        gpii.tests.flowManager.update.userToken + " was successfully logged in.", data);
};

gpii.tests.flowManager.update.testLogoutResponse = function (data) {
    jqUnit.assertEquals("Response is correct", "User with token " +
        gpii.tests.flowManager.update.userToken + " was successfully logged out.", data);
};

function testUpdateRequest(expected, data) {
    jqUnit.assertDeepEq("Response is correct", expected, data);
}

// TODO: These tests DO NOT EXERCISE THE UPDATE CYCLE OF THE LIFECYCLE MANAGER AT ALL!
// Since they only attempt to set settings which correspond to no solution, none of the rest of
// the lifecycle executes at all. We urgently need to either i) improve the return payload of
// the update method so that it returns something on which we can make some assertions
// (it currently just consists of "success: true") or else ii) apply white-box testing from
// here based on the contents of the LifecycleManager's session state

gpii.tests.flowManager.update.testFirstUpdateRequest = function (data) {
    testUpdateRequest(gpii.tests.flowManager.update.tokenPrefsUpdate, data);
};

gpii.tests.flowManager.update.testSecondUpdateRequest = function (data) {
    testUpdateRequest(gpii.tests.flowManager.update.tokenPrefsUpdate, data);
};

gpii.tests.flowManager.update.clearActiveSessions = function (lifecycleManager) {
    var session = lifecycleManager.getSession("testUser1");
    session.destroy();
};

// Used to mock the device reporters platformReporter function to ensure test isn't dependent on OS
gpii.tests.flowManager.update.platformReporter = function () {
    return {
        id: "win32",
        version: "x86-64"
    };
};

gpii.tests.flowManager.update.testUpdateRequestFailure = function (data) {
    jqUnit.assertDeepEq("Received error response", {
        statusCode: 401,
        isError: true,
        message: "Cannot update settings with no active users"
    }, data);
};

fluid.defaults("gpii.tests.flowManager.loginRequest", {
    gradeNames: "kettle.test.request.http",
    path: "/user/%userToken/login",
    port: "{configuration}.options.mainServerPort",
    termMap: {
        userToken: gpii.tests.flowManager.update.userToken
    }
});

gpii.tests.flowManager.update.testDefs = [{
    name: "Flow Manager update tests",
    expect: 8,
    config: {
        configName: "gpii.flowManager.tests.update.config",
        configPath: "%flowManager/test/configs"
    },
    components: {
        updateRequest: {
            type: "kettle.test.request.ws",
            options: {
                path: "/update",
                port: "{configuration}.options.mainServerPort"
            }
        },
        loginRequest1: {
            type: "gpii.tests.flowManager.loginRequest"
        },
        loginRequest2: {
            type: "gpii.tests.flowManager.loginRequest"
        },
        logoutRequest: {
            type: "kettle.test.request.http",
            options: {
                path: "/user/%userToken/logout",
                port: "{configuration}.options.mainServerPort",
                termMap: {
                    userToken: gpii.tests.flowManager.update.userToken
                }
            }
        }
    },
    sequence: [{
        func: "{updateRequest}.connect"
    }, {
        event: "{updateRequest}.events.onConnect",
        listener: "jqUnit.assert",
        args: "Received WebSockets connection event"
    }, {
        func: "{updateRequest}.send",
        args: "You shall not pass!!"
    }, {
        event: "{updateRequest}.events.onReceiveMessage",
        listener: "gpii.tests.flowManager.update.testUpdateRequestFailure"
    }, {
        func: "{loginRequest1}.send"
    }, {
        event: "{loginRequest1}.events.onComplete",
        listener: "gpii.tests.flowManager.update.testLoginResponse"
    }, {
        func: "{updateRequest}.send",
        args: gpii.tests.flowManager.update.payload1
    }, {
        event: "{updateRequest}.events.onReceiveMessage",
        listener: "gpii.tests.flowManager.update.testFirstUpdateRequest"
    }, {
        func: "{updateRequest}.send",
        args: gpii.tests.flowManager.update.payload2
    }, {
        event: "{updateRequest}.events.onReceiveMessage",
        listener: "gpii.tests.flowManager.update.testSecondUpdateRequest"
    }, {
        func: "{logoutRequest}.send"
    }, {
        event: "{logoutRequest}.events.onComplete",
        listener: "gpii.tests.flowManager.update.testLogoutResponse"
    }, {
        func: "{loginRequest2}.send"
    }, {
        event: "{loginRequest2}.events.onComplete",
        listener: "gpii.tests.flowManager.update.testLoginResponse"
    }, {
        func: "gpii.tests.flowManager.update.clearActiveSessions",
        args: "{tests}.configuration.server.flowManager.lifecycleManager"
    }, {
        func: "{updateRequest}.send",
        args: gpii.tests.flowManager.update.payload1
    }, {
        event: "{updateRequest}.events.onReceiveMessage",
        listener: "gpii.tests.flowManager.update.testUpdateRequestFailure"
    }]
}];

module.exports = kettle.test.bootstrapServer(gpii.tests.flowManager.update.testDefs);
