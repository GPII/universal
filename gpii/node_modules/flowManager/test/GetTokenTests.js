/*
 * GPII Flow Manager getToken Tests
 *
 * Copyright 2014 Raising the Floor - International
 * Copyright 2013 OCAD University
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

/*global require, __dirname, module*/

var fluid = require("infusion"),
    path = require("path"),
    jqUnit = fluid.require("jqUnit"),
    configPath = path.resolve(__dirname, "./configs"),
    kettle = fluid.registerNamespace("kettle");

fluid.require("flowManager", require);
fluid.require("kettle/test/utils/js/KettleTestUtils", require);

var fmGetToken = fluid.registerNamespace("kettle.tests.flowManagerGetToken");

fmGetToken.token = "testUser1";

fmGetToken.testLoginResponse = function (data) {
    jqUnit.assertEquals("Response is correct", "User with token " +
        fmGetToken.token + " was successfully logged in.", data);
};

fmGetToken.testLogoutResponse = function (data) {
    jqUnit.assertEquals("Response is correct", "User with token " +
        fmGetToken.token + " was successfully logged out.", data);
};

fmGetToken.testInvalidGetTokenRequest = function (data) {
    data = JSON.parse(data);
    jqUnit.assertDeepEq("Expecting error messages as reply to http request", {
        isError: true,
        message: "No token(s) currently logged in to the system"
    }, data);
};

fmGetToken.testGetTokenRequest = function (data) {
    data = JSON.parse(data);
    jqUnit.assertEquals("Expecting token returned in payload", data, fmGetToken.token);
};

var testDefs = [{
    name: "Flow Manager getToken tests.",
    expect: 5,
    config: {
        nodeEnv: "getToken",
        configPath: configPath
    },
    components: {
        getTokenRequest: {
            type: "kettle.tests.request.http",
            options: {
                requestOptions: {
                    path: "/token"
                }
            }
        },
        login: {
            type: "kettle.tests.request.http",
            options: {
                requestOptions: {
                    path: "/user/%token/login"
                },
                termMap: {
                    token: fmGetToken.token
                }
            }
        },
        logout: {
            type: "kettle.tests.request.http",
            options: {
                requestOptions: {
                    path: "/user/%token/logout"
                },
                termMap: {
                    token: fmGetToken.token
                }
            }
        }
    },
    sequence: [{
        func: "{getTokenRequest}.send"
    }, {
        event: "{getTokenRequest}.events.onComplete",
        listener: "kettle.tests.flowManagerGetToken.testInvalidGetTokenRequest"
    }, {
        func: "{login}.send"
    }, {
        event: "{login}.events.onComplete",
        listener: "kettle.tests.flowManagerGetToken.testLoginResponse"
    }, {
        func: "{getTokenRequest}.send"
    }, {
        event: "{getTokenRequest}.events.onComplete",
        listener: "kettle.tests.flowManagerGetToken.testGetTokenRequest"
    }, {
        func: "{logout}.send"
    }, {
        event: "{logout}.events.onComplete",
        listener: "kettle.tests.flowManagerGetToken.testLogoutResponse"
    }, {
        func: "{getTokenRequest}.send"
    }, {
        event: "{getTokenRequest}.events.onComplete",
        listener: "kettle.tests.flowManagerGetToken.testInvalidGetTokenRequest"
    }]
}];

module.exports = kettle.tests.bootstrap(testDefs);
