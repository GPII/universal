/**
 * GPII Flow Manager Browser Channel Tests
 *
 * Copyright 2013 OCAD University
 * Copyright 2015 Emergya
 * Copyright 2015 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/kettle/LICENSE.txt
 */
"use strict";

var fluid = require("infusion"),
    jqUnit = fluid.require("node-jqunit", require, "jqUnit"),
    gpii = fluid.registerNamespace("gpii");

fluid.registerNamespace("gpii.tests.flowManager.browserChannel");

gpii.tests.flowManager.browserChannel.chromeUserToken = "chrome2";
gpii.tests.flowManager.browserChannel.firefoxUserToken = "firefox";
gpii.tests.flowManager.browserChannel.chromeAndFirefoxUserToken = "chrome_and_firefox";

gpii.tests.flowManager.browserChannel.payloads = {
    "org.chrome.cloud4chrome": {
        "screenReaderTTSEnabled": false,
        "highContrastEnabled": true,
        "invertColours": false,
        "magnifierEnabled": true,
        "magnification": 2,
        "fontSize": "medium",
        "simplifier": false,
        "highContrastTheme": "white-black"
    },
    "org.mozilla.cloud4firefox": {
        "screenReaderTTSEnabled": false,
        "highContrastEnabled": true,
        "invertColours": false,
        "magnifierEnabled": true,
        "magnification": 2,
        "fontSize": "medium",
        "simplifier": false,
        "highContrastTheme": "black-white"
    }
};

gpii.tests.flowManager.browserChannel.reportPlatform = function () {
    return {
        id: "win32",
        version: "x86-64"
    };
};

gpii.tests.flowManager.browserChannel.checkConnectionRequest = function (data, request) {
    request.events.onReceiveMessage.addListener(function (message, request) {
        fluid.log("BrowserChannel checkConnectionRequest got onReceiveMessage ", message);
        request.events[message.type].fire(message.payload);
    });
};

gpii.tests.flowManager.browserChannel.checkClients = function (spec) {
    spec = spec || {};
    fluid.each(gpii.tests.flowManager.browserChannel.payloads, function (value, key) {
        var count = spec[key] || 0;
        jqUnit.assertEquals("Count of clients of type " + key, count, Object.keys(gpii.settingsHandlers.webSockets.instance.clients[key] || {}).length);
    });
};

gpii.tests.flowManager.browserChannel.checkErrorResponse = function (data, request) {
    var expMsg = "No user logged in, so ignoring logout action.";
    data = JSON.parse(data);
    jqUnit.assertTrue("Received error as expected", data.isError);
    jqUnit.assertEquals("Received message as expected", expMsg, data.message);
    jqUnit.assertEquals("Received error code 409", 409, request.nativeResponse.statusCode);
};

gpii.tests.flowManager.browserChannel.checkPersistentSettings = function (clientId) {
    var expectedSettings = gpii.tests.flowManager.browserChannel.payloads[clientId];
    jqUnit.assertDeepEq("The settings for " + clientId + " in persistence are the expected following logon",
        expectedSettings, gpii.settingsHandlers.webSockets.instance.getSettingsForId(clientId));
};

gpii.tests.flowManager.browserChannel.loginAndSettingsChanged = function (multiArg, spec) {
    fluid.each(spec.clientIds, function (clientId) {
        var expectedSettings = gpii.tests.flowManager.browserChannel.payloads[clientId];
        gpii.tests.flowManager.browserChannel.checkPersistentSettings(clientId);
        jqUnit.assertDeepEq("The settings sent via browserChannel for " + clientId + " are the expected following logon",
            expectedSettings, multiArg[clientId][0]);
    });
    jqUnit.assertEquals("Login response is correct", "User with token " + spec.tokenId + " was successfully logged in.", multiArg.login[0]);
};

gpii.tests.flowManager.browserChannel.connectionSucceeded = function (data, solutionId) {
    // TODO: Slight risk of race condition here - this message might not arrive until settings have changed
    jqUnit.assertDeepEq("Right after connecting, the initial settings transmitted for " + solutionId  + " are as in persistence",
        gpii.settingsHandlers.webSockets.instance.getSettingsForId(solutionId),
        data
    );
};

gpii.tests.flowManager.browserChannel.checkRejectedConnection = function (data, solutionId) {
    jqUnit.assertDeepEq("An untrusted solutionId can't make use of the browserChannel", {
        isError: true,
        message: "Rejecting a connection request from '" + solutionId + "'. The solution id was not found in the solutions registry"
    }, data);
};

fluid.defaults("gpii.tests.flowManager.browserChannel.clientHolder", {
    gradeNames: "kettle.test.request.ws",
    path: "/browserChannel",
    port: "{configuration}.options.mainServerPort",
    solutionId: "",
    events: {
        onSettingsChanged: null,
        connectionSucceeded: null
    },
    listeners: {
        connectionSucceeded: {
            funcName: "gpii.tests.flowManager.browserChannel.connectionSucceeded",
            args: ["{arguments}.0", "{that}.options.solutionId"]
        }
    },
    invokers: {
        sendId: {
            func: "{that}.send",
            args: {
                type: "connect",
                payload: {
                    solutionId: "{that}.options.solutionId"
                }
            }
        }
    }
});

fluid.defaults("gpii.tests.flowManager.browserChannel.chromeClient", {
    gradeNames: "gpii.tests.flowManager.browserChannel.clientHolder",
    solutionId: "org.chrome.cloud4chrome"
});

fluid.defaults("gpii.tests.flowManager.browserChannel.firefoxClient", {
    gradeNames: "gpii.tests.flowManager.browserChannel.clientHolder",
    solutionId: "org.mozilla.cloud4firefox"
});

fluid.defaults("gpii.tests.flowManager.browserChannel.unauthorizedClient", {
    gradeNames: "gpii.tests.flowManager.browserChannel.clientHolder",
    solutionId: "com.unauthorized.app"
});

fluid.defaults("gpii.tests.flowManager.browserChannel.tokenRequest", {
    gradeNames: "kettle.test.request.http",
    termMap: {
        userToken: "{that}.options.tokenName"
    }
});

fluid.defaults("gpii.tests.flowManager.browserChannel.loginRequest", {
    gradeNames: "gpii.tests.flowManager.browserChannel.tokenRequest",
    path: "/user/%userToken/login"
});

gpii.tests.flowManager.browserChannel.testLogoutResponse = function (data, tokenName) {
    jqUnit.assertEquals("Response is correct", "User with token " + tokenName + " was successfully logged out.", data);
};

fluid.defaults("gpii.tests.flowManager.browserChannel.logoutRequest", {
    gradeNames: "gpii.tests.flowManager.browserChannel.tokenRequest",
    path: "/user/%userToken/logout",
    invokers: {
        checkResponse: {
            funcName: "gpii.tests.flowManager.browserChannel.testLogoutResponse",
            args: ["{arguments}.0", "{that}.options.tokenName"]
        }
    }
});

gpii.tests.flowManager.browserChannel.testDefs = [{
    name: "Flow Manager Simple BrowserChannel tests",
    expect: 15,
    config: {
        configName: "gpii.flowManager.tests.browserChannel.config",
        configPath: "%flowManager/test/configs"
    },
    events: {
        loginAndSettingsChangedChrome: {
            events: {
                login: "{loginChrome}.events.onComplete",
                "org.chrome.cloud4chrome": "{clientOne}.events.onSettingsChanged"
            },
            args: ["{arguments}", {
                tokenId: "{loginChrome}.options.tokenName",
                clientIds: ["org.chrome.cloud4chrome"]
            }]
        }
    },
    components: {
        clientOne: {
            type: "gpii.tests.flowManager.browserChannel.chromeClient"
        },
        loginChrome: {
            type: "gpii.tests.flowManager.browserChannel.loginRequest",
            options: {
                tokenName: "chrome2"
            }
        },
        logoutChrome1: {
            type: "gpii.tests.flowManager.browserChannel.logoutRequest",
            options: {
                tokenName: "chrome2"
            }
        },
        logoutChrome2: {
            type: "gpii.tests.flowManager.browserChannel.logoutRequest",
            options: {
                tokenName: "chrome2"
            }
        }
    },
    sequence: [{
        func: "gpii.tests.flowManager.browserChannel.checkClients"
    }, {
        func: "{clientOne}.connect"
    }, {
        event: "{clientOne}.events.onConnect",
        listener: "fluid.identity"
    }, {
        func: "{clientOne}.sendId"
    }, {
        event: "{clientOne}.events.onReceiveMessage",
        listener: "gpii.tests.flowManager.browserChannel.checkConnectionRequest"
    }, {
        func: "gpii.tests.flowManager.browserChannel.checkClients",
        args: {
            "org.chrome.cloud4chrome": 1
        }
    }, {
        func: "{loginChrome}.send"
    }, {
        event: "{testCaseHolder}.events.loginAndSettingsChangedChrome",
        listener: "gpii.tests.flowManager.browserChannel.loginAndSettingsChanged"
    }, {
        func: "{logoutChrome1}.send"
    }, {
        event: "{logoutChrome1}.events.onComplete",
        listener: "{logoutChrome1}.checkResponse"
    }, {
        func: "gpii.tests.flowManager.browserChannel.checkClients",
        args: {
            "org.chrome.cloud4chrome": 1
        }
    }, {
        func: "{clientOne}.disconnect"
    }, {
        func: "{logoutChrome2}.send"
    }, {
        event: "{logoutChrome2}.events.onComplete",
        listener: "gpii.tests.flowManager.browserChannel.checkErrorResponse"
    }, {
        func: "gpii.tests.flowManager.browserChannel.checkClients"
    }]
}, {
    name: "Flow Manager BrowserChannel tests",
    expect: 30,
    config: {
        configName: "gpii.flowManager.tests.browserChannel.config",
        configPath: "%flowManager/test/configs"
    },
    events: {
        loginAndSettingsChangedChromeAndFirefox: {
            events: {
                login: "{loginChromeAndFirefox}.events.onComplete",
                "org.chrome.cloud4chrome": "{clientTwo}.events.onSettingsChanged",
                "org.mozilla.cloud4firefox": "{clientThree}.events.onSettingsChanged"
            },
            args: ["{arguments}", {
                tokenId: "{loginChromeAndFirefox}.options.tokenName",
                clientIds: ["org.chrome.cloud4chrome", "org.mozilla.cloud4firefox"]
            }]
        }
    },
    components: {
        clientOne: {
            type: "gpii.tests.flowManager.browserChannel.chromeClient"
        },
        clientTwo: {
            type: "gpii.tests.flowManager.browserChannel.chromeClient"
        },
        clientThree: {
            type: "gpii.tests.flowManager.browserChannel.firefoxClient"
        },
        clientFour: {
            type: "gpii.tests.flowManager.browserChannel.unauthorizedClient"
        },
        clientFive: {
            type: "gpii.tests.flowManager.browserChannel.chromeClient"
        },
        loginChrome: {
            type: "gpii.tests.flowManager.browserChannel.loginRequest",
            options: {
                tokenName: "chrome2"
            }
        },
        logoutChrome1: {
            type: "gpii.tests.flowManager.browserChannel.logoutRequest",
            options: {
                tokenName: "chrome2"
            }
        },
        logoutChrome2: {
            type: "gpii.tests.flowManager.browserChannel.logoutRequest",
            options: {
                tokenName: "chrome2"
            }
        },
        logoutFirefox: {
            type: "gpii.tests.flowManager.browserChannel.logoutRequest",
            options: {
                tokenName: "firefox"
            }
        },
        loginChromeAndFirefox: {
            type: "gpii.tests.flowManager.browserChannel.loginRequest",
            options: {
                tokenName: "chrome_and_firefox"
            }
        },
        logoutChromeAndFirefox: {
            type: "gpii.tests.flowManager.browserChannel.logoutRequest",
            options: {
                tokenName: "chrome_and_firefox"
            }
        }
    },
    sequence: [{
        func: "gpii.tests.flowManager.browserChannel.checkClients"
    }, {
        func: "{clientOne}.connect"
    }, {
        event: "{clientOne}.events.onConnect",
        listener: "fluid.identity"
    }, {
        func: "{clientOne}.sendId"
    }, {
        event: "{clientOne}.events.onReceiveMessage",
        listener: "gpii.tests.flowManager.browserChannel.checkConnectionRequest"
    }, {
        func: "gpii.tests.flowManager.browserChannel.checkClients",
        args: {
            "org.chrome.cloud4chrome": 1
        }
    }, {
        func: "{clientTwo}.connect"
    }, {
        event: "{clientTwo}.events.onConnect",
        listener: "fluid.identity"
    }, {
        func: "{clientTwo}.sendId"
    }, {
        event: "{clientTwo}.events.onReceiveMessage",
        listener: "gpii.tests.flowManager.browserChannel.checkConnectionRequest"
    }, {
        func: "gpii.tests.flowManager.browserChannel.checkClients",
        args: {
            "org.chrome.cloud4chrome": 2
        }
    }, {
        func: "{clientThree}.connect"
    }, {
        event: "{clientThree}.events.onConnect",
        listener: "fluid.identity"
    }, {
        func: "{clientThree}.sendId"
    }, {
        event: "{clientThree}.events.onReceiveMessage",
        listener: "gpii.tests.flowManager.browserChannel.checkConnectionRequest"
    }, {
        func: "{clientFour}.connect"
    }, {
        event: "{clientFour}.events.onConnect",
        listener: "fluid.identity"
    }, {
        func: "{clientFour}.sendId"
    }, {
        event: "{clientFour}.events.onReceiveMessage",
        listener: "gpii.tests.flowManager.browserChannel.checkRejectedConnection",
        args: ["{arguments}.0", "{clientFour}.options.solutionId"]
    }, {
        func: "gpii.tests.flowManager.browserChannel.checkClients",
        args: {
            "org.chrome.cloud4chrome": 2,
            "org.mozilla.cloud4firefox": 1
        }
    },
    // All three clients now logged in - disconnect client 1 and try a spurious logout
    {
        func: "{clientOne}.disconnect"
    }, {
        func: "{logoutChrome1}.send"
    }, {
        event: "{logoutChrome1}.events.onComplete",
        listener: "gpii.tests.flowManager.browserChannel.checkErrorResponse"
    }, {
        func: "gpii.tests.flowManager.browserChannel.checkClients",
        args: {
            "org.chrome.cloud4chrome": 1,
            "org.mozilla.cloud4firefox": 1
        }
    },
    // Log in a user who has settings for two browsers
    {
        func: "{loginChromeAndFirefox}.send"
    }, {
        event: "{testCaseHolder}.events.loginAndSettingsChangedChromeAndFirefox",
        listener: "gpii.tests.flowManager.browserChannel.loginAndSettingsChanged"
    }, {
        func: "{logoutChromeAndFirefox}.send"
    }, {
        event: "{logoutChromeAndFirefox}.events.onComplete",
        listener: "{logoutChromeAndFirefox}.checkResponse"
    }, {
        func: "{clientTwo}.disconnect"
    }, {
        func: "{logoutFirefox}.send"
    }, {
        event: "{logoutFirefox}.events.onComplete",
        listener: "gpii.tests.flowManager.browserChannel.checkErrorResponse"
    }, {
        func: "gpii.tests.flowManager.browserChannel.checkClients",
        args: {
            "org.mozilla.cloud4firefox": 1
        }
    }, {
        func: "{clientThree}.disconnect"
    }, // At this point, zero clients are connected
    {
        func: "{loginChrome}.send"
    }, {
        event: "{loginChrome}.events.onComplete",
        listener: "gpii.tests.flowManager.browserChannel.loginAndSettingsChanged",
        args: [{ // manually construct multiArg since there is only one event
            login: ["{arguments}.0"]
        }, {
            tokenId: "{loginChrome}.options.tokenName"
        }]
    },  {
        func: "{clientFive}.connect"
    }, {
        event: "{clientFive}.events.onConnect",
        listener: "fluid.identity"
    }, {
        func: "{clientFive}.sendId"
    }, {
        event: "{clientFive}.events.onReceiveMessage",
        listener: "gpii.tests.flowManager.browserChannel.checkConnectionRequest"
    }, {
        func: "gpii.tests.flowManager.browserChannel.checkPersistentSettings",
        args: "org.chrome.cloud4chrome"
    }, {
        func: "{clientFive}.disconnect"
    }, {
        func: "{logoutChrome2}.send"
    }, {
        event: "{logoutChrome2}.events.onComplete",
        listener: "{logoutChrome2}.checkResponse"
    }, {
        func: "gpii.tests.flowManager.browserChannel.checkClients"
    }]
}];
