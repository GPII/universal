/**
 * GPII Flow Manager Browser Channel Tests
 *
 * Copyright 2013-2020 OCAD University
 * Copyright 2015 Emergya
 * Copyright 2015 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/kettle/LICENSE.txt
 */
"use strict";

var fluid = require("infusion"),
    jqUnit = fluid.require("node-jqunit", require, "jqUnit"),
    gpii = fluid.registerNamespace("gpii");

fluid.registerNamespace("gpii.tests.flowManager.browserChannel");

// TODO:  These payloads are based on the "real" solutions 'org.nvda-project'
// and 'org.gnome.orca'.  The reason for the scare-quotes is because the
// solutions are real and declared within the solutions registries used in
// production.  However, the solution registry used in these tests is a mock
// (see ./data/browserChannel_solutionsRegistry.json).
//
// The solutions should be replaced with mock solutions, and associated mock
// preferences, a mock solutions registry, and a mock device context. (Note:
// these tests currently also use a mock device reporter payload, and could
// continue to do so, but updated with new mock data.  See
// ./data/browserChannel_deviceReporter.json.
//
// As a warning: if mock solutions and mock preferences are used, and the
// preferences file is located in %gpii-universal/tests/data/preferences, then
// the preferences will not validate -- see:
// %gpii-universal/gpii/node_modules/solutionsRegistry/test/SettingsPayloadTests.js
//
// GpiiKeys and prefsSafes are generated from those test preferences
// (%gpii-universal/tests/data/preferences) and then used by the couchDB test
// harness:  It is a convenient place to put any test preferences.  The
// issue is that using mock solutions/preferences will create validation issues
// elsewhere and that will have to be addressed somehow.
gpii.tests.flowManager.browserChannel.payloads = {
    "org.nvda-project": {
        "speech.synth": "espeak",
        "speech.outputDevice": "Microsoft Sound Mapper",
        "speech.symbolLevel": 300,
        "speech.espeak.rate": 40,
        "speech.espeak.voice": "en-us",
        "speech.espeak.pitch": 60,
        "speech.espeak.volume": 80,
        "reviewCursor.followFocus": "False",
        "reviewCursor.followCaret": "True",
        "reviewCursor.followMouse": "True",
        "keyboard.speakTypedWords": "True",
        "speech.espeak.rateBoost": "True",
        "keyboard.speakTypedCharacters": "False",
        "presentation.reportHelpBalloons": "False",
        "speech.espeak.sayCapForCapitals": "True",
        "virtualBuffers.autoSayAllOnPageLoad": "False"
    },
    "org.gnome.orca": {
        "sayAllStyle": 1,
        "enableEchoByWord": 1,
        "enableEchoByCharacter": 0,
        "voices.default.rate": 102.27272727272727,
        "enableTutorialMessages": 0,
        "voices.default.family": {
            "locale": "en",
            "name": "en-westindies"
        },
        "voices.default.average-pitch": 1,
        "voices.default.gain": 7,
        "verbalizePunctuationStyle": 0
    }
};

// Modify two of the settings for 'org.nvda-project' to test set function via
// BrowserChannel.
gpii.tests.flowManager.browserChannel.nvdaSetSettings = fluid.extend(
    true, {},
    gpii.tests.flowManager.browserChannel.payloads["org.nvda-project"],
    {
        "speech.espeak.rate": 50,
        "keyboard.speakTypedCharacters": "False"
    }
);

gpii.tests.flowManager.browserChannel.reportPlatform = function () {
    return {
        id: "win32",
        version: "x86-64"
    };
};

gpii.tests.flowManager.browserChannel.checkConnectionRequest = function (data, request) {
    request.events.onReceiveMessage.addListener(function (message, request) {
        fluid.log("BrowserChannel checkConnectionRequest got onReceiveMessage ", message);
        request.events[message.type].fire(message.payload);
    });
};

gpii.tests.flowManager.browserChannel.checkClients = function (spec) {
    spec = spec || {};
    fluid.each(gpii.tests.flowManager.browserChannel.payloads, function (value, key) {
        var count = spec[key] || 0;
        jqUnit.assertEquals("Count of clients of type " + key, count, Object.keys(gpii.settingsHandlers.webSockets.instance.clients[key] || {}).length);
    });
};

gpii.tests.flowManager.browserChannel.checkErrorResponse = function (gpiiKey, data, request) {
    var expMsg = "Got logout request from user " + gpiiKey + ", but the user noUser is logged in. So ignoring the request.";
    data = JSON.parse(data);
    jqUnit.assertTrue("Received error as expected", data.isError);
    jqUnit.assertEquals("Received message as expected", expMsg, data.message);
    jqUnit.assertEquals("Received error code 409", 409, request.nativeResponse.statusCode);
};

gpii.tests.flowManager.browserChannel.checkPersistentSettings = function (clientId) {
    var expectedSettings = gpii.tests.flowManager.browserChannel.payloads[clientId];
    jqUnit.assertDeepEq("The settings for " + clientId + " in persistence are the expected following logon",
        expectedSettings, gpii.settingsHandlers.webSockets.instance.getSettingsForId(clientId));
};

gpii.tests.flowManager.browserChannel.checkSettingsAfterSet = function (responses, expectedSettings) {
    fluid.each(responses, function (settingsArray, response) {
        jqUnit.assertDeepEq(
            "The persistent settings for " + response + " are, after setting them,",
            expectedSettings, settingsArray[0]
        );
    });
};

gpii.tests.flowManager.browserChannel.loginAndSettingsChanged = function (multiArg, spec) {
    fluid.each(spec.clientIds, function (clientId) {
        var expectedSettings = gpii.tests.flowManager.browserChannel.payloads[clientId];
        gpii.tests.flowManager.browserChannel.checkPersistentSettings(clientId);
        jqUnit.assertDeepEq("The settings sent via browserChannel for " + clientId + " are the expected following logon",
            expectedSettings, multiArg[clientId][0]);
    });
    jqUnit.assertEquals("Login response is correct", "User with GPII key " + spec.gpiiKey + " was successfully logged in.", multiArg.login[0]);
};

gpii.tests.flowManager.browserChannel.connectionSucceeded = function (data, solutionId) {
    // TODO: Slight risk of race condition here - this message might not arrive until settings have changed
    jqUnit.assertDeepEq("Right after connecting, the initial settings transmitted for " + solutionId  + " are as in persistence",
        gpii.settingsHandlers.webSockets.instance.getSettingsForId(solutionId),
        data
    );
};

gpii.tests.flowManager.browserChannel.checkRejectedConnection = function (data, solutionId) {
    jqUnit.assertDeepEq("An untrusted solutionId can't make use of the browserChannel", {
        isError: true,
        message: "Rejecting a connection request from '" + solutionId + "'. The solution id was not found in the solutions registry"
    }, data);
};

fluid.defaults("gpii.tests.flowManager.browserChannel.clientHolder", {
    gradeNames: "kettle.test.request.ws",
    path: "/browserChannel",
    port: "{configuration}.options.mainServerPort",
    solutionId: "",
    settings: {},
    events: {
        onSettingsChanged: null,
        changeSettingsReceived: null,
        connectionSucceeded: null
    },
    listeners: {
        connectionSucceeded: {
            funcName: "gpii.tests.flowManager.browserChannel.connectionSucceeded",
            args: ["{arguments}.0", "{that}.options.solutionId"]
        }
    },
    invokers: {
        sendId: {
            func: "{that}.send",
            args: {
                type: "connect",
                payload: {
                    solutionId: "{that}.options.solutionId"
                }
            }
        },
        sendChangeSettings: {
            func: "{that}.send",
            args: {
                type: "changeSettings",
                payload: {
                    settings: "{that}.options.settings"
                }
            }
        }
    }
});

fluid.defaults("gpii.tests.flowManager.browserChannel.chromeClient", {
    gradeNames: "gpii.tests.flowManager.browserChannel.clientHolder",
    solutionId: "org.nvda-project",
    settings: gpii.tests.flowManager.browserChannel.nvdaSetSettings
});

fluid.defaults("gpii.tests.flowManager.browserChannel.firefoxClient", {
    gradeNames: "gpii.tests.flowManager.browserChannel.clientHolder",
    solutionId: "org.gnome.orca"
});

fluid.defaults("gpii.tests.flowManager.browserChannel.unauthorizedClient", {
    gradeNames: "gpii.tests.flowManager.browserChannel.clientHolder",
    solutionId: "com.unauthorized.app"
});

fluid.defaults("gpii.tests.flowManager.browserChannel.gpiiKeyRequest", {
    gradeNames: "kettle.test.request.http",
    termMap: {
        gpiiKey: "{that}.options.gpiiKey"
    }
});

fluid.defaults("gpii.tests.flowManager.browserChannel.loginRequest", {
    gradeNames: "gpii.tests.flowManager.browserChannel.gpiiKeyRequest",
    path: "/user/%gpiiKey/login"
});

gpii.tests.flowManager.browserChannel.testLogoutResponse = function (data, gpiiKey) {
    jqUnit.assertEquals("Response is correct", "User with GPII key " + gpiiKey + " was successfully logged out.", data);
};

fluid.defaults("gpii.tests.flowManager.browserChannel.logoutRequest", {
    gradeNames: "gpii.tests.flowManager.browserChannel.gpiiKeyRequest",
    path: "/user/%gpiiKey/logout",
    invokers: {
        checkResponse: {
            funcName: "gpii.tests.flowManager.browserChannel.testLogoutResponse",
            args: ["{arguments}.0", "{that}.options.gpiiKey"]
        }
    }
});

gpii.tests.flowManager.browserChannel.testDefs = [{
    name: "Flow Manager Simple BrowserChannel tests",
    expect: 15,
    config: {
        configName: "gpii.flowManager.tests.browserChannel.config",
        configPath: "%flowManager/test/configs"
    },
    events: {
        loginAndSettingsChangedNvda: {
            events: {
                login: "{loginNvda}.events.onComplete",
                "org.nvda-project": "{clientOne}.events.onSettingsChanged"
            },
            args: ["{arguments}", {
                gpiiKey: "{loginNvda}.options.gpiiKey",
                clientIds: ["org.nvda-project"]
            }]
        }
    },
    components: {
        clientOne: {
            type: "gpii.tests.flowManager.browserChannel.chromeClient"
        },
        loginNvda: {
            type: "gpii.tests.flowManager.browserChannel.loginRequest",
            options: {
                gpiiKey: "screenreader_nvda"
            }
        },
        logoutNvda1: {
            type: "gpii.tests.flowManager.browserChannel.logoutRequest",
            options: {
                gpiiKey: "screenreader_nvda"
            }
        },
        logoutNvda2: {
            type: "gpii.tests.flowManager.browserChannel.logoutRequest",
            options: {
                gpiiKey: "screenreader_nvda"
            }
        }
    },
    sequence: [{
        func: "gpii.tests.flowManager.browserChannel.checkClients"
    }, {
        func: "{clientOne}.connect" // chromeClient (org.nvda-project)
    }, {
        event: "{clientOne}.events.onConnect",
        listener: "fluid.identity"
    }, {
        func: "{clientOne}.sendId"
    }, {
        event: "{clientOne}.events.onReceiveMessage",
        listener: "gpii.tests.flowManager.browserChannel.checkConnectionRequest"
    }, {
        func: "gpii.tests.flowManager.browserChannel.checkClients",
        args: {
            "org.nvda-project": 1
        }
    }, {
        func: "{loginNvda}.send"
    }, {
        event: "{testCaseHolder}.events.loginAndSettingsChangedNvda",
        listener: "gpii.tests.flowManager.browserChannel.loginAndSettingsChanged"
    }, {
        func: "{logoutNvda1}.send"
    }, {
        event: "{logoutNvda1}.events.onComplete",
        listener: "{logoutNvda1}.checkResponse"
    }, {
        func: "gpii.tests.flowManager.browserChannel.checkClients",
        args: {
            "org.nvda-project": 1
        }
    }, {
        func: "{clientOne}.disconnect"
    }, {
        func: "{logoutNvda2}.send"
    }, {
        event: "{logoutNvda2}.events.onComplete",
        listener: "gpii.tests.flowManager.browserChannel.checkErrorResponse",
        args: ["screenreader_nvda", "{arguments}.0", "{arguments}.1"]
    }, {
        func: "gpii.tests.flowManager.browserChannel.checkClients"
    }]
}, {
    name: "Flow Manager BrowserChannel tests",
    expect: 32,
    config: {
        configName: "gpii.flowManager.tests.browserChannel.config",
        configPath: "%flowManager/test/configs"
    },
    events: {
        loginAndSettingsChangedChromeAndFirefox: {
            events: {
                login: "{loginChromeAndFirefox}.events.onComplete",
                "org.nvda-project": "{clientTwo}.events.onSettingsChanged",
                "org.gnome.orca": "{clientThree}.events.onSettingsChanged"
            },
            args: ["{arguments}", {
                gpiiKey: "{loginChromeAndFirefox}.options.gpiiKey",
                clientIds: ["org.nvda-project", "org.gnome.orca"]
            }]
        },
        clientOneChangeSettings: {
            events: {
                "clientOneChangeReceipt": "{clientOne}.events.changeSettingsReceived",
                "clientTwoSettingsChanged": "{clientTwo}.events.onSettingsChanged"
            },
            args: ["{arguments}", "{clientOne}.options.settings"]
        }
    },
    components: {
        clientOne: {
            type: "gpii.tests.flowManager.browserChannel.chromeClient"
        },
        clientTwo: {
            type: "gpii.tests.flowManager.browserChannel.chromeClient"
        },
        clientThree: {
            type: "gpii.tests.flowManager.browserChannel.firefoxClient"
        },
        clientFour: {
            type: "gpii.tests.flowManager.browserChannel.unauthorizedClient"
        },
        clientFive: {
            type: "gpii.tests.flowManager.browserChannel.chromeClient"
        },
        loginNvda: {
            type: "gpii.tests.flowManager.browserChannel.loginRequest",
            options: {
                gpiiKey: "screenreader_nvda"
            }
        },
        logoutNvda1: {
            type: "gpii.tests.flowManager.browserChannel.logoutRequest",
            options: {
                gpiiKey: "Nvda1"
            }
        },
        logoutNvda2: {
            type: "gpii.tests.flowManager.browserChannel.logoutRequest",
            options: {
                gpiiKey: "screenreader_nvda"
            }
        },
        logoutOrca: {
            type: "gpii.tests.flowManager.browserChannel.logoutRequest",
            options: {
                gpiiKey: "screenreader_orca"
            }
        },
        loginChromeAndFirefox: {
            type: "gpii.tests.flowManager.browserChannel.loginRequest",
            options: {
                gpiiKey: "nvda_and_orca"
            }
        },
        logoutChromeAndFirefox: {
            type: "gpii.tests.flowManager.browserChannel.logoutRequest",
            options: {
                gpiiKey: "nvda_and_orca"
            }
        }
    },
    sequence: [{
        func: "gpii.tests.flowManager.browserChannel.checkClients"
    }, {
        func: "{clientOne}.connect"
    }, {
        event: "{clientOne}.events.onConnect",
        listener: "fluid.identity"
    }, {
        func: "{clientOne}.sendId"
    }, {
        event: "{clientOne}.events.onReceiveMessage",
        listener: "gpii.tests.flowManager.browserChannel.checkConnectionRequest"
    }, {
        func: "gpii.tests.flowManager.browserChannel.checkClients",
        args: {
            "org.nvda-project": 1
        }
    }, {
        func: "{clientTwo}.connect"
    }, {
        event: "{clientTwo}.events.onConnect",
        listener: "fluid.identity"
    }, {
        func: "{clientTwo}.sendId"
    }, {
        event: "{clientTwo}.events.onReceiveMessage",
        listener: "gpii.tests.flowManager.browserChannel.checkConnectionRequest"
    }, {
        func: "gpii.tests.flowManager.browserChannel.checkClients",
        args: {
            "org.nvda-project": 2
        }
    }, {
        func: "{clientThree}.connect"
    }, {
        event: "{clientThree}.events.onConnect",
        listener: "fluid.identity"
    }, {
        func: "{clientThree}.sendId"
    }, {
        event: "{clientThree}.events.onReceiveMessage",
        listener: "gpii.tests.flowManager.browserChannel.checkConnectionRequest"
    }, {
        func: "{clientFour}.connect"
    }, {
        event: "{clientFour}.events.onConnect",
        listener: "fluid.identity"
    }, {
        func: "{clientFour}.sendId"
    }, {
        event: "{clientFour}.events.onReceiveMessage",
        listener: "gpii.tests.flowManager.browserChannel.checkRejectedConnection",
        args: ["{arguments}.0", "{clientFour}.options.solutionId"]
    }, {
        func: "gpii.tests.flowManager.browserChannel.checkClients",
        args: {
            "org.nvda-project": 2,
            "org.gnome.orca": 1
        }
    },
    // All three clients now connected - clientOne sends a "changeSettings"
    // request and gets back a receipt, whereas clientTwo receives the changes.
    {
        func: "{clientOne}.sendChangeSettings"
    },
    {
        event: "{testCaseHolder}.events.clientOneChangeSettings",
        listener: "gpii.tests.flowManager.browserChannel.checkSettingsAfterSet"
    },
    // Disconnect client 1 and try a spurious logout
    {
        func: "{clientOne}.disconnect"
    }, {
        func: "{logoutNvda1}.send"
    }, {
        event: "{logoutNvda1}.events.onComplete",
        listener: "gpii.tests.flowManager.browserChannel.checkErrorResponse",
        args: ["Nvda1", "{arguments}.0", "{arguments}.1"]
    }, {
        func: "gpii.tests.flowManager.browserChannel.checkClients",
        args: {
            "org.nvda-project": 1,
            "org.gnome.orca": 1
        }
    },
    // Log in a user who has settings for two browsers
    {
        func: "{loginChromeAndFirefox}.send"
    }, {
        event: "{testCaseHolder}.events.loginAndSettingsChangedChromeAndFirefox",
        listener: "gpii.tests.flowManager.browserChannel.loginAndSettingsChanged"
    }, {
        func: "{logoutChromeAndFirefox}.send"
    }, {
        event: "{logoutChromeAndFirefox}.events.onComplete",
        listener: "{logoutChromeAndFirefox}.checkResponse"
    }, {
        func: "{clientTwo}.disconnect"
    }, {
        func: "{logoutOrca}.send"
    }, {
        event: "{logoutOrca}.events.onComplete",
        listener: "gpii.tests.flowManager.browserChannel.checkErrorResponse",
        args: ["screenreader_orca", "{arguments}.0", "{arguments}.1"]
    }, {
        func: "gpii.tests.flowManager.browserChannel.checkClients",
        args: {
            "org.gnome.orca": 1
        }
    }, {
        func: "{clientThree}.disconnect"
    }, // At this point, zero clients are connected
    {
        func: "{loginNvda}.send"
    }, {
        event: "{loginNvda}.events.onComplete",
        listener: "gpii.tests.flowManager.browserChannel.loginAndSettingsChanged",
        args: [{ // manually construct multiArg since there is only one event
            login: ["{arguments}.0"]
        }, {
            gpiiKey: "{loginNvda}.options.gpiiKey"
        }]
    },  {
        func: "{clientFive}.connect"
    }, {
        event: "{clientFive}.events.onConnect",
        listener: "fluid.identity"
    }, {
        func: "{clientFive}.sendId"
    }, {
        event: "{clientFive}.events.onReceiveMessage",
        listener: "gpii.tests.flowManager.browserChannel.checkConnectionRequest"
    }, {
        func: "gpii.tests.flowManager.browserChannel.checkPersistentSettings",
        args: "org.nvda-project"
    }, {
        func: "{clientFive}.disconnect"
    }, {
        func: "{logoutNvda2}.send"
    }, {
        event: "{logoutNvda2}.events.onComplete",
        listener: "{logoutNvda2}.checkResponse"
    }, {
        func: "gpii.tests.flowManager.browserChannel.checkClients"
    }]
}];
