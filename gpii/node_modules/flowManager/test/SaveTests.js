/**
 * GPII Flow Manager Save Tests
 *
 * Copyright 2013 OCAD University
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/kettle/LICENSE.txt
 */

/*global __dirname*/

"use strict";

var fluid = require("infusion"),
    path = require("path"),
    jqUnit = fluid.require("jqUnit"),
    configPath = path.resolve(__dirname, "./configs"),
    kettle = require("kettle"),
    gpii = fluid.registerNamespace("gpii"),
    fs = require("fs");

kettle.loadTestingSupport();

fluid.registerNamespace("gpii.tests.userSave");

fluid.require("ontologyHandler", require);
fluid.require("matchMakerFramework", require);
fluid.require("contextManager", require);
fluid.require("transformer", require);

gpii.tests.userSave.testToken1 = "testToken1";
gpii.tests.userSave.prefsDir = path.resolve(__dirname, "../../../../testData/preferences/");
gpii.tests.userSave.testToken1Set = {
    test: "test"
};

gpii.tests.userSave.filesToDelete = [];

gpii.tests.userSave.cleanUpTmpFiles = function () {
    fluid.each(gpii.tests.userSave.filesToDelete, function (filePath) {
        fs.unlinkSync(filePath);
    });
    gpii.tests.userSave.filesToDelete.length = 0;
};

gpii.tests.userSave.testSaveResponse = function (dataText) {
    var data = JSON.parse(dataText);
    var filePath = path.resolve(gpii.tests.userSave.prefsDir, data.userToken) + ".json";
    gpii.tests.userSave.filesToDelete.push(filePath);
    jqUnit.assertDeepEq("Response is correct", gpii.tests.userSave.testToken1Set, data.preferences);
    var savedPrefs = require(filePath);
    jqUnit.assertDeepEq("Saved preferences are correct", gpii.tests.userSave.testToken1Set,
        savedPrefs.flat);
};

gpii.tests.userSave.triggerFailure = function () {
    fluid.builtinFail(false, ["This failure is expected (flow manager save tests)"]);
};

gpii.tests.userSave.testBadResponse = function (data) {
    data = JSON.parse(data);
    jqUnit.assertTrue("Received error as expected", data.isError);
    jqUnit.assertTrue("Message is correct",
        data.message.indexOf("This failure is expected") > -1);
};

fluid.defaults("gpii.tests.userSave.failingDataSource", {
    gradeNames: ["autoInit", "fluid.littleComponent"],
    invokers: {
        set: {
            funcName: "gpii.tests.userSave.failingDataSource.set"
        }
    }
});

gpii.tests.userSave.failingDataSource.set = function () {
    // This method is made asynchronous on purpose, to try to evade the
    // exception handler inside route.js in connect.
    process.nextTick(kettle.wrapCallback(gpii.tests.userSave.triggerFailure));
    return fluid.promise();
};

gpii.tests.userSave.pushInstrumentedErrors = function () {
    // Restore Kettle's default uncaught exception handler (beating jqUnit's) so that we can test it
    fluid.onUncaughtException.addListener(kettle.requestUncaughtExceptionHandler, "fail", null,
        fluid.handlerPriorities.uncaughtException.fail);
};

gpii.tests.userSave.popInstrumentedErrors = function () {
    // restore jqUnit's exception handler for the next test
    fluid.onUncaughtException.removeListener("fail");
};


fluid.defaults("gpii.tests.userSave.rejectedPromise", {
    gradeNames: ["autoInit", "fluid.littleComponent"],
    invokers: {
        set: {
            funcName: "gpii.tests.userSave.rejectedPromise.set"
        }
    }
});

gpii.tests.userSave.rejectedPromise.set = function () {
    var promise = fluid.promise();
    promise.reject({
        isError: true,
        message: "this is a failure"
    });
    return promise;
};

gpii.tests.userSave.testRejectedResponse = function (request) {
    return function (data) {
        data = JSON.parse(data);
        jqUnit.assertTrue("Received error as expected", data.isError);
        jqUnit.assertEquals("Received message as expected", "this is a failure", data.message);
        jqUnit.assertEquals("Received error code 500", 500, request.nativeResponse.statusCode);
    };
};


var testDefs = [{
    name: "Flow Manager save tests",
    expect: 4,
    config: {
        configName: "save",
        configPath: configPath
    },
    listeners: {
        onDestroy: "gpii.tests.userSave.cleanUpTmpFiles"
    },
    components: {
        saveRequest: { // TODO: this test is faulty - a PUT should be supplied for an existing user token
            type: "kettle.test.request.http",
            options: {
                requestOptions: {
                    port: "{configuration}.options.savePort", // TODO: We would like to remove this duplication, it depends on FLUID-5495
                    path: "/user/preferences/%userToken",
                    method: "PUT"
                },
                termMap: {
                    userToken: gpii.tests.userSave.testToken1
                }
            }
        },
        saveRequestNoToken: {
            type: "kettle.test.request.http",
            options: {
                requestOptions: {
                    port: "{configuration}.options.savePort",
                    path: "/user/preferences",
                    method: "POST"
                }
            }
        }
    },
    sequence: [{
        func: "{saveRequest}.send",
        args: gpii.tests.userSave.testToken1Set
    }, {
        event: "{saveRequest}.events.onComplete",
        listener: "gpii.tests.userSave.testSaveResponse"
    }, {
        func: "{saveRequestNoToken}.send",
        args: gpii.tests.userSave.testToken1Set
    }, {
        event: "{saveRequestNoToken}.events.onComplete",
        listener: "gpii.tests.userSave.testSaveResponse"
    }]
}, {
    name: "Flow Manager failed save tests",
    expect: 2,
    config: {
        configName: "save",
        configPath: configPath
    },
    listeners: {
        onDestroy: gpii.tests.userSave.cleanUpTmpFiles
    },
    distributeOptions: {
        source: "{that}.options.preferencesDataSourceGradeNames",
        target: "{that preferencesDataSource}.options.gradeNames"
    },
    preferencesDataSourceGradeNames: ["gpii.tests.userSave.failingDataSource"],
    components: {
        failRequest: {
            type: "kettle.test.request.http",
            options: {
                requestOptions: {
                    port: "{configuration}.options.savePort",
                    path: "/user/preferences",
                    method: "POST"
                }
            }
        }
    },
    sequence: [{
        funcName: "gpii.tests.userSave.pushInstrumentedErrors"
    }, {
        func: "{failRequest}.send"
    }, {
        event: "{failRequest}.events.onComplete",
        listener: "gpii.tests.userSave.testBadResponse"
    }, {
        func: "gpii.tests.userSave.popInstrumentedErrors"
    }]
}, {
    name: "PreferencesDataSource promise rejection",
    expect: 3,
    config: {
        configName: "save",
        configPath: configPath
    },
    listeners: {
        onDestroy: gpii.tests.userSave.cleanUpTmpFiles
    },
    distributeOptions: {
        source: "{that}.options.preferencesDataSourceGradeNames",
        target: "{that preferencesDataSource}.options.gradeNames"
    },
    preferencesDataSourceGradeNames: ["gpii.tests.userSave.rejectedPromise"],
    components: {
        failRequest: {
            type: "kettle.test.request.http",
            options: {
                requestOptions: {
                    port: "{configuration}.options.savePort",
                    path: "/user/preferences",
                    method: "POST"
                }
            }
        }
    },
    sequence: [{
        func: "{failRequest}.send"
    }, {
        event: "{failRequest}.events.onComplete",
        listenerMaker: "gpii.tests.userSave.testRejectedResponse",
        makerArgs: [ "{failRequest}" ]
    }]
}];

module.exports = kettle.test.bootstrapServer(testDefs);
