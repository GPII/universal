/**
 * GPII Flow Manager Save Tests
 *
 * Copyright 2013 OCAD University
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/kettle/LICENSE.txt
 */

/*global __dirname*/

"use strict";

var fluid = require("infusion"),
    path = require("path"),
    jqUnit = fluid.require("jqUnit"),
    configPath = path.resolve(__dirname, "./configs"),
    kettle = fluid.registerNamespace("kettle"),
    gpii = fluid.registerNamespace("gpii"),
    fs = require("fs");

fluid.require("kettle/test/utils/js/KettleTestUtils", require);
fluid.require("ontologyHandler", require);

fluid.registerNamespace("gpii.tests.userSave");

gpii.tests.userSave.testToken1 = "testToken1";
gpii.tests.userSave.prefsDir = path.resolve(__dirname, "../../../../testData/preferences/");
gpii.tests.userSave.testToken1Set = {
    test: "test"
};

gpii.tests.userSave.filesToDelete = [];

gpii.tests.userSave.cleanUpTmpFiles = function () {
    fluid.each(gpii.tests.userSave.filesToDelete, function (filePath) {
        fs.unlinkSync(filePath);
    });
    gpii.tests.userSave.filesToDelete.length = 0;
};

gpii.tests.userSave.testSaveResponse = function (dataText) {
    var data = JSON.parse(dataText);
    var filePath = path.resolve(gpii.tests.userSave.prefsDir, data.token) + ".json";
    gpii.tests.userSave.filesToDelete.push(filePath);
    jqUnit.assertDeepEq("Response is correct", gpii.tests.userSave.testToken1Set,
        data.preferences);
    var savedPrefs = require(filePath);
    jqUnit.assertDeepEq("Saved preferences are correct",
        gpii.tests.userSave.testToken1Set, savedPrefs.flat);
};

// function testCondition() {
//     fluid.builtinFail(false, ["This failure is expected."]);
// }
gpii.tests.userSave.triggerFailure = function () {
    fluid.builtinFail(false, ["This failure is expected (flow manager save tests)"]);
};

gpii.tests.userSave.testBadResponse = function (data) {
    data = JSON.parse(data);
    jqUnit.assertTrue("Received error as expected", data.isError);
    jqUnit.assertTrue("Message is correct",
        data.message.indexOf("This failure is expected") > -1);
};

fluid.defaults("gpii.tests.userSave.failingDataSource", {
    gradeNames: ["autoInit", "fluid.littleComponent"],
    invokers: {
        set: {
            funcName: "gpii.tests.userSave.failingDataSource.set"
        }
    }
});

gpii.tests.userSave.failingDataSource.set = function () {
    // This method is made asynchronous on purpose, to try to evade the
    // exception handler inside route.js in connect.
    process.nextTick(kettle.wrapCallback(gpii.tests.userSave.triggerFailure));
};

// kettle.test.failingDataSource.set = function (callbackWrapper) {
//     // This method is made asynchronous on purpose, to try to evade the
//     // exception handler inside route.js in connect.
//     process.nextTick(kettle.wrapCallback(testCondition));
// };

gpii.tests.userSave.pushInstrumentedErrors = function () {
    // Restore Kettle's default uncaught exception handler (beating jqUnit's) so that we can test it
    fluid.onUncaughtException.addListener(kettle.requestUncaughtExceptionHandler, "fail", null,
        fluid.handlerPriorities.uncaughtException.fail);
};

gpii.tests.userSave.popInstrumentedErrors = function () {
    // restore jqUnit's exception handler for the next test
    fluid.onUncaughtException.removeListener("fail");
};

var testDefs = [{
    name: "Flow Manager PUT tests.",
    expect: 2,
    config: {
        configName: "save",
        configPath: configPath
    },
    listeners: {
        onDestroy: gpii.tests.userSave.cleanUpTmpFiles
    },
    components: {
        saveRequest: {
            type: "kettle.test.request.http",
            options: {
                requestOptions: {
                    port: "{configuration}.options.savePort",
                    path: "/save/%token",
                    method: "PUT"

                },
                termMap: {
                    token: gpii.tests.userSave.testToken1
                }
            }
        }
    },
    sequence: [{
        func: "{saveRequest}.send",
        args: gpii.tests.userSave.testToken1Set
    }, {
        event: "{saveRequest}.events.onComplete",
        listener: "gpii.tests.userSave.testSaveResponse"
    }]
}, {
    name: "Flow Manager save POST tests.",
    expect: 2,
    config: {
        configName: "save",
        configPath: configPath
    },
    listeners: {
        onDestroy: gpii.tests.userSave.cleanUpTmpFiles
    },
    components: {
        saveRequestNoToken: {
            type: "kettle.test.request.http",
            options: {
                requestOptions: {
                    port: "{configuration}.options.savePort",
                    path: "/save",
                    method: "POST"
                }
            }
        }
    },
    sequence: [{
        func: "{saveRequestNoToken}.send",
        args: gpii.tests.userSave.testToken1Set
    }, {
        event: "{saveRequestNoToken}.events.onComplete",
        listener: "gpii.tests.userSave.testSaveResponse"
    }]
// }, {
    // name: "Flow Manager save PUT to existing file test.",
    // expect: 2,
    // config: {
    //     configName: "save",
    //     configPath: configPath
    // },
    // listeners: {
    //     onDestroy: gpii.tests.userSave.cleanUpTmpFiles
    // },
    // components: {
    //     saveRequestNoToken: {
    //         type: "kettle.test.request.http",
    //         options: {
    //             requestOptions: {
    //                 port: "{configuration}.options.savePort",
    //                 path: "/save",
    //                 method: "POST"
    //             }
    //         }
    //     }
    // },
    // sequence: [{
    //     func: "{saveRequestNoToken}.send",
    //     args: gpii.tests.userSave.testToken1Set
    // }, {
    //     event: "{saveRequestNoToken}.events.onComplete",
    //     listener: "gpii.tests.userSave.testSaveResponse"
    // }]
// }, {
//     name: "Flow Manager failed save tests.",
//     expect: 2,
//     config: {
//         configName: "save",
//         configPath: configPath
//     },
//     distributeOptions: {
//         source: "{that}.options.preferencesDataSourceGradeNames",
//         target: "{that preferencesDataSource}.options.gradeNames"
//     },
//     preferencesDataSourceGradeNames: ["gpii.tests.userSave.failingDataSource"],
//     components: {
//         failRequest: {
//             type: "kettle.test.request.http",
//             options: {
//                 requestOptions: {
//                     port: "{configuration}.options.savePort",
//                     path: "/save",
//                     method: "POST"
//                 }
//             }
//         }
//     },
//     sequence: [{
//         funcName: "gpii.tests.userSave.pushInstrumentedErrors"
//     }, {
//         func: "{failRequest}.send"
//     }, {
//         event: "{failRequest}.events.onComplete",
//         listener: "gpii.tests.userSave.testBadResponse"
//     }, {
//         func: "gpii.tests.userSave.popInstrumentedErrors"
//     }]
}];

module.exports = kettle.test.bootstrapServer(testDefs);
