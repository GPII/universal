/*
 * GPII Flow Manager Save Preferences Tests
 *
 * Copyright 2013 OCAD University
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion"),
    jqUnit = fluid.require("node-jqunit", require, "jqUnit"),
    kettle = require("kettle"),
    gpii = fluid.registerNamespace("gpii"),
    fs = require("fs");

fluid.require("%universal");

kettle.loadTestingSupport();

fluid.registerNamespace("gpii.tests.flowManager.savePrefs");

gpii.tests.flowManager.savePrefs.configRecord = {
    configName: "gpii.flowManager.tests.save.config",
    configPath: "%flowManager/test/configs"
};

gpii.tests.flowManager.savePrefs.testToken1 = "testToken1";
gpii.tests.flowManager.savePrefs.prefsDir = fluid.module.resolvePath("%universal/testData/preferences/");
gpii.tests.flowManager.savePrefs.testToken1Set = {
    test: "test"
};

gpii.tests.flowManager.savePrefs.filesToDelete = [];

gpii.tests.flowManager.savePrefs.cleanUpTmpFiles = function () {
    fluid.each(gpii.tests.flowManager.savePrefs.filesToDelete, function (filePath) {
        fs.unlinkSync(filePath);
    });
    gpii.tests.flowManager.savePrefs.filesToDelete.length = 0;
};

gpii.tests.flowManager.savePrefs.testSaveResponse = function (dataText) {
    var data = JSON.parse(dataText);
    var filePath = gpii.tests.flowManager.savePrefs.prefsDir + data.userToken + ".json";
    gpii.tests.flowManager.savePrefs.filesToDelete.push(filePath);
    jqUnit.assertDeepEq("Response is correct", gpii.tests.flowManager.savePrefs.testToken1Set, data.preferences);
    var savedPrefs = require(filePath);
    jqUnit.assertDeepEq("Saved preferences are correct", gpii.tests.flowManager.savePrefs.testToken1Set,
        savedPrefs.flat);
};

gpii.tests.flowManager.savePrefs.triggerFailure = function () {
    fluid.builtinFail(["This failure is expected (flow manager save tests)"]);
};

fluid.defaults("gpii.tests.flowManager.savePrefs.failingDataSource", {
    gradeNames: ["fluid.component"],
    readOnlyGrade: "gpii.tests.flowManager.savePrefs.failingDataSource",
    invokers: {
        set: {
            funcName: "gpii.tests.flowManager.savePrefs.failingDataSource.set"
        }
    }
});

gpii.tests.flowManager.savePrefs.failingDataSource.set = function () {
    var wrapped = kettle.wrapCallback(gpii.tests.flowManager.savePrefs.triggerFailure);
    // This method is made asynchronous on purpose, to try to evade the
    // exception handler inside route.js in connect.
    process.nextTick(wrapped);
    return fluid.promise();
};

fluid.defaults("gpii.tests.flowManager.savePrefs.rejectedPromise", {
    gradeNames: ["fluid.component"],
    invokers: {
        set: {
            funcName: "gpii.tests.flowManager.savePrefs.rejectedPromise.set"
        }
    }
});

gpii.tests.flowManager.savePrefs.rejectedPromise.set = function () {
    var promise = fluid.promise();
    promise.reject({
        isError: true,
        message: "this is a failure"
    });
    return promise;
};


gpii.tests.flowManager.savePrefs.testDefs = [{
    name: "Flow Manager save tests",
    expect: 4,
    config: gpii.tests.flowManager.savePrefs.configRecord,
    listeners: {
        onDestroy: "gpii.tests.flowManager.savePrefs.cleanUpTmpFiles"
    },
    components: {
        saveRequest: { // TODO: this test is faulty - a PUT should be supplied for an existing user token
            type: "kettle.test.request.http",
            options: {
                port: "{configuration}.options.mainServerPort", // TODO: We would like to remove this duplication, it depends on FLUID-5495
                path: "/user/preferences/%userToken",
                method: "PUT",
                termMap: {
                    userToken: gpii.tests.flowManager.savePrefs.testToken1
                }
            }
        },
        saveRequestNoToken: {
            type: "kettle.test.request.http",
            options: {
                port: "{configuration}.options.mainServerPort",
                path: "/user/preferences",
                method: "POST"
            }
        }
    },
    sequence: [{
        func: "{saveRequest}.send",
        args: gpii.tests.flowManager.savePrefs.testToken1Set
    }, {
        event: "{saveRequest}.events.onComplete",
        listener: "gpii.tests.flowManager.savePrefs.testSaveResponse"
    }, {
        func: "{saveRequestNoToken}.send",
        args: gpii.tests.flowManager.savePrefs.testToken1Set
    }, {
        event: "{saveRequestNoToken}.events.onComplete",
        listener: "gpii.tests.flowManager.savePrefs.testSaveResponse"
    }]
}, {
    name: "Flow Manager failed save tests",
    expect: 3,
    config: gpii.tests.flowManager.savePrefs.configRecord,
    listeners: {
        onDestroy: gpii.tests.flowManager.savePrefs.cleanUpTmpFiles
    },
    distributeOptions: {
        record: "gpii.tests.flowManager.savePrefs.failingDataSource",
        target: "{that preferencesDataSource}.type",
        priority: "after:flowManager.development.prefs"
    },
    components: {
        failRequest: {
            type: "kettle.test.request.http",
            options: {
                port: "{configuration}.options.mainServerPort",
                path: "/user/preferences",
                method: "POST"
            }
        }
    },
    sequence: [{
        funcName: "kettle.test.pushInstrumentedErrors",
        args: "kettle.requestUncaughtExceptionHandler"
    }, {
        func: "{failRequest}.send"
    }, {
        event: "{failRequest}.events.onComplete",
        listener: "kettle.test.assertErrorResponse",
        args: {
            message: "Received request error from deferred failure",
            errorTexts: "This failure is expected",
            string: "{arguments}.0",
            request: "{failRequest}"
        }
    }, {
        func: "kettle.test.popInstrumentedErrors"
    }]
}, {
    name: "PreferencesDataSource promise rejection",
    expect: 2,
    config: gpii.tests.flowManager.savePrefs.configRecord,
    listeners: {
        onDestroy: gpii.tests.flowManager.savePrefs.cleanUpTmpFiles
    },
    distributeOptions: {
        record: "gpii.tests.flowManager.savePrefs.rejectedPromise",
        target: "{that preferencesDataSource}.type",
        priority: "after:flowManager.development.prefs"
    },
    components: {
        failRequest: {
            type: "kettle.test.request.http",
            options: {
                port: "{configuration}.options.mainServerPort",
                path: "/user/preferences",
                method: "POST"
            }
        }
    },
    sequence: [{
        func: "{failRequest}.send"
    }, {
        event: "{failRequest}.events.onComplete",
        listener: "kettle.test.assertJSONResponse",
        args: {
            message: "Received request error from rejected promise",
            expected: {
                isError: true,
                message: "this is a failure"
            },
            statusCode: 500,
            string: "{arguments}.0",
            request: "{failRequest}"
        }
    }]
}];


module.exports = kettle.test.bootstrapServer(gpii.tests.flowManager.savePrefs.testDefs);
