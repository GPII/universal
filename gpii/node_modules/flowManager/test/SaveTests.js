/**
 * GPII Flow Manager Save Tests
 *
 * Copyright 2013 OCAD University
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/kettle/LICENSE.txt
 */

/*global __dirname*/

"use strict";

var fluid = require("infusion"),
    path = require("path"),
    jqUnit = fluid.require("jqUnit"),
    configPath = path.resolve(__dirname, "./configs"),
    kettle = fluid.registerNamespace("kettle"),
    fs = require("fs");

fluid.require("kettle/test/utils/js/KettleTestUtils", require);
fluid.require("ontologyHandler", require);

kettle.tests.prefsDir = path.resolve(__dirname,
    "../../../../testData/preferences/");

kettle.tests.testToken1 = "testToken1";
kettle.tests.testToken1Set = {
    test: "test"
};

kettle.tests.filesToDelete = [];

var cleanUpTmpFiles = function () {
    var path;
    while ((path = kettle.tests.filesToDelete.pop()) !== undefined) {
        fs.unlinkSync(path);
    }
};

kettle.tests.testSaveResponse = function (dataText) {
    var data = JSON.parse(dataText);
    var filePath = path.resolve(kettle.tests.prefsDir, data.token) + ".json";
    kettle.tests.filesToDelete.push(filePath);
    jqUnit.assertDeepEq("Response is correct", kettle.tests.testToken1Set,
        data.preferences);
    var savedPrefs = require(filePath);
    jqUnit.assertDeepEq("Saved preferences are correct",
        kettle.tests.testToken1Set, savedPrefs.flat);
};

function testCondition() {
    fluid.builtinFail(false, ["This failure is expected."]);
}

kettle.tests.testBadResponse = function (data) {
    data = JSON.parse(data);
    jqUnit.assertTrue("Received error as expected", data.isError);
    jqUnit.assertTrue("Message is correct",
        data.message.indexOf("This failure is expected.") > -1);
};

fluid.defaults("kettle.tests.failingDataSource", {
    gradeNames: ["autoInit", "fluid.littleComponent"],
    invokers: {
        set: {
            funcName: "kettle.tests.failingDataSource.set",
            args: "{callbackWrapper}"
        }
    }
});

kettle.tests.failingDataSource.set = function (callbackWrapper) {
    // This method is made asynchronous on purpose, to try to evade the
    // exception handler inside route.js in connect.
    process.nextTick(callbackWrapper.wrap(testCondition));
};

var testDefs = [{
    name: "Flow Manager PUT tests.",
    expect: 2,
    config: {
        nodeEnv: "save",
        configPath: configPath
    },
    listeners: {
        onDestroy: cleanUpTmpFiles
    },
    components: {
        saveRequest: {
            type: "kettle.tests.request.http",
            options: {
                requestOptions: {
                    path: "/save/%token",
                    method: "PUT"

                },
                termMap: {
                    token: kettle.tests.testToken1
                }
            }
        }
    },
    sequence: [{
        func: "{saveRequest}.send",
        args: kettle.tests.testToken1Set
    }, {
        event: "{saveRequest}.events.onComplete",
        listener: "kettle.tests.testSaveResponse"
    }]
}, {
    name: "Flow Manager save POST tests.",
    expect: 2,
    config: {
        nodeEnv: "save",
        configPath: configPath
    },
    listeners: {
        onDestroy: cleanUpTmpFiles
    },
    components: {
        saveRequestNoToken: {
            type: "kettle.tests.request.http",
            options: {
                requestOptions: {
                    path: "/save",
                    method: "POST"
                }
            }
        }
    },
    sequence: [{
        func: "{saveRequestNoToken}.send",
        args: kettle.tests.testToken1Set
    }, {
        event: "{saveRequestNoToken}.events.onComplete",
        listener: "kettle.tests.testSaveResponse"
    }]
}, {
    name: "Flow Manager save PUT to existing file test.",
    expect: 2,
    config: {
        nodeEnv: "save",
        configPath: configPath
    },
    listeners: {
        onDestroy: cleanUpTmpFiles
    },
    components: {
        saveRequestNoToken: {
            type: "kettle.tests.request.http",
            options: {
                requestOptions: {
                    path: "/save",
                    method: "POST"
                }
            }
        }
    },
    sequence: [{
        func: "{saveRequestNoToken}.send",
        args: kettle.tests.testToken1Set
    }, {
        event: "{saveRequestNoToken}.events.onComplete",
        listener: "kettle.tests.testSaveResponse"
    }]
}, {
    name: "Flow Manager failed save tests.",
    expect: 2,
    config: {
        nodeEnv: "save",
        configPath: configPath
    },
    distributeOptions: {
        source: "{that}.options.preferencesDataSourceGradeNames",
        target: "{that preferencesDataSource}.options.gradeNames"
    },
    preferencesDataSourceGradeNames: ["kettle.tests.failingDataSource"],
    components: {
        failRequest: {
            type: "kettle.tests.request.http",
            options: {
                requestOptions: {
                    path: "/save",
                    method: "POST"
                }
            }
        }
    },
    sequence: [{
        func: "fluid.pushSoftFailure",
        args: -1
    }, {
        func: "{failRequest}.send"
    }, {
        event: "{failRequest}.events.onComplete",
        listener: "kettle.tests.testBadResponse"
    }, {
        func: "fluid.pushSoftFailure",
        args: testCondition
    }]
}];

module.exports = kettle.tests.bootstrap(testDefs);
