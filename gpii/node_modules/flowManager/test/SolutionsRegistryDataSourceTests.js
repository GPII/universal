/*!
GPII download and save solutions registry from source code repositoyr

Copyright 2020 OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

"use strict";

var fluid = fluid || require("infusion"),
    kettle = require("kettle"),
    jqUnit = fluid.registerNamespace("jqUnit"),
    gpii = fluid.registerNamespace("gpii");

kettle.loadTestingSupport();

fluid.require("%flowManager/src/SolutionsRegistryDataSource.js");
fluid.registerNamespace("gpii.tests.solutionsRegistry");

gpii.tests.solutionsRegistry = {
    path: "%gpii-universal/testData/solutions",
    platformIds: ["win32", "linux", "darwin", "android", "web"],
    platformId: "darwin",
    repositoryDarwinSolutions: require("./data/darwin.json5"),
    requestOptions: { os: "darwin" }
};

// Check that all platform ids are in the solutions registries (result).
gpii.tests.solutionsRegistry.checkAllRegistries = function (msg, platformIds, result) {
    jqUnit.assertValue(msg, result);
    jqUnit.assertDeepEq(msg, platformIds, fluid.keys(result));
};

// Check that the given platform id has been stripped out of the result.
gpii.tests.solutionsRegistry.checkOneRegistry = function (msg, platformId, result) {
    jqUnit.assertValue(msg, result);
    jqUnit.assertFalse(msg, platformId in result);
};

// equalityCheck is either jqUnit.assertDeepEq() or jqUnit.assertDeepNeq().
gpii.tests.solutionsRegistry.checkNamedRegistry = function (msg, equalityCheck, expectedSolutions, result) {
    jqUnit.assertValue(msg, result);
    equalityCheck(msg, expectedSolutions, result);
};

// Check that all platform ids are in the solutions registries result, and that
// the single platformId/expectedSolutions is either deeply equal or not.
gpii.tests.solutionsRegistry.checkAllWithNamedRegistry = function (msg, platformIds, platformId, equalityCheck, expectedSolutions, result) {
    console.log(platformId);
    gpii.tests.solutionsRegistry.checkAllRegistries(msg, platformIds, result);
    equalityCheck(msg, expectedSolutions, result[platformId]);
};

// ======== Testing the solutions registry data source used by the CBFM ========

fluid.defaults("gpii.tests.solutionsRegistry.cloud.testCaseHolder", {
    gradeNames: "fluid.test.testCaseHolder",
    components: {
        solutionsRegistryDataSource: {
            type: "gpii.flowManager.solutionsRegistry.dataSource.cloud",
            options: {
                path: gpii.tests.solutionsRegistry.path
            }
        }
    },
    modules: [{
        name: "Solutions registry used by CBFM - file-based solutions",
        expect: 2,
        tests: [{
            name: "Solutions registry used with CBFM - retrieve all solutions",
            sequence: [
                { funcName: "fluid.log", args: ["Solutions Registry for CBFM, getting named registry -- START"] },

                // For some reason, even though the solutionsRegistryReady event
                // fires, this doesn't hear it.
                // ... and doesn't appear to need to wait for it (?!)
                /*{
                    event: "{solutionsRegistryDataSource}.events.solutionsRegistryReady",
                    listener: "jqUnit.assert",
                    args: ["CBFM solutionsRegistryDataSource ready"]
                },*/ {
                    funcName: "{solutionsRegistryDataSource}.get",
                    args: [gpii.tests.solutionsRegistry.requestOptions]
                }, {
                    event: "{solutionsRegistryDataSource}.events.onRead",
                    listener: "gpii.tests.solutionsRegistry.checkOneRegistry",
                    args: [
                        "Expecting one solutions registry",
                        gpii.tests.solutionsRegistry.requestOptions.os,
                        "{arguments}.0"
                    ]
                },
                { funcName: "fluid.log", args: ["Solutions Registry for CBFM, getting named registry -- END"] },
                { funcName: "fluid.log", args: ["Solutions Registry for CBFM, getting all registries -- START"] },
                {
                    funcName: "{solutionsRegistryDataSource}.get",
                    args: [{}]
                }, {
                    event: "{solutionsRegistryDataSource}.events.onRead",
                    listener: "gpii.tests.solutionsRegistry.checkAllRegistries",
                    args: [
                        "Expecting all solutions registries",
                        gpii.tests.solutionsRegistry.platformIds,
                        "{arguments}.0"
                    ]
                },
                { funcName: "fluid.log", args: ["Solutions Registry for CBFM, getting all registries -- END"] }
            ]
        }]
    }]
});

// Test environment for CLFM solutions registry data source
fluid.defaults("gpii.tests.solutionsRegistry.dataSource.cloud.env", {
    gradeNames: ["fluid.test.testEnvironment"],
    components: {
        tester: {
            type: "gpii.tests.solutionsRegistry.cloud.testCaseHolder"
        }
    }
});
kettle.test.bootstrap("gpii.tests.solutionsRegistry.dataSource.cloud.env");

// ======== Testing the solutions registry data source used by the LFM ========

// Test component for the LFM solutions registry data source mocking a load
// from the source code repository.
fluid.defaults("gpii.tests.solutionsRegistry.dataSource.local.mockLoadFromRepository", {
    gradeNames: ["gpii.flowManager.solutionsRegistry.dataSource.local"],
    components: {
        revisionRequester: {
            type: "gpii.flowmanager.revisionRequester",
            options: {
                cloudURL: "http://gpii.net"
            }
        }
    },
    listeners: {
        "loadSolutions.loadFromLocalDisk": {
            listener: "{that}.loadFromLocalDisk",
            priority: "first"
        },
        "loadSolutions.getRevision": {
            listener: "{revisionRequester}.getRevision",
            priority: "after:loadFromLocalDisk"
        },
        "loadSolutions.loadFromRepository": {
            listener: "gpii.tests.solutionsRegistry.dataSource.local.mockRepoLoad",
            args: [
                "{that}",
                gpii.tests.solutionsRegistry.platformId,
                gpii.tests.solutionsRegistry.repositoryDarwinSolutions
            ],
            priority: "after:getRevision"
        },
        "loadSolutions.solutionsLoaded": {
            listener: "gpii.flowManager.solutionsRegistry.dataSource.finishedLoading",
            args: ["{that}.events.solutionsRegistryReady"],
            priority: "after:loadFromRepository"
        }
    }
});

gpii.tests.solutionsRegistry.dataSource.local.mockRepoLoad = function (that, platformId, solutions) {
    var promise = fluid.promise();
    var solutionsRegistry = {};
    solutionsRegistry[platformId] = solutions;
    that.repositorySolutionsRegistry = solutionsRegistry;
    promise.resolve(that.repositorySolutionsRegistry);
    return promise;
};

fluid.defaults("gpii.tests.solutionsRegistry.local.mockRepository.testCaseHolder", {
    gradeNames: "fluid.test.testCaseHolder",
    components: {
        solutionsRegistryMockRepoLoad: {
            type: "gpii.tests.solutionsRegistry.dataSource.local.mockLoadFromRepository",
            options: {
                path: gpii.tests.solutionsRegistry.path
            }
        }
    },
    modules: [{
        name: "Solutions registry used by LFM - repository + file system based solutions",
        expect: 2,
        tests: [{
            name: "Solutions registry LFM - solutions loaded from repository and looking for named registry",
            sequence: [
                { funcName: "fluid.log", args: ["Solutions Registry Mock Repo Load, getting named and all registries -- START"] },
                {
                    event: "{solutionsRegistryMockRepoLoad}.events.solutionsRegistryReady",
                    listener: "jqUnit.assert",
                    args: ["LFM solutionsRegistryMockRepoLoad ready"]
                }, {
                    funcName: "{solutionsRegistryMockRepoLoad}.get",
                    args: [gpii.tests.solutionsRegistry.requestOptions]
                }, {
                    event: "{solutionsRegistryMockRepoLoad}.events.onRead",
                    listener: "gpii.tests.solutionsRegistry.checkNamedRegistry",
                    args: [
                        "Expecting named solutions registry from repository",
                        jqUnit.assertDeepEq,
                        gpii.tests.solutionsRegistry.repositoryDarwinSolutions,
                        "{arguments}.0"
                    ]
                },
                { funcName: "fluid.log", args: ["Solutions Registry Mock Repo Load, getting named local registry -- END"] },
                { funcName: "fluid.log", args: ["Solutions Registry Mock Repo Load, getting all registries -- START"] },
                {
                    funcName: "{solutionsRegistryMockRepoLoad}.get",
                    args: [{}]
                }, {
                    event: "{solutionsRegistryMockRepoLoad}.events.onRead",
                    listener: "gpii.tests.solutionsRegistry.checkAllWithNamedRegistry",
                    args: [
                        "Expecting all solutions registries, but named registry is from repository",
                        gpii.tests.solutionsRegistry.platformIds,
                        gpii.tests.solutionsRegistry.platformId,
                        jqUnit.assertDeepEq,
                        gpii.tests.solutionsRegistry.repositoryDarwinSolutions,
                        "{arguments}.0"
                    ]
                },
                { funcName: "fluid.log", args: ["Solutions Registry Mock Repo Load, getting all registries -- START"] }
            ]
        }]
    }]
});

// Test environment for LFM solutions registry data source where solutions are
// fetched from the repository
fluid.defaults("gpii.tests.solutionsRegistry.dataSource.local.mockRepository.env", {
    gradeNames: ["fluid.test.testEnvironment"],
    components: {
        tester: {
            type: "gpii.tests.solutionsRegistry.local.mockRepository.testCaseHolder"
        }
    }
});
kettle.test.bootstrap("gpii.tests.solutionsRegistry.dataSource.local.mockRepository.env");

// Test component for the LFM solutions registry data source where it fails to
// load from the source code repository.
fluid.defaults("gpii.tests.solutionsRegistry.dataSource.local.failLoadFromRepository", {
    gradeNames: ["gpii.flowManager.solutionsRegistry.dataSource.local"],
    components: {
        revisionRequester: {
            type: "gpii.flowmanager.revisionRequester",
            options: {
                cloudURL: "http://gpii.net"
            }
        }
    },
    listeners: {
        "loadSolutions.loadFromLocalDisk": {
            listener: "{that}.loadFromLocalDisk",
            priority: "first"
        },
        "loadSolutions.getRevision": {
            listener: "{revisionRequester}.getRevision",
            priority: "after:loadFromLocalDisk"
        },
        "loadSolutions.loadFromRepository": {
            listener: "gpii.tests.solutionsRegistry.dataSource.local.nullRepoLoad",
            args: ["{that}"],
            priority: "after:getRevision"
        },
        "loadSolutions.solutionsLoaded": {
            listener: "gpii.flowManager.solutionsRegistry.dataSource.finishedLoading",
            args: ["{that}.events.solutionsRegistryReady"],
            priority: "after:loadFromRepository"
        }
    }
});

gpii.tests.solutionsRegistry.dataSource.local.nullRepoLoad = function (that) {
    var promise = fluid.promise();
    that.repositorySolutionsRegistry = null;
    promise.resolve(that.repositorySolutionsRegistry);
    return promise;
};

fluid.defaults("gpii.tests.solutionsRegistry.local.noRepository.testCaseHolder", {
    gradeNames: "fluid.test.testCaseHolder",
    components: {
        solutionsRegistryNullRepoLoad: {
            type: "gpii.tests.solutionsRegistry.dataSource.local.failLoadFromRepository",
            options: {
                path: gpii.tests.solutionsRegistry.path
            }
        }
    },
    modules: [{
        name: "Solutions registry used by LFM - only file system based solutions available",
        expect: 2,
        tests: [{
            name: "Solutions registry used with LFM - no solutions loaded from repository",
            sequence: [
                { funcName: "fluid.log", args: ["Solutions Registry No Repo Load, getting named local registry -- START"] },
                {
                    event: "{solutionsRegistryNullRepoLoad}.events.solutionsRegistryReady",
                    listener: "jqUnit.assert",
                    args: ["LFM solutionsRegistryNullRepoLoad ready"]
                }, {
                    funcName: "{solutionsRegistryNullRepoLoad}.get",
                    args: [gpii.tests.solutionsRegistry.requestOptions]
                }, {
                    event: "{solutionsRegistryNullRepoLoad}.events.onRead",
                    listener: "gpii.tests.solutionsRegistry.checkNamedRegistry",
                    args: [
                        "Expecting local solutions registry",
                        jqUnit.assertDeepNeq,
                        gpii.tests.solutionsRegistry.repositoryDarwinSolutions,
                        "{arguments}.0"
                    ]
                },
                { funcName: "fluid.log", args: ["Solutions Registry No Repo Load, getting named local registry -- END"] },
                { funcName: "fluid.log", args: ["Solutions Registry No Repo Load, getting all registries -- START"] },
                {
                    funcName: "{solutionsRegistryNullRepoLoad}.get",
                    args: [{}]
                }, {
                    event: "{solutionsRegistryNullRepoLoad}.events.onRead",
                    listener: "gpii.tests.solutionsRegistry.checkAllWithNamedRegistry",
                    args: [
                        "Expecting local named solutions registry",
                        gpii.tests.solutionsRegistry.platformIds,
                        gpii.tests.solutionsRegistry.platformId,
                        jqUnit.assertDeepNeq,
                        gpii.tests.solutionsRegistry.repositoryDarwinSolutions,
                        "{arguments}.0"
                    ]
                },
                { funcName: "fluid.log", args: ["Solutions Registry No Repo Load, getting all registries -- END"] }
            ]
        }]
    }]
});

// Test environment for LFM solutions registry data source where solutions are
// NOT fetched from the repository
fluid.defaults("gpii.tests.solutionsRegistry.dataSource.local.noRepository.env", {
    gradeNames: ["fluid.test.testEnvironment"],
    components: {
        tester: {
            type: "gpii.tests.solutionsRegistry.local.noRepository.testCaseHolder"
        }
    }
});
kettle.test.bootstrap("gpii.tests.solutionsRegistry.dataSource.local.noRepository.env");
