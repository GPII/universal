/*!
GPII download and save solutions registry from source code repositoyr

Copyright 2020 OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

"use strict";

var fluid = fluid || require("infusion"),
    kettle = require("kettle"),
    jqUnit = fluid.registerNamespace("jqUnit"),
    gpii = fluid.registerNamespace("gpii");

kettle.loadTestingSupport();

fluid.require("%flowManager/src/SolutionsRegistryDataSource.js");
fluid.registerNamespace("gpii.tests.solutionsRegistry");

gpii.tests.solutionsRegistry = {
    path: "%gpii-universal/testData/solutions",
    platformIds: ["win32", "linux", "darwin", "android", "web"],
    platformId: "darwin",
    repositoryDarwinSolutions: require("./data/darwin.json5"),
    requestOptions: { os: "darwin" },
    requestOptionsMissingOs: {foo: "bar"},
    win32PlatformId: "win32"
};

// Check that the local solutions for the given platformId matches the result.
gpii.tests.solutionsRegistry.checkLocalRegistry = function (msg, platformId, result) {
    var solutions = fluid.require(gpii.tests.solutionsRegistry.path + "/" + platformId + ".json5");
    jqUnit.assertDeepEq(msg, solutions, result);
};

// equalityCheck is either jqUnit.assertDeepEq() or jqUnit.assertDeepNeq().
gpii.tests.solutionsRegistry.checkNamedRegistry = function (msg, equalityCheck, expectedSolutions, result) {
    jqUnit.assertValue(msg, result);
    equalityCheck(msg, expectedSolutions, result);
};

// Check for failures.
gpii.tests.solutionsRegistry.checkRejection = function (msg, result) {
    jqUnit.assertTrue(msg, result.isError);
};

gpii.tests.solutionsRegistry.handleReadyEvent = function (that) {
    that.isReady = true;
};

// ======== Testing the solutions registry data source used by the CBFM ========

fluid.defaults("gpii.tests.solutionsRegistry.cloud.testCaseHolder", {
    gradeNames: "fluid.test.testCaseHolder",
    components: {
        solutionsRegistryDataSource: {
            type: "gpii.flowManager.solutionsRegistry.dataSource.cloudBased",
            options: {
                path: gpii.tests.solutionsRegistry.path,
                members: {
                    isReady: false
                },
                listeners: {
                    "solutionsRegistryReady": {
                        listener: "gpii.tests.solutionsRegistry.handleReadyEvent",
                        args: ["{that}"]
                    }
                }
            }
        }
    },
    modules: [{
        name: "Solutions registry used by CBFM - file-based solutions",
        expect: 2,
        tests: [{
            name: "Solutions registry used with CBFM",
            sequence: [
                { funcName: "fluid.log", args: ["Solutions Registry for CBFM, getting named registry -- START"] },
                {
                    // Cannot listen for solutionsRegistryReady event directly
                    // since it is long gone by the time this executes.  Check
                    // that the handleIsReady listener heard the event.
                    funcName: "jqUnit.assertTrue",
                    args: [
                        "Cloud based solutionsRegistryDataSource is ready",
                        "{solutionsRegistryDataSource}.isReady"
                    ]
                }, {
                    task: "{solutionsRegistryDataSource}.get",
                    args: [gpii.tests.solutionsRegistry.requestOptions],
                    resolve: "gpii.tests.solutionsRegistry.checkLocalRegistry",
                    resolveArgs: [
                        "Expecting one solutions registry",
                        gpii.tests.solutionsRegistry.requestOptions.os,
                        "{arguments}.0"
                    ]
                },
                { funcName: "fluid.log", args: ["Solutions Registry for CBFM, getting named registry -- END"] },
                { funcName: "fluid.log", args: ["Solutions Registry for CBFM, failure to provide platform -- START"] },
                {
                    task: "{solutionsRegistryDataSource}.get",
                    args: [gpii.tests.solutionsRegistry.requestOptionsMissingOs],
                    reject: "gpii.tests.solutionsRegistry.checkRejection",
                    rejectArgs: [
                        "Check missing OS parameter",
                        "{arguments}.0"
                    ]
                },
                { funcName: "fluid.log", args: ["Solutions Registry for CBFM, failure to provide platform -- END"] }
            ]
        }]
    }]
});

// Test environment for CBFM solutions registry data source
fluid.defaults("gpii.tests.solutionsRegistry.dataSource.cloud.env", {
    gradeNames: ["fluid.test.testEnvironment"],
    components: {
        tester: {
            type: "gpii.tests.solutionsRegistry.cloud.testCaseHolder"
        }
    }
});
kettle.test.bootstrap("gpii.tests.solutionsRegistry.dataSource.cloud.env");

// ======== Testing the solutions registry data source used by the LFM ========

// Test component for the LFM solutions registry data source mocking a load
// from the source code repository.
fluid.defaults("gpii.tests.solutionsRegistry.dataSource.local.mockLoadFromRepository", {
    gradeNames: ["gpii.flowManager.solutionsRegistry.dataSource.local"],
    components: {
        revisionRequester: {
            type: "gpii.flowmanager.revisionRequester",
            options: {
                cloudURL: "http://gpii.net"
            }
        }
    },
    listeners: {
        "loadSolutions.loadFromRepository": {
            listener: "gpii.tests.solutionsRegistry.dataSource.local.mockRepoLoad",
            args: [
                "{that}",
                gpii.tests.solutionsRegistry.platformId,
                gpii.tests.solutionsRegistry.repositoryDarwinSolutions
            ],
            priority: "after:getRevision"
        }
    }
});

gpii.tests.solutionsRegistry.dataSource.local.mockRepoLoad = function (that, platformId, solutions) {
    var promise = fluid.promise();
    var solutionsRegistry = {};
    solutionsRegistry[platformId] = solutions;
    that.repositorySolutionsRegistry = fluid.freezeRecursive(solutionsRegistry);
    promise.resolve(that.repositorySolutionsRegistry);
    return promise;
};

fluid.defaults("gpii.tests.solutionsRegistry.local.mockRepository.testCaseHolder", {
    gradeNames: "fluid.test.testCaseHolder",
    components: {
        solutionsRegistryMockRepoLoad: {
            type: "gpii.tests.solutionsRegistry.dataSource.local.mockLoadFromRepository",
            options: {
                path: gpii.tests.solutionsRegistry.path
            }
        }
    },
    modules: [{
        name: "Solutions registry used by LFM - repository + file system based solutions",
        expect: 3,
        tests: [{
            name: "Solutions registry LFM - solutions loaded from repository and looking for named registry",
            sequence: [
                { funcName: "fluid.log", args: ["Solutions Registry Mock Repo Load, getting named repository registry -- START"] },
                {
                    event: "{solutionsRegistryMockRepoLoad}.events.solutionsRegistryReady",
                    listener: "jqUnit.assert",
                    args: ["LFM solutionsRegistryMockRepoLoad ready"]
                }, {
                    task: "{solutionsRegistryMockRepoLoad}.get",
                    args: [gpii.tests.solutionsRegistry.requestOptions],
                    resolve: "gpii.tests.solutionsRegistry.checkNamedRegistry",
                    resolveArgs: [
                        "Expecting named solutions registry from repository",
                        jqUnit.assertDeepEq,
                        gpii.tests.solutionsRegistry.repositoryDarwinSolutions,
                        "{arguments}.0"
                    ]
                },
                { funcName: "fluid.log", args: ["Solutions Registry Mock Repo Load, getting named repository registry -- END"] },
                { funcName: "fluid.log", args: ["Solutions Registry Mock Repo Load, getting named local registry -- START"] },
                {
                    task: "{solutionsRegistryMockRepoLoad}.get",
                    args: [{os: gpii.tests.solutionsRegistry.win32PlatformId}],
                    resolve: "gpii.tests.solutionsRegistry.checkLocalRegistry",
                    resolveArgs: [
                        "Expecting named solutions registries, but from the local file system",
                        gpii.tests.solutionsRegistry.win32PlatformId,
                        "{arguments}.0"
                    ]
                },
                { funcName: "fluid.log", args: ["Solutions Registry Mock Repo Load, getting named local registry -- END"] },
                { funcName: "fluid.log", args: ["Solutions Registry Mock Repo Load, failure to provide platform -- START"] },
                {
                    task: "{solutionsRegistryMockRepoLoad}.get",
                    args: [gpii.tests.solutionsRegistry.requestOptionsMissingOs],
                    reject: "gpii.tests.solutionsRegistry.checkRejection",
                    rejectArgs: [
                        "Check missing OS parameter",
                        "{arguments}.0"
                    ]
                },
                { funcName: "fluid.log", args: ["Solutions Registry Mock Repo Load, failure to provide platform -- END"] }
            ]
        }]
    }]
});

// Test environment for LFM solutions registry data source where solutions are
// fetched from the repository
fluid.defaults("gpii.tests.solutionsRegistry.dataSource.local.mockRepository.env", {
    gradeNames: ["fluid.test.testEnvironment"],
    components: {
        tester: {
            type: "gpii.tests.solutionsRegistry.local.mockRepository.testCaseHolder"
        }
    }
});
kettle.test.bootstrap("gpii.tests.solutionsRegistry.dataSource.local.mockRepository.env");

// Test component for the LFM solutions registry data source where it fails to
// load from the source code repository.
fluid.defaults("gpii.tests.solutionsRegistry.dataSource.local.failLoadFromRepository", {
    gradeNames: ["gpii.flowManager.solutionsRegistry.dataSource.local"],
    components: {
        revisionRequester: {
            type: "gpii.flowmanager.revisionRequester",
            options: {
                cloudURL: "http://gpii.net"
            }
        }
    },
    listeners: {
        "loadSolutions.loadFromRepository": {
            listener: "gpii.tests.solutionsRegistry.dataSource.local.nullRepoLoad",
            args: ["{that}"],
            priority: "after:getRevision"
        }
    }
});

gpii.tests.solutionsRegistry.dataSource.local.nullRepoLoad = function (that) {
    var promise = fluid.promise();
    that.repositorySolutionsRegistry = null;
    promise.resolve(that.repositorySolutionsRegistry);
    return promise;
};

fluid.defaults("gpii.tests.solutionsRegistry.local.noRepository.testCaseHolder", {
    gradeNames: "fluid.test.testCaseHolder",
    components: {
        solutionsRegistryNullRepoLoad: {
            type: "gpii.tests.solutionsRegistry.dataSource.local.failLoadFromRepository",
            options: {
                path: gpii.tests.solutionsRegistry.path
            }
        }
    },
    modules: [{
        name: "Solutions registry used by LFM - only file system based solutions available",
        expect: 2,
        tests: [{
            name: "Solutions registry used with LFM - no solutions loaded from repository",
            sequence: [
                { funcName: "fluid.log", args: ["Solutions Registry No Repo Load, getting named 'repository' registry -- START"] },
                {
                    event: "{solutionsRegistryNullRepoLoad}.events.solutionsRegistryReady",
                    listener: "jqUnit.assert",
                    args: ["LFM solutionsRegistryNullRepoLoad ready"]
                }, {
                    task: "{solutionsRegistryNullRepoLoad}.get",
                    args: [gpii.tests.solutionsRegistry.requestOptions],
                    resolve: "gpii.tests.solutionsRegistry.checkNamedRegistry",
                    resolveArgs: [
                        "Expecting local solutions registry",
                        jqUnit.assertDeepNeq,
                        gpii.tests.solutionsRegistry.repositoryDarwinSolutions,
                        "{arguments}.0"
                    ]
                },
                { funcName: "fluid.log", args: ["Solutions Registry No Repo Load, getting named 'repository' registry -- END"] },
                { funcName: "fluid.log", args: ["Solutions Registry No Repo Load, getting named local registry -- START"] },
                {
                    task: "{solutionsRegistryNullRepoLoad}.get",
                    args: [{os: gpii.tests.solutionsRegistry.win32PlatformId}],
                    resolve: "gpii.tests.solutionsRegistry.checkLocalRegistry",
                    resolveArgs: [
                        "Expecting local named solutions registry",
                        gpii.tests.solutionsRegistry.win32PlatformId,
                        "{arguments}.0"
                    ]
                },
                { funcName: "fluid.log", args: ["Solutions Registry No Repo Load, named local registry -- END"] }
            ]
        }]
    }]
});

// Test environment for LFM solutions registry data source where solutions are
// NOT fetched from the repository
fluid.defaults("gpii.tests.solutionsRegistry.dataSource.local.noRepository.env", {
    gradeNames: ["fluid.test.testEnvironment"],
    components: {
        tester: {
            type: "gpii.tests.solutionsRegistry.local.noRepository.testCaseHolder"
        }
    }
});
kettle.test.bootstrap("gpii.tests.solutionsRegistry.dataSource.local.noRepository.env");
