/**
 * GPII PCP Interface Tests
 *
 * Copyright 2015 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/kettle/LICENSE.txt
 */

"use strict";

var fluid = require("infusion"),
    path = require("path"),
    jqUnit = fluid.require("jqUnit"),
    configPath = path.resolve(__dirname, "../configs"),
    kettle = require("kettle"),
    gpii = fluid.registerNamespace("gpii");

require("universal");

kettle.loadTestingSupport();

fluid.registerNamespace("gpii.tests.flowManager.PCPInterface");

gpii.tests.flowManager.PCPInterface.checkConnectionRequest = function (data, client) {
    jqUnit.assertEquals("Connection succeeded", "Client has successfully established connection to the PCP Channel", data);

    // connect socket events to the client events so we can test it
    client.socket.on("login", client.events.onLogin.fire);
    client.socket.on("logout", client.events.onLogout.fire);
    client.socket.on("message", client.events.onMessage.fire);
};

fluid.defaults("gpii.tests.flowManager.PCPInterface.basicClient", {
    gradeNames: ["kettle.test.request.io", "autoInit"],
    path: "/pcpChannel",
    port: 8081,
    listenOnInit: true,
    events: {
        onLogin: null,
        onLogout: null,
        onMessage: null
    }
});

fluid.defaults("gpii.tests.flowManager.pcpInterface.testCaseHolder", {
    gradeNames: ["kettle.test.testCaseHolder", "autoInit"],
    distributeOptions: {
        record: {
            funcName: "gpii.tests.flowManager.pcpInterface.receiveLifecycleManager",
            args: ["{testCaseHolder}", "{arguments}.0"]
        },
        target: "{that flowManager}.options.listeners.onCreate"
    }
});


gpii.tests.flowManager.pcpInterface.receiveLifecycleManager = function (testCaseHolder, flowManager) {
    testCaseHolder.flowManager = flowManager;
};

gpii.tests.flowManager.PCPInterface.onLogin = function (data, userToken) {
    jqUnit.assertDeepEq("Testing data on login event", {
        "settings": {
            "http://registry.gpii.net/common/highContrastEnabled": false
        },
        "userToken": userToken
    }, data);
};

gpii.tests.flowManager.PCPInterface.onLogout = function () {
    jqUnit.assertTrue("Logout event received on client side of socket", true);
};

gpii.tests.flowManager.PCPInterface.onMessage = function (data, expected) {
    jqUnit.assertDeepEq("Message succusfully received by socket client", expected, data);
};

var testDefs = [
    {
        name: "Flow Manager PCPInterface login, logout and standard message tests",
        expect: 5,
        config: {
            configName: "development",
            configPath: configPath
        },
        gradeNames: "gpii.tests.flowManager.pcpInterface.testCaseHolder",
        components: {
            client: {
                type: "gpii.tests.flowManager.PCPInterface.basicClient"
            }
        },
        sequence: [
            {
                func: "{client}.send"
            }, {
                event: "{client}.events.onComplete",
                listener: "gpii.tests.flowManager.PCPInterface.checkConnectionRequest",
                args: [ "{arguments}.0", "{client}" ]
            }, {
                // Test regular login notification
                func: "{flowManager}.pcpInterface.notifyUserLogonStateChange",
                args: [ "login", "someUser" ]
            }, {
                event: "{client}.events.onLogin",
                listener: "gpii.tests.flowManager.PCPInterface.onLogin",
                args: [ "{arguments}.0", "someUser" ]
            }, {
                event: "{client}.events.onMessage",
                listener: "gpii.tests.flowManager.PCPInterface.onMessage",
                args: [
                    "{arguments}.0", {
                        type: "infoMessage",
                        message: "The token someUser was logged in."
                    }
                ]
            }, {
                // Test logout notification gets passed to socket client
                func: "{flowManager}.pcpInterface.notifyUserLogonStateChange",
                args: [ "logout", "someUser" ]
            }, {
                event: "{client}.events.onLogout",
                listener: "gpii.tests.flowManager.PCPInterface.onLogout"
            }, {
                event: "{client}.events.onMessage",
                listener: "gpii.tests.flowManager.PCPInterface.onMessage",
                args: [
                    "{arguments}.0", {
                        type: "infoMessage",
                        message: "The token someUser was logged out."
                    }
                ]
            }
        ]
    }, {
        name: "Flow Manager PCPInterface simple messagetests",
        expect: 2,
        config: {
            configName: "development",
            configPath: configPath
        },
        gradeNames: "gpii.tests.flowManager.pcpInterface.testCaseHolder",
        components: {
            client: {
                type: "gpii.tests.flowManager.PCPInterface.basicClient"
            }
        },
        sequence: [
            {
                func: "{client}.send"
            }, {
                event: "{client}.events.onComplete",
                listener: "gpii.tests.flowManager.PCPInterface.checkConnectionRequest",
                args: [ "{arguments}.0", "{client}" ]
            }, {
                // Test simpe messages gets passed to socket client
                func: "{flowManager}.pcpInterface.sendUserMessage",
                args: [ "Howdy user! This is a message to you" ]
            }, {
                event: "{client}.events.onMessage",
                listener: "gpii.tests.flowManager.PCPInterface.onMessage",
                args: [
                    "{arguments}.0", {
                        type: "infoMessage",
                        message: "Howdy user! This is a message to you"
                    }
                ]
            }
        ]
    }
];

module.exports = kettle.test.bootstrapServer(testDefs);
