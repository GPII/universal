/*
 * GPII User Logon State Change
 *
 * Copyright 2012 OCAD University
 * Copyright 2015, 2017 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion");
var gpii = fluid.registerNamespace("gpii");
fluid.registerNamespace("gpii.flowManager.userLogonHandling");

gpii.flowManager.userLogonHandling.handleResetGpiiKey = function (activeGpiiKey, that) {
    if (activeGpiiKey === undefined) { // if no user is logged in
        that.errorResponse("No users currently logged in - nothing to reset", 409);
    } else {
        fluid.log("Logging out the user with GPII key " + activeGpiiKey);
        that.logoutUser(activeGpiiKey, true);
    }
};

gpii.flowManager.userLogonHandling.errorResponse = function (request, message, statusCode) {
    request.events.onError.fire({
        statusCode: statusCode || 500,
        message: message || "Unknown error occurred on logon change action"
    });
};

gpii.flowManager.userLogonHandling.startLifecycle = function (that, lifecycleManager, lifecyclePayload, event) {
    gpii.logFully("userLogonHandling.startLifecycle got final payload ", gpii.renderMegapayload(lifecyclePayload));
    var promise = lifecycleManager.start(lifecyclePayload);
    promise.then(function () {
        gpii.flowManager.userLogonHandling.updateLogonChangeModel(lifecycleManager, lifecyclePayload.gpiiKey, "login", false);
        event.fire("User with GPII key " + lifecyclePayload.gpiiKey + " was successfully logged in.");
    }, function (error) {
        fluid.log(fluid.logLevel.FAIL, "Error returned from lifecycle manager: ", error);
        that.errorResponse("Error occurred during login: " + error.message);
    });
};

/**
 * Updates the `logonChange` portion of the lifecycle manager model.
 *
 * @param {Object} lifecycleManager - The lifecycleManager component.
 * @param {String} gpiiKey - The gpiiKey of the user who is logging in or out.
 * @param {String} logonType - "login" or "logout" depending on whether its a login or logout.
 * @param {Boolean} inProgress - If this call signifies a login that is (or is about to be) in progress.
 */
gpii.flowManager.userLogonHandling.updateLogonChangeModel = function (lifecycleManager, gpiiKey, logonType, inProgress) {
    lifecycleManager.applier.change("logonChange", {
        type: logonType, // "login"/"logout"
        inProgress: inProgress, // boolean
        gpiiKey: gpiiKey, // string with GPII key
        timeStamp: Date.now()
    });
};

/*
 * Resets the logon change model of the lifecycle manager. This means that the
 * current GPII key is set to undefined, and inProgress set to false
 */
gpii.flowManager.userLogonHandling.resetLogonChangeModel = function (lifecycleManager) {
    fluid.log("Resetting logon change model of lifecycleManager");
    gpii.flowManager.userLogonHandling.updateLogonChangeModel(lifecycleManager, undefined, "logout", false);
};

/**
 * Does a logout of the user with the given token. No response will be sent to the request (ie. no request events fired)
 * but a promise will be returned for the logout action.
 *
 * @param {Component} that - An instance of stateChangeHandler component.
 * @param {Component} lifecycleManager - An instance of lifecycleManager component.
 * @param {String} gpiiKey - The user to logout.
 * @return {Promise} promise for the logout action.
 */
gpii.flowManager.userLogonHandling.logoutUserWithoutResponse = function (that, lifecycleManager, gpiiKey, isReset) {
    gpii.flowManager.userLogonHandling.updateLogonChangeModel(lifecycleManager, gpiiKey, "logout", true);
    var promise = lifecycleManager.stop({
        gpiiKey: gpiiKey
    });
    promise.then(function (response) {
        fluid.log("userLogonStateChange.logoutUser: Lifecycle manager returned: ", response);
        gpii.flowManager.userLogonHandling.updateLogonChangeModel(lifecycleManager, gpiiKey, "logout", false);
        if (gpiiKey !== "noUser" || gpiiKey === "noUser" && isReset) {
            fluid.log("=== logoutUserWithoutResponse, login in no user, gpiiKey: ", gpiiKey);
            fluid.log("userLogonStateChange.logoutUser: Login noUser");
            gpii.flowManager.local.keyInWithNoUser();
        }
    }, function (error) {
        fluid.log(fluid.logLevel.FAIL, "userLogonStateChange.logoutUser: An error occurred when attempting to log out user: ", error);
        gpii.flowManager.userLogonHandling.updateLogonChangeModel(lifecycleManager, gpiiKey, "logout", false);
    });
    return promise;
};

// Logs out user with the logoutUserWithoutResponse function, but calls the relevant events on the logout request
gpii.flowManager.userLogonHandling.logoutUser = function (that, request, gpiiKey, isReset) {
    var promise = that.logoutUserWithoutResponse(gpiiKey, isReset);
    promise.then(function () {
        request.events.onSuccess.fire("User with GPII key " + gpiiKey + " was successfully logged out.");
    }, function (error) {
        that.errorResponse("Error occurred during logout: " + error.message);
    });
};

gpii.flowManager.userLogonHandling.loginUser = function (that, lifecycleManager, gpiiKey) {
    gpii.flowManager.userLogonHandling.updateLogonChangeModel(lifecycleManager, gpiiKey, "login", true);
    that.events.onGpiiKey.fire(gpiiKey);
};


gpii.flowManager.getDeviceContext = function (deviceReporterDataSource, event, errorEvent) {
    var promise = deviceReporterDataSource.get();
    promise.then(function (deviceData) {
        gpii.logFully("getDeviceContext got deviceData ", deviceData);
        if (deviceData.isError) {
            errorEvent.fire({message: "Error in device reporter data: " + deviceData.message});
        } else {
            event.fire(deviceData);
        }
    }, function (err) {
        var error = fluid.extend(err, {
            message: "Rejected deviceReporter promise: " + err.message
        });
        errorEvent.fire(error);
    });
};

// A mixin grade for a matchMakingRequest request handler, supporting local user logon
fluid.defaults("gpii.flowManager.userLogonHandling.stateChangeHandler", {
    debounceTimeMs: 1500,
    invokers: {
        getDeviceContext: { // TODO: remember to close GPII-1770 now this is correctly factored
            funcName: "gpii.flowManager.getDeviceContext",
            args: ["{flowManager}.deviceReporterDataSource", "{that}.events.onDeviceContext", "{request}.events.onError"]
        },
        startLifecycle: {
            funcName: "gpii.flowManager.userLogonHandling.startLifecycle",
            args: [ "{that}", "{flowManager}.lifecycleManager", "{arguments}.0", "{request}.events.onSuccess" ]
                                                                // final payload from matchmaking process
        },
        logoutUserWithoutResponse: {
            funcName: "gpii.flowManager.userLogonHandling.logoutUserWithoutResponse",
            args: ["{that}", "{flowManager}.lifecycleManager", "{arguments}.0", "{arguments}.1"]
        },
        logoutUser: {
            funcName: "gpii.flowManager.userLogonHandling.logoutUser",
            args: ["{that}", "{request}", "{arguments}.0", "{arguments}.1"]
        },
        loginUser: {
            funcName: "gpii.flowManager.userLogonHandling.loginUser",
            args: ["{that}","{flowManager}.lifecycleManager", "{arguments}.0"]
        },
        errorResponse: {
            funcName: "gpii.flowManager.userLogonHandling.errorResponse",
            args: ["{request}", "{arguments}.0", "{arguments}.1"]
                                // message, statusCode
        },
        isBounce: {
            funcName: "gpii.flowManager.userLogonHandling.isBounce",
            args: ["{flowManager}.lifecycleManager", "{that}.options.debounceTimeMs", "{arguments}.0"]
                                                                                      // gpiiKey
        }
    },
    events: {
        onMatchDone: null,
        onError: null
    },
    listeners: {
        "onMatchDone": [{
            priority: 100,
            namespace: "runContextManager",
            listener: "{flowManager}.contextManager.updateActiveContextName"
        }, {
            priority: 90,
            namespace: "addLifecycleInstructionsToPayload",
            listener: "{lifecycleManager}.addLifecycleInstructionsToPayload"
        }, {
            priority: 80,
            namespace: "startLifecycle",
            listener: "{that}.startLifecycle"
        }],
        "onError.handleErrors": {
            listener: "gpii.flowManager.userLogonHandling.resetLogonChangeModel",
            args: [ "{lifecycleManager}" ]
        }
    }
});

fluid.defaults("gpii.flowManager.userLogonHandling.matchMakingStateChangeHandler", {
    gradeNames: [
        "gpii.flowManager.userLogonHandling.stateChangeHandler",
        "gpii.flowManager.matchMakingRequest"
    ],
    listeners: {
        "onGpiiKey.getDeviceContext": "{that}.getDeviceContext"
    }
});


// Incomplete grade - local FlowManager adds "gpii.flowManager.userLogonHandling.matchMakingStateChangeHandler",
// whereas untrusted adds "gpii.flowManager.untrusted.stateChangeHandler"

fluid.defaults("gpii.flowManager.proximityTrigger.handler", {
    gradeNames: ["kettle.request.http"],
    invokers: {
        handleRequest: {
            funcName: "gpii.flowManager.userLogonHandling.handleProximityTriggerRequest",
            args: ["{that}", "{flowManager}.lifecycleManager", "{request}.req.params.gpiiKey"]
        }
    }
});

/**
 * Function to check whether a proximity trigger should bounce
 *
 * @param {Component} lifecycleManager - The lifecycleManager module.
 * @param {Integer} debounceTimeMs - The time in milliseconds for which to debounce after last proximityTrigger was fired.
 * @param {String} gpiiKey - The GPII key of the user for whom the proximityTrigger was fired.
 * @return {Boolean} Returns true if the proximityTrigger should be ignored (i.e. is considered a bounce). This is done according
 *              to the following rule: any RFID actions is ignored for <myGpiiKey> if a login/logout for <myGpiiKey> is in progress
 *              OR if the last login/logout process for <myGpiiKey> finished less than {debounceTimeMs} milliseconds ago
 */
gpii.flowManager.userLogonHandling.isBounce = function (lifecycleManager, debounceTimeMs, gpiiKey) {
    // if login/logout is in progress for <gpiiKey> we consider it a bounce
    var now = Date.now();
    var model = lifecycleManager.model;
    if (gpiiKey === model.logonChange.gpiiKey) {
        return model.logonChange.inProgress || now - lifecycleManager.model.logonChange.timeStamp < debounceTimeMs;
    } else {
        return false;
    }
};

/*
 * /user/:gpiiKey/proximityTriggered handler
 * RFID with <myGpiiKey>:
 * * Debounce rule: any RFID actions is ignored for <myGpiiKey> if a login/logout for <myGpiiKey> is in progress
 * *                OR if the last login/logout process for <myGpiiKey> finished less than 1.5 seconds ago
 * * If no user is logged in and debounce doesn't apply, log in <myGpiiKey>
 * * If <myGpiiKey> is logged in and debounce doesn't apply, log out <myGpiiKey>
 * * If another user is already logged in or in the process of logging in or out, log that user out and log in <myGpiiKey>
 */
gpii.flowManager.userLogonHandling.handleProximityTriggerRequest = function (that, lifecycleManager, gpiiKey) {
    fluid.log("proximity triggered by GPII key: ", gpiiKey);
    // find currently logged in user:
    var activeGpiiKeys = lifecycleManager.getActiveSessionGpiiKeys();

    if (gpiiKey === "reset") {
        gpii.flowManager.userLogonHandling.handleResetGpiiKey(activeGpiiKeys[0], that);
        return;
    }

    if (that.isBounce(gpiiKey, that)) {
        fluid.log("Proximity trigger ignored due to bounce rules");
        that.errorResponse("Proximity trigger ignored due to bounce rules. Please wait current logon change is complete", 429);
        return;
    }

    if (activeGpiiKeys.length === 0) { // if no user is logged in
        that.loginUser(gpiiKey);
        return;
    }

    // if user is already logged in, log them out. If it's a different user who is logged in
    // log that user out before logging in with the new user
    if (activeGpiiKeys.length === 1) {
        var previousUser = activeGpiiKeys[0];
        if (previousUser !== gpiiKey) {
            var promise = that.logoutUserWithoutResponse(previousUser);
            promise.then(function () {
                that.loginUser(gpiiKey);
            }, function () {
                that.errorResponse("Unable to log previous user out so canceling login.");
            });
        } else {
            that.logoutUser(previousUser);
        }
    }
};

// Incomplete grade - local FlowManager adds "gpii.flowManager.userLogonHandling.matchMakingStateChangeHandler",
// whereas untrusted adds "gpii.flowManager.untrusted.stateChangeHandler"

fluid.defaults("gpii.flowManager.userLogin.handler", {
    gradeNames: ["kettle.request.http"],
    invokers: {
        handleRequest: {
            funcName: "gpii.flowManager.userLogin.handleRequest",
            args: ["{request}.req.params.gpiiKey", "{lifecycleManager}", "{that}"]
        }
    }
});

/*
 * Handler for URL: /user/<myGpiiKey>/login:
 * * If no user is logged in, <myGpiiKey> will be logged in
 * * If another user is logged in, nothing will happen
 * * If GPII key is "reset", log out any already logged in user.
 */
gpii.flowManager.userLogin.handleRequest = function (gpiiKey, lifecycleManager, that) {
    var activeGpiiKeys = lifecycleManager.getActiveSessionGpiiKeys(); // find currently logged in user:

    if (gpiiKey === "reset") {
        gpii.flowManager.userLogonHandling.handleResetGpiiKey(activeGpiiKeys[0], that);
        return;
    }

    if (activeGpiiKeys.length === 1) { // if another user is already logged in:
        if (activeGpiiKeys[0] === "noUser") {
            that.logoutUserWithoutResponse("noUser");
        } else {
            that.errorResponse("Got log in request from user " + gpiiKey + ", but the user " +
                activeGpiiKeys[0] + " is already logged in. So ignoring login request.", 409);
            return;
        }
    }
    that.loginUser(gpiiKey);
};

fluid.defaults("gpii.flowManager.userLogout.handler", {
    gradeNames: ["kettle.request.http", "gpii.flowManager.userLogonHandling.stateChangeHandler"],
    invokers: {
        handleRequest: {
            funcName: "gpii.flowManager.userLogout.handleRequest",
            args: ["{request}.req.params.gpiiKey", "{flowManager}.lifecycleManager", "{that}"]
        }
    }
});

/**
 * Handler for the URL /user/<myGpiiKey>/logout:
 * * If no user is logged in, nothing happens
 * * if user myGpiiKey is logged in, he will be used out
 * * If another user is logged in, nothing will happen
 * * If GPII key is "reset", log out any already logged in user.
 */

gpii.flowManager.userLogout.handleRequest = function (gpiiKey, lifecycleManager, that) {
    var activeGpiiKeys = lifecycleManager.getActiveSessionGpiiKeys(); // find currently logged in user:

    if (gpiiKey === "reset") {
        gpii.flowManager.userLogonHandling.handleResetGpiiKey(activeGpiiKeys[0], that);
        return;
    }

    if (activeGpiiKeys.length === 0) { // if no user is logged in
        that.errorResponse("No user logged in, so ignoring logout action.", 409);
        return;
    }

    if (activeGpiiKeys[0] === gpiiKey) {
        that.logoutUser(activeGpiiKeys[0]);
    } else {
        that.errorResponse("Got logout request from user " + gpiiKey + ", but the user " +
            activeGpiiKeys[0] + " is logged in. So ignoring the request.", 409);
    }
};
