/*
 * GPII User Logon State Change
 *
 * Copyright 2012 OCAD University
 * Copyright 2015 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

(function () {

    "use strict";

    var fluid = require("infusion");
    var gpii = fluid.registerNamespace("gpii");
    fluid.registerNamespace("gpii.request.flowManager.userLogonStateChange");

    gpii.request.flowManager.userLogonStateChange.handleResetToken = function (activeToken, that) {
        if (activeToken === undefined) { // if no user is logged in
            that.errorResponse("No users currently logged in - nothing to reset", 409);
        } else {
            fluid.log("Logging out the user with token " + activeToken);
            that.logoutUser(activeToken);
        }
    };

    /**
     * /user/:userToken/logonChange handler
     * * If no user is logged in, user <userToken> will be logged in
     * * If <userToken> is logged in, <userToken> will be logged out
     * * If another user is logged in, nothing happens
     * If "reset" is used as the <mytoken> for any of the above URLs, any currently logged in user will be logged out
     */
    gpii.request.flowManager.userLogonStateChange.logonChangeHandler = function (userToken, lifecycleManager, that) {
        // find currently logged in user:
        var activeTokens = lifecycleManager.getActiveSessionTokens();
        if (userToken === "reset") {
            gpii.request.flowManager.userLogonStateChange.handleResetToken(activeTokens[0], that);
            return;
        }
        if (activeTokens.length === 0) { // if no user is logged in
            that.loginUser(userToken);
            return;
        }

        if (activeTokens.length === 1) {
            if (activeTokens[0] === userToken) {
                that.logoutUser(activeTokens[0]);
            } else {
                that.errorResponse("Got logon change request from user " + userToken + ", but the user " +
                    activeTokens[0] + " is already logged in. So ignoring request.", 409);
            }
        }
    };

    gpii.request.flowManager.userLogonStateChange.errorResponse = function (request, message, statusCode) {
        request.events.onError.fire({
            statusCode: statusCode || 500,
            message: message || "Unknown error occured on logon change action"
        });
    };

    gpii.request.flowManager.userLogonStateChange.logoutUser = function (lifecycleManager, event, userToken) {
        lifecycleManager.stop({
            userToken: userToken
        }, function onSuccess(response) {
            fluid.log("Lifecycle manager returned: ", response);
            event.fire(userToken);
        });
    };

    gpii.request.flowManager.userLogonStateChange.logoutComplete = function (requestEvent, userToken) {
        requestEvent.fire("User with token " + userToken + " was successfully logged out.");
    };

    gpii.request.flowManager.userLogonStateChange.loginUser = function (that, userToken) {
        that.events.onUserToken.fire(userToken);
    };

    gpii.request.flowManager.userLogonStateChange.getDeviceContext = function (deviceReporterDataSource, event, errorEvent) {
        var promise = deviceReporterDataSource.get();
        promise.then(function (deviceData) {
            if (deviceData.isError) {
                errorEvent.fire({message: "Error in device reporter data: " + deviceData.message});
            }
            event.fire(deviceData);
        }, function (err) {
            errorEvent.fire({message: "Rejected device reporter promise: " + err.message});
        });
    };

    gpii.request.flowManager.userLogonStateChange.startLifecycle = function (lifecycleManager, lifecyclePayload, event) {
        console.log("Got final payload " + JSON.stringify(lifecyclePayload, null, 2));
        lifecycleManager.start(lifecyclePayload, function () {
            event.fire(lifecyclePayload.userToken);
        });
    };

    gpii.request.flowManager.userLogonStateChange.loginComplete = function (requestEvent, userToken) {
        requestEvent.fire("User with token " + userToken + " was successfully logged in.");
    };

    fluid.defaults("gpii.request.flowManager.userLogonStateChange.stateChangeHandler", {
        gradeNames: ["fluid.littleComponent", "gpii.request.flowManager.matchMakingRequest", "autoInit"],
        invokers: {
            startLifecycle: {
                funcName: "gpii.request.flowManager.userLogonStateChange.startLifecycle",
                args: [ "{flowManager}.lifecycleManager", "{arguments}.0", "{that}.events.onLoginComplete" ]
                                                    // final payload from matchmaking process
            },
            getDeviceContext: {
                funcName: "gpii.request.flowManager.userLogonStateChange.getDeviceContext",
                args: ["{flowManager}.deviceReporterDataSource", "{that}.events.onDeviceContext", "{request}.events.onError"]
            },
            logoutUser: {
                funcName: "gpii.request.flowManager.userLogonStateChange.logoutUser",
                args: ["{flowManager}.lifecycleManager", "{that}.events.onLogoutComplete", "{arguments}.0"],
                dynamic: true
            },
            loginUser: {
                funcName: "gpii.request.flowManager.userLogonStateChange.loginUser",
                args: ["{that}", "{arguments}.0"],
                dynamic: true
            },
            loginComplete: {
                funcName: "gpii.request.flowManager.userLogonStateChange.loginComplete",
                args: ["{requestProxy}.events.onSuccess", "{arguments}.0"] // userToken
            },
            logoutComplete: {
                funcName: "gpii.request.flowManager.userLogonStateChange.logoutComplete",
                args: ["{requestProxy}.events.onSuccess", "{arguments}.0"] // userToken
            },
            errorResponse: {
                funcName: "gpii.request.flowManager.userLogonStateChange.errorResponse",
                args: ["{request}", "{arguments}.0", "{arguments}.1"]
            }
        },
        listeners: {
            onUserToken: "{that}.getDeviceContext",
            onMatchDone: "{that}.startLifecycle",
            onLoginComplete: [
                {
                    listener: "{flowManager}.events.onLogonStateChangeComplete.fire",
                    args: [ "login", "{arguments}.0" ]
                },
                "{that}.loginComplete",
            ],
            onLogoutComplete: [
                {
                    listener: "{flowManager}.events.onLogonStateChangeComplete.fire",
                    args: [ "logout", "{arguments}.0" ]
                },
                "{that}.logoutComplete"
            ]
        }
    });

    fluid.defaults("kettle.requests.request.handler.userLogonStateChange", {
        gradeNames: ["fluid.littleComponent", "gpii.request.flowManager.userLogonStateChange.stateChangeHandler"],
        invokers: {
            handle: {
                funcName: "gpii.request.flowManager.userLogonStateChange.logonChangeHandler",
                args: ["{request}.req.params.userToken", "{flowManager}.lifecycleManager", "{that}"]
            }
        }
    });

    /**
     * Handler for URL: /user/<mytoken>/login:
     * * If no user is logged in, <mytoken> will be logged in
     * * If another user is logged in, nothing will happen
     * * If token is "reset", log out any already logged in user.
     */
    gpii.request.flowManager.userLogonStateChange.loginHandler = function (userToken, lifecycleManager, that) {
        var activeTokens = lifecycleManager.getActiveSessionTokens(); // find currently logged in user:

        if (userToken === "reset") {
            gpii.request.flowManager.userLogonStateChange.handleResetToken(activeTokens[0], that);
            return;
        }

        if (activeTokens.length === 1) { // if another user is already logged in:
            that.errorResponse("Got log in request from user " + userToken + ", but the user " +
                activeTokens[0] + " is already logged in. So ignoring login request.", 409);
            return;
        }

        that.loginUser(userToken);
    };

    fluid.defaults("kettle.requests.request.handler.userLogin", {
        gradeNames: ["fluid.littleComponent", "gpii.request.flowManager.userLogonStateChange.stateChangeHandler"],
        invokers: {
            handle: {
                funcName: "gpii.request.flowManager.userLogonStateChange.loginHandler",
                args: ["{request}.req.params.userToken", "{flowManager}.lifecycleManager", "{that}"]
            }
        }
    });

    /**
     * Handler for the URL /user/<mytoken>/logout:
     * * If no user is logged in, nothing happens
     * * if user mytoken is logged in, he will be used out
     * * If another user is logged in, nothing will happen
     * * If token is "reset", log out any already logged in user.
     */

    gpii.request.flowManager.userLogonStateChange.logoutHandler = function (userToken, lifecycleManager, that) {
        var activeTokens = lifecycleManager.getActiveSessionTokens(); // find currently logged in user:

        if (userToken === "reset") {
            gpii.request.flowManager.userLogonStateChange.handleResetToken(activeTokens[0], that);
            return;
        }

        if (activeTokens.length === 0) { // if no user is logged in
            that.errorResponse("No user logged in, so ignoring logout action.", 409);
            return;
        }

        if (activeTokens[0] === userToken) {
            that.logoutUser(activeTokens[0]);
        } else {
            that.errorResponse("Got logout request from user " + userToken + ", but the user " +
                activeTokens[0] + " is logged in. So ignoring the request.", 409);
        }
    };

    fluid.defaults("kettle.requests.request.handler.userLogout", {
        gradeNames: ["fluid.littleComponent", "gpii.request.flowManager.userLogonStateChange.stateChangeHandler"],
        invokers: {
            handle: {
                funcName: "gpii.request.flowManager.userLogonStateChange.logoutHandler",
                args: ["{request}.req.params.userToken", "{flowManager}.lifecycleManager", "{that}"],
                dynamic: true
            }
        }
    });
})();
