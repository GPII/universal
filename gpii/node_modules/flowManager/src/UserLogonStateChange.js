/*
 * GPII User Logon State Change
 *
 * Copyright 2012 OCAD University
 * Copyright 2015, 2017 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion");
var gpii = fluid.registerNamespace("gpii");
fluid.registerNamespace("gpii.flowManager.userLogonHandling");

gpii.flowManager.userLogonHandling.handleResetToken = function (activeToken, that) {
    if (activeToken === undefined) { // if no user is logged in
        that.errorResponse("No users currently logged in - nothing to reset", 409);
    } else {
        fluid.log("Logging out the user with token " + activeToken);
        that.logoutUser(activeToken);
    }
};

gpii.flowManager.userLogonHandling.errorResponse = function (request, message, statusCode) {
    request.events.onError.fire({
        statusCode: statusCode || 500,
        message: message || "Unknown error occured on logon change action"
    });
};

gpii.flowManager.userLogonHandling.startLifecycle = function (that, lifecycleManager, lifecyclePayload, event) {
    gpii.logFully("userLogonHandling.startLifecycle got final payload ", gpii.renderMegapayload(lifecyclePayload));
    var promise = lifecycleManager.start(lifecyclePayload);
    promise.then(function () {
        gpii.flowManager.userLogonHandling.updateLogonChangeModel(lifecycleManager, lifecyclePayload.userToken, "login", false);
        event.fire("User with token " + lifecyclePayload.userToken + " was successfully logged in.");
    }, function (error) {
        fluid.log(fluid.logLevel.ERROR, "Error returned from lifecycle manager: ", error);
        that.errorResponse("Error occured during login: ", error);
    });
};

/**
 * Updates the `logonChange` portion of the lifecycle manager model.
 *
 * @param lifecycleManager {Object} The lifecycleManager component
 * @param userToken {String} the userToken of the user who is logging in or out
 * @param logonType {String} "login" or "logout" depending on whether its a login or logout
 * @param inProgress {boolean} Boolean if this call signifies a login that is (or is about to be) in progress
 */
gpii.flowManager.userLogonHandling.updateLogonChangeModel = function (lifecycleManager, userToken, logonType, inProgress) {
    lifecycleManager.applier.change("logonChange", {
        type: logonType, // "login"/"logout"
        inProgress: inProgress, // boolean
        userToken: userToken, // string with user token
        timeStamp: Date.now()
    });
};

/**
 * Does a logout of the user with the given token. No response will be sent to the request (ie. no request events fired)
 * but a promise will be returned for the logout action.
 *
 * @param {that} The stateChangeHandler component
 * @param {lifecycleMananger} the lifecycleManager component
 * @param {userToken} the user to logout
 * @returns promise for the logout action
 */
gpii.flowManager.userLogonHandling.logoutUserWithoutResponse = function (that, lifecycleManager, userToken) {
    gpii.flowManager.userLogonHandling.updateLogonChangeModel(lifecycleManager, userToken, "logout", true);
    var promise = lifecycleManager.stop({
        userToken: userToken
    });
    promise.then(function (response) {
        fluid.log("userLogonStateChange.logoutUser: Lifecycle manager returned: ", response);
        gpii.flowManager.userLogonHandling.updateLogonChangeModel(lifecycleManager, userToken, "logout", false);
    }, function (error) {
        fluid.log(fluid.logLevel.ERROR, "userLogonStateChange.logoutUser: An error occurred when attempting to log out user: ", error);
        gpii.flowManager.userLogonHandling.updateLogonChangeModel(lifecycleManager, userToken, "logout", false);
    });
    return promise;
};

// Logs out user with the logoutUserWithoutResponse function, but calls the relevant events on the logout request
gpii.flowManager.userLogonHandling.logoutUser = function (that, request, userToken) {
    var promise = that.logoutUserWithoutResponse(userToken);
    promise.then(function () {
        request.events.onSuccess.fire("User with token " + userToken + " was successfully logged out.");
    }, function (error) {
        that.errorResponse("Error occurred during logout: " + error);
    });
};

gpii.flowManager.userLogonHandling.loginUser = function (that, lifecycleManager, userToken) {
    gpii.flowManager.userLogonHandling.updateLogonChangeModel(lifecycleManager, userToken, "login", true);
    that.events.onUserToken.fire(userToken);
};


gpii.flowManager.getDeviceContext = function (deviceReporterDataSource, event, errorEvent) {
    var promise = deviceReporterDataSource.get();
    promise.then(function (deviceData) {
        gpii.logFully("getDeviceContext got deviceData ", deviceData);
        if (deviceData.isError) {
            errorEvent.fire({message: "Error in device reporter data: " + deviceData.message});
        } else {
            event.fire(deviceData);
        }
    }, function (err) {
        var error = fluid.extend(err, {
            message: "Rejected deviceReporter promise: " + err.message
        });
        errorEvent.fire(error);
    });
};

// A mixin grade for a matchMakingRequest request handler, supporting local user logon
fluid.defaults("gpii.flowManager.userLogonHandling.stateChangeHandler", {
    members: {
        debounceTimeMs: 5000
    },
    invokers: {
        getDeviceContext: { // TODO: remember to close GPII-1770 now this is correctly factored
            funcName: "gpii.flowManager.getDeviceContext",
            args: ["{flowManager}.deviceReporterDataSource", "{that}.events.onDeviceContext", "{request}.events.onError"]
        },
        startLifecycle: {
            funcName: "gpii.flowManager.userLogonHandling.startLifecycle",
            args: [ "{that}", "{flowManager}.lifecycleManager", "{arguments}.0", "{request}.events.onSuccess" ]
                                                                // final payload from matchmaking process
        },
        logoutUserWithoutResponse: {
            funcName: "gpii.flowManager.userLogonHandling.logoutUserWithoutResponse",
            args: ["{that}", "{flowManager}.lifecycleManager", "{arguments}.0" ]
        },
        logoutUser: {
            funcName: "gpii.flowManager.userLogonHandling.logoutUser",
            args: ["{that}", "{request}", "{arguments}.0" ]
        },
        loginUser: {
            funcName: "gpii.flowManager.userLogonHandling.loginUser",
            args: ["{that}","{flowManager}.lifecycleManager", "{arguments}.0"]
        },
        errorResponse: {
            funcName: "gpii.flowManager.userLogonHandling.errorResponse",
            args: ["{request}", "{arguments}.0", "{arguments}.1"]
        },
        isBounce: {
            funcName: "gpii.flowManager.userLogonHandling.isBounce",
            args: ["{flowManager}.lifecycleManager", "{that}.debounceTimeMs", "{arguments}.0"] // userToken
        }
    }
});

fluid.defaults("gpii.flowManager.userLogonHandling.matchMakingStateChangeHandler", {
    gradeNames: ["gpii.flowManager.userLogonHandling.stateChangeHandler",
                 "gpii.flowManager.nonPrivacyFilteredMatchMakingRequest"],
    listeners: {
        "onUserToken.getDeviceContext": "{that}.getDeviceContext",
        "onMatchDone.startLifecycle": "{that}.startLifecycle"
    }
});


// Incomplete grade - local FlowManager adds "gpii.flowManager.userLogonHandling.matchMakingStateChangeHandler",
// whereas untrusted adds "gpii.flowManager.untrusted.stateChangeHandler"

fluid.defaults("gpii.flowManager.proximityTrigger.handler", {
    gradeNames: ["kettle.request.http"],
    invokers: {
        handleRequest: {
            funcName: "gpii.flowManager.userLogonHandling.handleProximityTriggerRequest",
            args: ["{that}", "{flowManager}.lifecycleManager", "{request}.req.params.userToken"]
        }
    }
});

/*
 * Function to check whether a proximity trigger should bounce
 *
 * @param lifecycleManager {Component} the lifecycleManager module
 * @param debounceTimeMs {Integer} the time in milliseconds for which to debounce after last proximityTrigger was fired
 * @param userToken {String} The token of the user for whom the proximityTrigger was fired
 * @return {Boolean} Returns true if the proximityTrigger should be ignored (i.e. is considered a bounce). This is done according
 *              to the following rule: any RFID actions is ignored for <mytoken> if a login/logout for <mytoken> is in progress
 *              OR if the last login/logout process for <mytoken> finished less than {debounceTimeMs} milliseconds ago
 */
gpii.flowManager.userLogonHandling.isBounce = function (lifecycleManager, debounceTimeMs, userToken) {
    // if login/logout is in progress for <userToken> we consider it a bounce
    var now = Date.now();
    var model = lifecycleManager.model;
    if (userToken === model.logonChange.userToken) {
        return model.logonChange.inProgress || now - lifecycleManager.model.logonChange.timeStamp < debounceTimeMs;
    } else {
        return false;
    }
};

/**
 * /user/:userToken/proximityTriggered handler
 * RFID with <mytoken>:
 * * Debounce rule: any RFID actions is ignored for <mytoken> if a login/logout for <mytoken> is in progress
 * *                OR if the last login/logout process for <mytoken> finished less than 5 seconds ago
 * * If no user is logged in and debounce doesn't apply, log in <mytoken>
 * * If <mytoken> is logged in and debounce doesn't apply, log out <mytoken>
 * * If another user is already logged in or in the process of logging in or out, log that user out and log in <mytoken>
 */
gpii.flowManager.userLogonHandling.handleProximityTriggerRequest = function (that, lifecycleManager, userToken) {
    fluid.log("proximity triggered by token: ", userToken);
    // find currently logged in user:
    var activeTokens = lifecycleManager.getActiveSessionTokens();

    if (userToken === "reset") {
        gpii.flowManager.userLogonHandling.handleResetToken(activeTokens[0], that);
        return;
    }

    if (that.isBounce(userToken, that)) {
        fluid.log("Proximity trigger ignored due to bounce rules");
        that.errorResponse("Proximity trigger ignored due to bounce rules. Please wait current logon change is complete", 429);
        return;
    }

    if (activeTokens.length === 0) { // if no user is logged in
        that.loginUser(userToken);
        return;
    }

    // if user is already logged in, log them out. If it's a different user who is logged in
    // log that user out before logging in with the new user
    if (activeTokens.length === 1) {
        var previousUser = activeTokens[0];
        if (previousUser !== userToken) {
            var promise = that.logoutUserWithoutResponse(previousUser);
            promise.then(function () {
                that.loginUser(userToken);
            }, function () {
                that.errorResponse("Unable to log previous user out so canceling login.");
            });
        } else {
            that.logoutUser(previousUser);
        }
    }
};

// Incomplete grade - local FlowManager adds "gpii.flowManager.userLogonHandling.matchMakingStateChangeHandler",
// whereas untrusted adds "gpii.flowManager.untrusted.stateChangeHandler"

fluid.defaults("gpii.flowManager.userLogin.handler", {
    gradeNames: ["kettle.request.http"],
    invokers: {
        handleRequest: {
            funcName: "gpii.flowManager.userLogin.handleRequest",
            args: ["{request}.req.params.userToken", "{lifecycleManager}", "{that}"]
        }
    }
});

/**
 * Handler for URL: /user/<mytoken>/login:
 * * If no user is logged in, <mytoken> will be logged in
 * * If another user is logged in, nothing will happen
 * * If token is "reset", log out any already logged in user.
 */
gpii.flowManager.userLogin.handleRequest = function (userToken, lifecycleManager, that) {
    var activeTokens = lifecycleManager.getActiveSessionTokens(); // find currently logged in user:

    if (userToken === "reset") {
        gpii.flowManager.userLogonHandling.handleResetToken(activeTokens[0], that);
        return;
    }

    if (activeTokens.length === 1) { // if another user is already logged in:
        that.errorResponse("Got log in request from user " + userToken + ", but the user " +
            activeTokens[0] + " is already logged in. So ignoring login request.", 409);
        return;
    }
    that.loginUser(userToken);
};

fluid.defaults("gpii.flowManager.userLogout.handler", {
    gradeNames: ["kettle.request.http", "gpii.flowManager.userLogonHandling.stateChangeHandler"],
    invokers: {
        handleRequest: {
            funcName: "gpii.flowManager.userLogout.handleRequest",
            args: ["{request}.req.params.userToken", "{flowManager}.lifecycleManager", "{that}"]
        }
    }
});

/**
 * Handler for the URL /user/<mytoken>/logout:
 * * If no user is logged in, nothing happens
 * * if user mytoken is logged in, he will be used out
 * * If another user is logged in, nothing will happen
 * * If token is "reset", log out any already logged in user.
 */

gpii.flowManager.userLogout.handleRequest = function (userToken, lifecycleManager, that) {
    var activeTokens = lifecycleManager.getActiveSessionTokens(); // find currently logged in user:

    if (userToken === "reset") {
        gpii.flowManager.userLogonHandling.handleResetToken(activeTokens[0], that);
        return;
    }

    if (activeTokens.length === 0) { // if no user is logged in
        that.errorResponse("No user logged in, so ignoring logout action.", 409);
        return;
    }

    if (activeTokens[0] === userToken) {
        that.logoutUser(activeTokens[0]);
    } else {
        that.errorResponse("Got logout request from user " + userToken + ", but the user " +
            activeTokens[0] + " is logged in. So ignoring the request.", 409);
    }
};
