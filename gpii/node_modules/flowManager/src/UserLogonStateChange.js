/*
 * GPII User Logon State Change
 *
 * Copyright 2012 OCAD University
 * Copyright 2015 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion");
var gpii = fluid.registerNamespace("gpii");
fluid.registerNamespace("gpii.flowManager.userLogonStateChange");

gpii.flowManager.userLogonStateChange.handleResetToken = function (activeToken, that) {
    if (activeToken === undefined) { // if no user is logged in
        that.errorResponse("No users currently logged in - nothing to reset", 409);
    } else {
        fluid.log("Logging out the user with token " + activeToken);
        that.logoutUser(activeToken);
    }
};

gpii.flowManager.userLogonStateChange.errorResponse = function (request, message, statusCode) {
    request.events.onError.fire({
        statusCode: statusCode || 500,
        message: message || "Unknown error occured on logon change action"
    });
};

gpii.flowManager.userLogonStateChange.startLifecycle = function (lifecycleManager, lifecyclePayload, event) {
    fluid.log("userLogonStateChange.startLifecycle got final payload " + JSON.stringify(lifecyclePayload, null, 2));
    lifecycleManager.start(lifecyclePayload,
        gpii.flowManager.logAndNotify("Lifecycle manager startLifecycle returned: ", event, function () {
            return "User with token " + lifecyclePayload.userToken + " was successfully logged in.";
        }
    ));
};

gpii.flowManager.userLogonStateChange.logoutUser = function (request, lifecycleManager, userToken) {
    lifecycleManager.stop({
        userToken: userToken
    }, function onSuccess(response) {
        fluid.log("userLoginStateChange.logoutUser: Lifecycle manager returned: ", response);
        request.events.onSuccess.fire("User with token " + userToken +
            " was successfully logged out.");
    });
};

gpii.flowManager.userLogonStateChange.loginUser = function (that, userToken) {
    that.events.onUserToken.fire(userToken);
};

fluid.defaults("gpii.flowManager.userLogonStateChange.stateChangeHandler", {
    invokers: {
        startLifecycle: {
            funcName: "gpii.flowManager.userLogonStateChange.startLifecycle",
            args: [ "{flowManager}.lifecycleManager", "{arguments}.0", "{request}.events.onSuccess" ]
                                                // final payload from matchmaking process
        },
        logoutUser: {
            funcName: "gpii.flowManager.userLogonStateChange.logoutUser",
            args: ["{request}", "{flowManager}.lifecycleManager", "{arguments}.0"]
        },
        loginUser: {
            funcName: "gpii.flowManager.userLogonStateChange.loginUser",
            args: ["{that}", "{arguments}.0"]
        },
        errorResponse: {
            funcName: "gpii.flowManager.userLogonStateChange.errorResponse",
            args: ["{request}", "{arguments}.0", "{arguments}.1"]
        }
    }
});

fluid.defaults("gpii.flowManager.userLogonStateChange.matchMakingStateChangeHandler", {
    gradeNames: ["gpii.flowManager.userLogonStateChange.stateChangeHandler",
                 "gpii.flowManager.nonPrivacyFilteredMatchMakingRequest"],
    listeners: {
        "onUserToken.getDeviceContext": "{that}.getDeviceContext",
        "onMatchDone.startLifecycle": "{that}.startLifecycle"
    }
});

fluid.defaults("gpii.flowManager.userLogonStateChange.handler", {
    gradeNames: ["kettle.request.http", "gpii.flowManager.userLogonStateChange.matchMakingStateChangeHandler"],
    invokers: {
        handleRequest: {
            funcName: "gpii.flowManager.userLogonStateChange.handleRequest",
            args: ["{request}.req.params.userToken", "{flowManager}.lifecycleManager", "{that}"]
        }
    }
});

/**
 * /user/:userToken/logonChange handler
 * * If no user is logged in, user <userToken> will be logged in
 * * If <userToken> is logged in, <userToken> will be logged out
 * * If another user is logged in, nothing happens
 * If "reset" is used as the <mytoken> for any of the above URLs, any currently logged in user will be logged out
 */
gpii.flowManager.userLogonStateChange.handleRequest = function (userToken, lifecycleManager, that) {
    // find currently logged in user:
    var activeTokens = lifecycleManager.getActiveSessionTokens();
    if (userToken === "reset") {
        gpii.flowManager.userLogonStateChange.handleResetToken(activeTokens[0], that);
        return;
    }
    if (activeTokens.length === 0) { // if no user is logged in
        that.loginUser(userToken);
        return;
    }

    if (activeTokens.length === 1) {
        if (activeTokens[0] === userToken) {
            that.logoutUser(activeTokens[0]);
        } else {
            that.errorResponse("Got logon change request from user " + userToken + ", but the user " +
                activeTokens[0] + " is already logged in. So ignoring request.", 409);
        }
    }
};

fluid.defaults("gpii.flowManager.userLogin.handler", {
    gradeNames: ["kettle.request.http", "gpii.flowManager.userLogonStateChange.matchMakingStateChangeHandler"],
    invokers: {
        handleRequest: {
            funcName: "gpii.flowManager.userLogin.handleRequest",
            args: ["{request}.req.params.userToken", "{lifecycleManager}", "{that}"]
        }
    }
});

/**
 * Handler for URL: /user/<mytoken>/login:
 * * If no user is logged in, <mytoken> will be logged in
 * * If another user is logged in, nothing will happen
 * * If token is "reset", log out any already logged in user.
 */
gpii.flowManager.userLogin.handleRequest = function (userToken, lifecycleManager, that) {
    var activeTokens = lifecycleManager.getActiveSessionTokens(); // find currently logged in user:

    if (userToken === "reset") {
        gpii.flowManager.userLogonStateChange.handleResetToken(activeTokens[0], that);
        return;
    }

    if (activeTokens.length === 1) { // if another user is already logged in:
        that.errorResponse("Got log in request from user " + userToken + ", but the user " +
            activeTokens[0] + " is already logged in. So ignoring login request.", 409);
        return;
    }
    that.loginUser(userToken);
};

fluid.defaults("gpii.flowManager.userLogout.handler", {
    gradeNames: ["kettle.request.http", "gpii.flowManager.userLogonStateChange.stateChangeHandler"],
    invokers: {
        handleRequest: {
            funcName: "gpii.flowManager.userLogout.handleRequest",
            args: ["{request}.req.params.userToken", "{flowManager}.lifecycleManager", "{that}"]
        }
    }
});

/**
 * Handler for the URL /user/<mytoken>/logout:
 * * If no user is logged in, nothing happens
 * * if user mytoken is logged in, he will be used out
 * * If another user is logged in, nothing will happen
 * * If token is "reset", log out any already logged in user.
 */

gpii.flowManager.userLogout.handleRequest = function (userToken, lifecycleManager, that) {
    var activeTokens = lifecycleManager.getActiveSessionTokens(); // find currently logged in user:

    if (userToken === "reset") {
        gpii.flowManager.userLogonStateChange.handleResetToken(activeTokens[0], that);
        return;
    }

    if (activeTokens.length === 0) { // if no user is logged in
        that.errorResponse("No user logged in, so ignoring logout action.", 409);
        return;
    }

    if (activeTokens[0] === userToken) {
        that.logoutUser(activeTokens[0]);
    } else {
        that.errorResponse("Got logout request from user " + userToken + ", but the user " +
            activeTokens[0] + " is logged in. So ignoring the request.", 409);
    }
};
