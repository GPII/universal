/*
 * GPII User Logon State Change
 *
 * Copyright 2012 OCAD University
 * Copyright 2015 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

(function () {

    "use strict";

    var fluid = require("infusion");
    var gpii = fluid.registerNamespace("gpii");
    fluid.registerNamespace("gpii.request.flowManager.userLogonStateChange");

    gpii.request.flowManager.userLogonStateChange.handleResetToken = function (activeTokens, that) {
        if (activeTokens.length === 0) { // if no user is logged in
            that.errorResponse("No users currently logged in - nothing to reset", 409);
        } else {
            fluid.log("Retrieved Logging out the user(s) with token " + activeTokens);
            that.responseMsg = "Retrieved reset token, so logging out the user(s) " + activeTokens;
            that.logoutUser(activeTokens);
        }
    };

    /* /user/<mytoken>/logonChange:
     * * If 0 users are logged in, user <mytoken> will be logged in
     * * If <mytoken> is logged in, <mytoken> will be logged out
     * * if <mytoken> and one other user are logged in, <mytoken> will be logged out
     * * If 2 other users are logged in, nothing happens
     *
     * If "reset" is used as the <mytoken> for any of the above URLs, any currently logged in user will be logged out
     */
    gpii.request.flowManager.userLogonStateChange.logonChangeHandler = function (userToken, lifecycleManager, that) {
        // find currently logged in user:
        var activeTokens = lifecycleManager.getUserTokens();
        if (userToken === "reset") {
            gpii.request.flowManager.userLogonStateChange.handleResetToken(activeTokens, that);
            return;
        }

        if (fluid.contains(activeTokens, userToken)) {
            that.logoutUser(userToken);
            return;
        }

        if (activeTokens.length === 0 || activeTokens.length === 1) {
            that.loginUser(userToken);
            return;
        }

        if (activeTokens.length === 2) {
            that.errorResponse("Two other users are already logged in. Ignoring logon change request", 409);
        }
    };

    gpii.request.flowManager.userLogonStateChange.errorResponse = function (that, request, message, statusCode) {
        request.events.onError.fire({
            statusCode: statusCode || 500,
            message: message || "Unknown error occured on logon change action"
        });
        that.responseMsg = null;
    };

    gpii.request.flowManager.userLogonStateChange.startLifecycle = function (that, lifecycleManager, lifecyclePayload, event) {
        console.log("Got final payload " + JSON.stringify(lifecyclePayload, null, 2));
        lifecycleManager.start(lifecyclePayload,
            gpii.request.flowManager.logAndNotify("Lifecycle manager returned: ", event, function () {
                var message = that.responseMsg || "User with token " + lifecyclePayload.userToken + " was successfully logged in.";
                that.responseMsg = null;
                return message;
            }
        ));
    };

    gpii.request.flowManager.userLogonStateChange.logoutUser = function (that, requestProxy, lifecycleManager, userToken) {
        var activeTokens = lifecycleManager.getUserTokens();
        var remainingToken = null;
        var message = "User with token " + userToken + " was successfully logged out.";
        if (activeTokens.length === 2 && userToken.length !== 2) {
            // if two users are logged in, restore system, then log back in the remaining user:
            fluid.each(activeTokens, function (activeToken) {
                if (activeToken !== userToken) {
                    remainingToken = activeToken;
                }
            });
        }
        lifecycleManager.stop({ userToken: userToken }, function onSuccess(response) {
            fluid.log("Lifecycle manager returned: ", response);
            if (remainingToken) {
                // TODO this should probably be done in a prettier way, since we already have device
                // and solution information available. But for simplicity, we will do a regular login
                that.responseMsg = message;
                that.events.onUserToken.fire(remainingToken);
            } else {
                requestProxy.events.onSuccess.fire(that.responseMsg || message);
                that.responseMsg = null;
            }
        });
    };

    gpii.request.flowManager.userLogonStateChange.loginUser = function (that, userToken) {
        that.events.onUserToken.fire(userToken);
    };

    gpii.request.flowManager.userLogonStateChange.getDeviceContext = function (deviceReporterDataSource, event, errorEvent) {
        var promise = deviceReporterDataSource.get();
        promise.then(function (deviceData) {
            if (deviceData.isError) {
                errorEvent.fire({message: "Error in device reporter data: " + deviceData.message});
            }
            event.fire(deviceData);
        }, function (err) {
            errorEvent.fire({message: "Rejected device reporter promise: " + err.message});
        });
    };

    fluid.defaults("gpii.request.flowManager.userLogonStateChange.stateChangeHandler", {
        gradeNames: ["fluid.littleComponent", "gpii.request.flowManager.matchMakingRequest", "autoInit"],
        invokers: {
            startLifecycle: {
                funcName: "gpii.request.flowManager.userLogonStateChange.startLifecycle",
                args: [ "{that}", "{flowManager}.lifecycleManager", "{arguments}.0", "{requestProxy}.events.onSuccess" ]
                                                    // final payload from matchmaking process
            },
            getDeviceContext: {
                funcName: "gpii.request.flowManager.userLogonStateChange.getDeviceContext",
                args: ["{flowManager}.deviceReporterDataSource", "{that}.events.onDeviceContext", "{request}.events.onError"]
            },
            logoutUser: {
                funcName: "gpii.request.flowManager.userLogonStateChange.logoutUser",
                args: ["{that}", "{requestProxy}", "{flowManager}.lifecycleManager", "{arguments}.0"],
                dynamic: true
            },
            loginUser: {
                funcName: "gpii.request.flowManager.userLogonStateChange.loginUser",
                args: ["{that}", "{arguments}.0"],
                dynamic: true
            },
            errorResponse: {
                funcName: "gpii.request.flowManager.userLogonStateChange.errorResponse",
                args: ["{that}", "{request}", "{arguments}.0", "{arguments}.1"]
            }
        },
        listeners: {
            onUserToken: "{that}.getDeviceContext",
            onMatchDone: "{that}.startLifecycle"
        },
        members: {
            responseMsg: null
        }
    });

    fluid.defaults("kettle.requests.request.handler.userLogonStateChange", {
        gradeNames: ["fluid.littleComponent", "gpii.request.flowManager.userLogonStateChange.stateChangeHandler"],
        invokers: {
            handle: {
                funcName: "gpii.request.flowManager.userLogonStateChange.logonChangeHandler",
                args: ["{request}.req.params.userToken", "{flowManager}.lifecycleManager", "{that}"]
            }
        }
    });

    /**
     * Handler for URL: /user/<mytoken>/login:
     * * If 0 users are logged in, <mytoken> will be logged in
     * * If 1 other user is logged in, <mytoken> will be logged in as dual-user mode
     * * If 2 other users are logged in, nothing happens
     * * If token is "reset", log out any already logged in users.
     */
    gpii.request.flowManager.userLogonStateChange.loginHandler = function (userToken, lifecycleManager, that) {
        var activeTokens = lifecycleManager.getUserTokens(); // find currently logged in user:

        if (userToken === "reset") {
            gpii.request.flowManager.userLogonStateChange.handleResetToken(activeTokens, that);
            return;
        }

        if (activeTokens.length === 2) { // if another user is already logged in:
            that.errorResponse("Got login action from user " + userToken + ", but two users are " +
                "already logged in. So ignoring login request action.", 409);
            return;
        }

        that.loginUser(userToken);
    };

    fluid.defaults("kettle.requests.request.handler.userLogin", {
        gradeNames: ["fluid.littleComponent", "gpii.request.flowManager.userLogonStateChange.stateChangeHandler"],
        invokers: {
            handle: {
                funcName: "gpii.request.flowManager.userLogonStateChange.loginHandler",
                args: ["{request}.req.params.userToken", "{flowManager}.lifecycleManager", "{that}"]
            }
        }
    });

    /**
     * Handler for the URL /user/<mytoken>/logout:
     * * If 0 users are logged in, nothing happens
     * * if user <mytoken> is logged in, he will be logged out
     * * If <mytoken> and one other user is logged in, <mytoken> will be logged out
     * * If 2 other users are logged in, nothing happens
     */

    gpii.request.flowManager.userLogonStateChange.logoutHandler = function (userToken, lifecycleManager, that) {
        var activeTokens = lifecycleManager.getUserTokens(); // find currently logged in user:

        if (userToken === "reset") {
            gpii.request.flowManager.userLogonStateChange.handleResetToken(activeTokens, that);
            return;
        }

        if (activeTokens.length === 0) { // if no user is logged in
            that.errorResponse("No users logged in, so ignoring logout action.", 409);
            return;
        }

        if (fluid.contains(activeTokens, userToken) === false) {
            that.errorResponse("Got logout request from user " + userToken + ", but that user " +
                "is not logged in. So ignoring request.", 409);
            return;
        }

        that.logoutUser(userToken);
    };

    fluid.defaults("kettle.requests.request.handler.userLogout", {
        gradeNames: ["fluid.littleComponent", "gpii.request.flowManager.userLogonStateChange.stateChangeHandler"],
        invokers: {
            handle: {
                funcName: "gpii.request.flowManager.userLogonStateChange.logoutHandler",
                args: ["{request}.req.params.userToken", "{flowManager}.lifecycleManager", "{that}"],
                dynamic: true
            }
        }
    });
})();
