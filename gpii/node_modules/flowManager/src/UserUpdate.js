/**
 * GPII User Update Handler
 *
 * Copyright 2013 OCAD University
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * You may obtain a copy of the License at
 * https://github.com/gpii/universal/LICENSE.txt
 */

(function () {

    "use strict";

    var fluid = require("infusion");
    var gpii = fluid.registerNamespace("gpii");
    fluid.registerNamespace("gpii.request.flowManager");

    fluid.defaults("kettle.requests.request.handler.userUpdate", {
        gradeNames: ["gpii.request.flowManager.sessionAware", "gpii.request.flowManager.token", "autoInit"],
        invokers: {
            handle: {
                funcName: "gpii.request.flowManager.userUpdateHandle",
                args: [
                    "{flowManager}.matchMakerDataSource",
                    "{that}.events.onMatch",
                    "{request}", "{that}"
                ],
                dynamic: true
            },
            onMatchHandler: {
                funcName: "gpii.request.flowManager.onMatchUpdateHandler",
                args: [
                    "{flowManager}.lifecycleManagerServerDataSource",
                    "{requestProxy}.events.onSuccess",
                    "{request}", "{that}",
                    "{arguments}.0"
                ],
                dynamic: true
            }
        },
        listeners: {
            onMatch: "{that}.onMatchHandler"
        }
    });

    // TODO: this needs to be replaced with the implementation based on
    // FLUID-3674 once it's part of Infusion.
    gpii.request.flowManager.deepEq = function (obj1, obj2) {
        var equal = true;
        if (!obj2) {
            return !equal;
        }
        fluid.each(obj1, function (val, key) {
            if (fluid.isPrimitive(val)) {
                equal = val === obj2[key];
            } else {
                equal = gpii.request.flowManager.deepEq(val, obj2[key]);
            }
            return equal;
        });
        return equal;
    };

    gpii.request.flowManager.getUpdatedPreferences = function (newPreferences, oldPreferences) {
        var togo = fluid.copy(newPreferences);
        fluid.remove_if(togo, function (val, key) {
            if (fluid.isPrimitive(val)) {
                return val === oldPreferences[key];
            } else {
                return gpii.request.flowManager.deepEq(val, oldPreferences[key]);
            }
        });
        return togo;
    };

    gpii.request.flowManager.userUpdateHandle = function (matchMakerDataSource, event, fluidRequest, that) {
        that.withSession(function (session) {
            fluidRequest.updatedPreferences = gpii.request.flowManager.getUpdatedPreferences(
                fluidRequest.data, session.preferences);
            gpii.request.flowManager.getMatch(matchMakerDataSource, event,
                fluidRequest.updatedPreferences, session.device);
        });
    };

    gpii.request.flowManager.onMatchUpdateHandler = function (lifecycleManagerServerDataSource, event, fluidRequest, that, match) {
        // TODO: Flatten out this horrid mess with async ginger world
        that.withSession(function (session, token) {
            lifecycleManagerServerDataSource.set({
                operation: "update",
                token: token
            }, match, function (response) {
                if (response.success) {
                    // Update the session.
                    session.preferences = fluidRequest.data;
                }
                gpii.request.flowManager.logAndNotify("Lifecycle manager returned: ", event)(response);
            });
        });
    };

})();
