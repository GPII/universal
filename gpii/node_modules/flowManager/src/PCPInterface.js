/**
* GPII PCP Render Handler
*
* Copyright 2014 Astea
* Copyright 2015 Raising the Floor - International
*
* Licensed under the New BSD license. You may not use this file except in
* compliance with this License.
*
* You may obtain a copy of the License at
* https://github.com/gpii/universal/LICENSE.txt
*/
(function () {
    "use strict";

    var fluid = require("infusion"),
        gpii = fluid.registerNamespace("gpii"),
        $ = fluid.registerNamespace("jQuery");

    fluid.registerNamespace("gpii.request.flowManager");
    fluid.registerNamespace("gpii.pcpInterface");

    gpii.pcpInterface.sockets = [];

    fluid.defaults("gpii.pcpInterface", {
        gradeNames: ["autoInit", "fluid.eventedComponent"],
        members: {
            socket: null,
            defaultAdjusters: {
                "http://registry.gpii.net/common/highContrastEnabled": false
            },
            pendingMsgs: []
        },
        invokers: {
            sendUserMessage: {
                funcName: "gpii.pcpInterface.sendUserMessage",
                args: ["{that}", "{that}.socket", "{arguments}.0", "{arguments}.1", "{arguments}.2", "{arguments}.3" ]
            },
            notifyUserLogonStateChange: {
                funcName: "gpii.pcpInterface.notifyUserLogonStateChange",
                args: ["{that}", "{that}.socket", "{lifecycleManager}", "{arguments}.0", "{arguments}.1" ]
                                        // user token, adjusters
            },
            initSocket: {
                funcName: "gpii.pcpInterface.initSocket",
                args: ["{that}", "{arguments}.0" ] // socket connection
            },
            setCurrentStatus: {
                funcName: "gpii.pcpInterface.setCurrentStatus",
                args: ["{that}", "{that}.socket", "{arguments}.0", "{lifecycleManager}"]
            }
        },
        events: {
            sendUserMessage: null
        },
        listeners: {
            sendUserMessage: "{that}.sendUserMessage",
            "{flowManager}.events.onLogonStateChangeComplete": "{that}.notifyUserLogonStateChange",
            "{flowManager}.contextManager.events.broadCastMessage": "{that}.sendUserMessage"
        }
    });

    gpii.pcpInterface.initSocket = function (that, socket) {
        that.socket = socket;

        socket.on("error", function (a) {
            console.log("PCP Error: " + JSON.stringify(a));
        });

        socket.on("disconnect", function () {
            // To avoid multiple listeners being assigned to a socket in case the connection is unstable or
            // the PCP is restarted, this hack has been implementedt. This should be adressed before this pull-
            // request is ready for master
            socket.removeAllListeners();
        });


        gpii.pcpInterface.sockets.push(socket);
    };

    /**
     * Send a message to the PCP client. If no client is connected, the message is discarded.
     *
     * @param socket {Object} client socket connection
     * @param text {String or Object} The text that the client should display. This should either
     *    be a simple string of English text or an object with texts, each keyed by a language code.
     * @param messageType {String} A string denoting the option type ("infoMessage", "warningMessage"
     *    or "errorMessage"). If this parameter is not given, it defaults to "infoMessage"
    */
    gpii.pcpInterface.sendUserMessage = function (that, socket, text, messageType, extras, postponeForLogin) {
        console.log("User message sent: " + text);
        // prep msg:
        var message = {  // Default to 'infoMessage'
            type: (messageType === undefined) ? "infoMessage" : messageType,
            message: text
        };
        if (extras) {
            message = $.extend(true, {}, message, extras);
        }

        if (postponeForLogin) {
            that.pendingMsgs.push(message);
            return;
        }
        fluid.each(gpii.pcpInterface.sockets, function (s) {
            if ((s === null) || (s.disconnected === true)) {
                fluid.log("No PCP connected on this socket, so discarding message: " + text);
            } else {
                s.emit("message", message, fluid.log);
            }
        });
    };

    /**
     * Notify the PCP client that a user has logged in or out
     *
     * @param that {Object} the pcpInterface
     * @param socket {Object} client socket connection
     * @param action {String} "login" or "logout"
     * @param userToken {String} the token of the user who has just logged in or out
     */
    gpii.pcpInterface.notifyUserLogonStateChange = function (that, socket, lifecycleManager, action, userToken) {
        fluid.each(gpii.pcpInterface.sockets, function (s) {
            if ((s === null) || (s.disconnected === true)) {
                fluid.log("No PCP connected, so is not attempting to notify of a logon change on this socket");
            } else {
                if (action === "logout") {
                    s.emit("logout");
                    // that.sendUserMessage("The token " + userToken + " was logged out.");
                    return;
                }
                // if there are multiple users logged in now, signify that:
                var multiUser = lifecycleManager.getUserTokens().length > 1;
                // send login message
                s.emit("login", {
                    settings: that.defaultAdjusters,
                    userToken: userToken,
                    multiUser: multiUser,
                    pendingMsgs: that.pendingMsgs
                });
                // if (that.pendingMsg) {
                //     s.emit("message", that.pendingMsg, fluid.log);
                // }
                // that.sendUserMessage("The token " + userToken + " was logged in.");

            }
        });
        that.pendingMsgs = [];
    };

    gpii.pcpInterface.setCurrentStatus = function (that, socket, content, lifecycleManager) {
        fluid.each(gpii.pcpInterface.sockets, function (s) {
            if ((s === null) || (s.disconnected === true)) {
                fluid.log("No PCP connected, so is not attempting to notify of a logon change on this socket");
            } else {
                console.log("Setting PCP content: " + JSON.stringify(content, null, 2));
                var currentUsers = lifecycleManager.getUserTokens();
                s.emit("currentStatus", {
                    settings: that.defaultAdjusters,
                    userToken: lifecycleManager.getUserTokens()[0] //undefined if none is logged in
                });
            }
        });
    };


    fluid.defaults("kettle.requests.request.handler.pcpChannel", {
        gradeNames: ["gpii.request.flowManager.sessionAware", "autoInit"],
        invokers: {
            handle: {
                funcName: "gpii.request.flowManager.pcpChannelHandle",
                args: ["{request}.socket", "{requestProxy}.events", "{flowManager}.pcpInterface" ],
                dynamic: true
            }
        }
    });

    gpii.request.flowManager.pcpChannelHandle = function (socket, events, pcpInterface) {
        pcpInterface.initSocket(socket);
        pcpInterface.setCurrentStatus({});
        events.onSuccess.fire("Client has successfully established connection to the PCP Channel");
    };
})();
