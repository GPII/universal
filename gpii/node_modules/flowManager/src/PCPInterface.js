/**
* GPII PCP Render Handler
*
* Copyright 2014 Astea
* Copyright 2015 Raising the Floor - International
*
* Licensed under the New BSD license. You may not use this file except in
* compliance with this License.
*
* You may obtain a copy of the License at
* https://github.com/gpii/universal/LICENSE.txt
*/
(function () {
    "use strict";

    var fluid = require("infusion");
    var gpii = fluid.registerNamespace("gpii");

    fluid.registerNamespace("gpii.request.flowManager");
    fluid.registerNamespace("gpii.pcpInterface");

    fluid.defaults("gpii.pcpInterface", {
        gradeNames: ["autoInit", "fluid.eventedComponent"],
        members: {
            clients: {}
        },
        model: {},
        invokers: {
            sendUserMessage: {
                funcName: "gpii.pcpInterface.sendUserMessage",
                args: ["{that}.clients", "{arguments}.0", "{arguments}.1" ]
            },
            notifyUserLogonStateChange: {
                funcName: "gpii.pcpInterface.notifyUserLogonStateChange",
                args: ["{that}", "{that}.clients", "{arguments}.0", "{arguments}.1" ]
                                        // user token, adjusters
            },
            addClient: {
                funcName: "gpii.pcpInterface.addClient",
                args: [ "{that}", "{arguments}.0" ] // socket connection
            },
            removeClient: {
                funcName: "gpii.pcpInterface.removeClient",
                args: [ "{that}", "{arguments}.0" ]
            }
        },
        events: {
            sendUserMessage: null
        },
        listeners: {
            sendUserMessage: "{that}.sendUserMessage",
            "{flowManager}.events.onLogonStateChangeComplete": "{that}.notifyUserLogonStateChange"
        }
    });

    gpii.pcpInterface.addClient = function (that, client) {
        var currentValue = fluid.get(that.clients, client.id);
        if (!currentValue) {
            fluid.set(that.clients, client.id, client);
            // notify of current logon state:
            client.emit("connectionSucceeded", that.model);

            client.on("disconnect", function () {
                if (!fluid.isDestroyed(that)) {
                    that.removeClient(client);
                }
            });
        }
    };

    gpii.pcpInterface.removeClient = function (that, client) {
        delete that.clients[client.id];
    };

    /**
     * Send a message to the PCP client. If no client is connected, the message is discarded.
     *
     * @param socket {Object} client socket connection
     * @param text {String or Object} The text that the client should display. This should either
     *    be a simple string of English text or an object with texts, each keyed by a language code.
     * @param messageType {String} A string denoting the option type ("infoMessage", "warningMessage"
     *    or "errorMessage"). If this parameter is not given, it defaults to "infoMessage"
    */
    gpii.pcpInterface.sendUserMessage = function (clients, text, messageType) {
        fluid.log("User message emitted from the PCP: " + text);
        // Default to 'infoMessage'
        var message = {
            type: (messageType === undefined) ? "infoMessage" : messageType,
            message: text
        };

        fluid.each(clients, function (client) {
            client.emit("message", message, fluid.log);
        });
    };

    /**
     * Notify the PCP client that a user has logged in or out
     *
     * @param that {Object} the pcpInterface
     * @param socket {Object} client socket connection
     * @param action {String} "login" or "logout"
     * @param userToken {String} the token of the user who has just logged in or out
     */
    gpii.pcpInterface.notifyUserLogonStateChange = function (that, clients, action, userToken) {
        if (action === "logout") {
            that.sendUserMessage("The token " + userToken + " was logged out.");
            that.model = {};
            fluid.each(clients, function (client) {
                client.emit("logout");
            });
        } else {
            // else a user just logging in
            var defaultAdjusters = {
                "http://registry.gpii.net/common/highContrastEnabled": false
            };
            that.model = {
                settings: defaultAdjusters,
                userToken: userToken
            };

            fluid.each(clients, function (client) {
                // send login message
                client.emit("login", that.model);
            });
            that.sendUserMessage("The token " + userToken + " was logged in.");
        }
    };

    fluid.defaults("kettle.requests.request.handler.pcpChannel", {
        gradeNames: ["gpii.request.flowManager.sessionAware", "autoInit"],
        invokers: {
            handle: {
                funcName: "gpii.request.flowManager.pcpChannelHandle",
                args: ["{request}", "{requestProxy}.events", "{flowManager}.pcpInterface" ],
                dynamic: true
            }
        }
    });

    gpii.request.flowManager.pcpChannelHandle = function (request, events, pcpInterface) {
        events.onSuccess.fire("Client has successfully established connection to the PCP Channel");
        pcpInterface.addClient(request.socket);
    };
})();