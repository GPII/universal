/**
 * GPII Flow Manager Utilities.
 *
 * Copyright 2012 OCAD University
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

(function () {

    "use strict";

    var fluid = require("infusion"),
        $ = fluid.registerNamespace("jQuery"),
        gpii = fluid.registerNamespace("gpii");

    fluid.registerNamespace("gpii.request.flowManager");

    gpii.request.flowManager.logAndNotify = function (msg, event, callback) {
        return function (data) {
            fluid.log(msg, data);
            event.fire(callback ? callback(data) : data);
        };
    };

    gpii.request.flowManager.getPreferences = function (preferencesDataSource, event, userToken) {
        fluid.log("gpii.request.flowManager.getPreferences called - fetching preferences");
        preferencesDataSource.get({
            userToken: userToken
        }, gpii.request.flowManager.logAndNotify("Fetched user preferences: ", event,
            function getPreferences(data) {
                return data.preferences || data;
            }));
    };

    /*
     * Asynchronous function which makes a get call to the solutions registry (1st parameter) to
     * retrieve the solutions registry matching what is passed in the `device` parameter.
     * This is appended to the matchmaker payload (mmpayload) parameter, which in turn is passed
     * as parameter in the event fired.
     *
     * @solutionsRegistry (Object) - a solutions registry data source
     * @mmpayload (Object) - the matchmaker payload on which to attach the retrieved solution object
     * @device (Object) - output from a device reporter. Used to filter solutions registry entries
     * @event (Object) - Event to be fired when the solutionsRegistry entry has been retrieved
     *
     * @return (undefined) - function is asynchronous and doesn't return anything. Instead the event
     *      is fired with the modified mmpayload.
     */
    gpii.request.flowManager.getSolutions = function (solutionsRegistryDataSource, deviceContext, event) {
        var os = fluid.get(deviceContext, "OS.id"),
            version = fluid.get(deviceContext, "OS.version");
        solutionsRegistryDataSource.get({
            os: os,
            version: version
        }, function (solutions) {
            var solutionsRegistryEntries = gpii.matchMakerFramework.filterSolutions(solutions, deviceContext);
            fluid.log("Fetched filtered solutions registry entries: " + JSON.stringify(solutionsRegistryEntries, null, 4));
            event.fire(solutionsRegistryEntries);
        });
    };

    gpii.request.flowManager.invokeTransformer = function (transformer, contextPayload) {
        var lifecycleInstructions = transformer.configurationToSettings(contextPayload.activeConfiguration, contextPayload.solutionsRegistryEntries);
        console.log("transformer got lifecycleInstructions " + JSON.stringify(lifecycleInstructions, null, 2) + " from contextPayload " + JSON.stringify(contextPayload, null, 2));
        var transformedPayload = $.extend({
            lifecycleInstructions: lifecycleInstructions
        }, contextPayload);
        return transformedPayload;
    };

    // initialPayload contains fields
    //     userToken, preferences, deviceContext, solutionsRegistryEntry
    // resulting from the initial fetch process
    gpii.request.flowManager.processMatch = function (that, initialPayload) {
        var promise = fluid.promise.fireTransformEvent(that.events.processMatch, initialPayload, {});
        promise.then(function (finalPayload) {
            that.events.onMatchDone.fire(finalPayload);
        }, function (error) {
            that.requestPromise.reject(error);
        });
    };

    // This is a table of priorities for handlers in the "processMatch" filter chain governing the MatchMaking process.
    // This will be removed in favour of a relative constraints system once we have FLUID-5506 completed
    // Higher priority numbers are handled earlier than lower ones
    // This process is kicked off by the "onReadyToMatch" event defined in the "gpii.request.flowManager.matchMakingRequest" grade
    gpii.request.flowManager.processMatch.priorities = {
        // onReadyToMatch event signals start of process
        preProcess:           100,
        matchMakerDispatcher: 90,
        runContextManager:    80,
        privacyFilter:        70,
        transform:            60
        // onMatchDone event fired to lifecycleManager or cloud-based settings endpoint
    };

    /* This component orchestrates the lifecycle for a component which assembles the raw materials required for the matchmaking
     *  process, invokes it, and distributes the results. These raw materials are the userToken (of the user whose preferences are to
     *  be fetched), the device information for the current platform, and the registry of solutions which are available to be
     *  invoked.
     *  This grade is used in the following places:
     *     UserLogin.js - where it coordinates the standard lifecycle for a user logging on to a local FlowManager
     *     CloudBasedFlowManager.js - where it coordinates the lifecycle for a user requesting settings from a cloud-based FlowManager
     */
    fluid.defaults("gpii.request.flowManager.matchMakingRequest", {
        gradeNames: ["fluid.eventedComponent", "autoInit"],
        invokers: {
            getPreferences: {
                funcName: "gpii.request.flowManager.getPreferences",
                args: ["{flowManager}.preferencesDataSource", "{that}.events.onPreferences", "{that}.userToken"]
            },
            processMatch: {
                funcName: "gpii.request.flowManager.processMatch",
                args: [ "{that}", "{arguments}.0"]
                // initial payload
            },
            getSolutions: {
                funcName: "gpii.request.flowManager.getSolutions",
                args: [ "{flowManager}.solutionsRegistryDataSource", "{arguments}.0", "{that}.events.onSolutions"]
            }
        },
        events: {
            // Four pre-requisites for the match process to begin
            onUserToken: null,
            onPreferences: null,
            onDeviceContext: null,
            onSolutions: null,
            // The "pseudo-event" whose handlers govern the match processing chain
            processMatch: null,
            // Output of the matching process - listeners in derived grades
            onMatchDone: null,
            // Boiled event which initiates the match process
            onReadyToMatch: {
                events: {
                    preferences: "onPreferences",
                    deviceContext: "onDeviceContext",
                    solutions: "onSolutions"
                },
                args: [{
                    userToken: "{that}.userToken",
                    preferences: "{arguments}.preferences.0",
                    deviceContext: "{arguments}.deviceContext.0",
                    solutionsRegistryEntries: "{arguments}.solutions.0"
                }]
            }
        },
        listeners: {
            onUserToken: [{
                priority: "first",
                listener: "gpii.request.flowManager.setUserToken",
                args: ["{that}", "{arguments}.0"]
            }, "{that}.getPreferences"],
            onDeviceContext: "{that}.getSolutions",
            onReadyToMatch: "{that}.processMatch",
            processMatch: [{ // Definition of the MatchMaking processing chain
                priority: gpii.request.flowManager.processMatch.priorities.preProcess,
                namespace: "preProcess",
                listener: "{flowManager}.matchMakerFramework.preProcess"
            }, {
                priority: gpii.request.flowManager.processMatch.priorities.matchMakerDispatcher,
                namespace: "matchMakerDispatcher",
                listener: "{flowManager}.matchMakerFramework.matchMakerDispatcher"
            }, {
                priority: gpii.request.flowManager.processMatch.priorities.runContextManager,
                namespace: "runContextManager",
                listener: "{flowManager}.contextManager.evaluateMatch"
            }, // privacy filter inserted in here for cloud-based flow manager
            {
                priority: gpii.request.flowManager.processMatch.priorities.transform,
                namespace: "transform",
                listener: "gpii.request.flowManager.invokeTransformer",
                args: ["{flowManager}.transformer", "{arguments}.0"]
            }
            ]
        }
    });

    gpii.request.flowManager.setUserToken = function (handler, userToken) {
        handler.userToken = userToken;
    };

    fluid.defaults("gpii.request.flowManager.sessionAware", {
        gradeNames: ["fluid.littleComponent", "autoInit"],
        components: {
            lifecycleManager: "{flowManager}.lifecycleManager"
        },
        invokers: {
            getActiveSessionTokens: {
                func: "{lifecycleManager}.getActiveSessionTokens"
            },
            withSession: {
                funcName: "gpii.request.flowManager.sessionAware.withSession",
                args: ["{that}", "{flowManager}.lifecycleManager", "{requestProxy}.events", "{arguments}.0", "{arguments}.1"]
            }
        }
    });

    gpii.request.flowManager.sessionAware.withSession = function (that, lifecycleManager, events, callback, failMessage) {
        var userTokens = that.getActiveSessionTokens();
        if (userTokens.length === 0) {
            failMessage = failMessage || "Error handling request which required active session, but none was active";
            events.onError.fire({
                isError: true,
                statusCode: 401,
                message: failMessage
            });
        } else {
            var session = lifecycleManager.getSession(userTokens);
            callback(session, userTokens);
        }
    };
})();
