 /**
 GPII Flow Manager Utilities.

 Copyright 2012 OCAD University

 Licensed under the New BSD license. You may not use this file except in
 compliance with this License.

 You may obtain a copy of the License at
 https://github.com/gpii/universal/LICENSE.txt
*/

(function () {

    "use strict";

    var fluid = require("infusion");
    var gpii = fluid.registerNamespace("gpii");
    fluid.registerNamespace("gpii.request.flowManager");

    gpii.request.flowManager.logAndNotify = function (msg, event, callback) {
        return function (data) {
            fluid.log(msg, data);
            event.fire(callback ? callback(data) : data);
        };
    };

    gpii.request.flowManager.getPreferences = function (preferencesDataSource, event, userToken) {
        fluid.log("gpii.request.flowManager.getPreferences called - fetching preferences");
        preferencesDataSource.get({
            userToken: userToken
        }, gpii.request.flowManager.logAndNotify("Fetched user preferences: ", event,
            function getPreferences(data) {
                return data.preferences || data;
            }));
    };

    gpii.request.flowManager.getDevice = function (deviceReporterDataSource, event) {
        fluid.log("gpii.request.flowManager.getDevice called - fetching device info");
        deviceReporterDataSource.get(null, gpii.request.flowManager.logAndNotify(
            "Fetched device reporter data: ", event));
    };

    /*
     * Asynchronous function which makes a get call to the solutions registry (1st parameter) to
     * retrieve the solutions registry matching what is passed in the `device` parameter.
     * This is appended to the matchmaker payload (mmpayload) parameter, which in turn is passed
     * as parameter in the event fired.
     *
     * @solutionsRegistry (Object) - a solutions registry data source
     * @mmpayload (Object) - the matchmaker payload on which to attach the retrieved solution object
     * @device (Object) - output from a device reporter. Used to filter solutions registry entries
     * @event (Object) - Event to be fired when the solutionsRegistry entry has been retrieved
     *
     * @return (undefined) - function is asynchronous and doesn't return anything. Instead the event
     *      is fired with the modified mmpayload.
     */
    gpii.request.flowManager.getSolutions = function (solutionsRegistryDataSource, device, event) {
        var os = fluid.get(device, "OS.id"),
            version = fluid.get(device, "OS.version");
        solutionsRegistryDataSource.get({
            os: os,
            version: version
        }, function (solutions) {
            var solutionsRegistry = gpii.matchMakerFramework.filterSolutions(solutions, device);
            fluid.log("Fetched solutions registry: "+JSON.stringify(solutionsRegistry, null, 4));
            event.fire(solutionsRegistry);
        });
    };

    gpii.request.flowManager.runMatchMakerFramework = function (that, matchMakerFramework, preferences, device, solutionsRegistry, event) {
        matchMakerFramework.preProcess(that.userToken, preferences, device, solutionsRegistry, event);
    };

    // TODO: This component is poorly named
    fluid.defaults("gpii.request.flowManager.userToken", {
        gradeNames: ["fluid.eventedComponent", "autoInit"],
        invokers: {
            getPreferences: {
                funcName: "gpii.request.flowManager.getPreferences",
                args: ["{flowManager}.preferencesDataSource", "{that}.events.onPreferences", "{that}.userToken"]
            },
            runMatchMakerFramework: {
                funcName: "gpii.request.flowManager.runMatchMakerFramework",
                args: [ "{that}", "{flowManager}.matchMakerFramework",  "{arguments}.0", "{arguments}.1", "{arguments}.2", "{that}.events.onMatch"]
                                                               // prefs, device, solutionsRegistry
            },
            getSolutions: {
                funcName: "gpii.request.flowManager.getSolutions",
                args: [ "{flowManager}.solutionsRegistryDataSource", "{arguments}.0", "{that}.events.onSolutionsRegistry"]
            }
        },
        events: {
            onSolutionsRegistry: null,
            onDevice: null,
            onUserToken: null,
            onPreferences: null,
            onMatch: null,
            onReadyForLifecycle: null,
            onReadyToMatch: {
                events: {
                    preferences: "onPreferences",
                    device: "onDevice",
                    solutionsRegistry: "onSolutionsRegistry"
                },
                args: ["{arguments}.preferences.0", "{arguments}.device.0", "{arguments}.solutionsRegistry.0"]
            }
        },
        listeners: {
            onUserToken: "{that}.getPreferences",
            onReadyToMatch: "{that}.runMatchMakerFramework",
            onDevice: "{that}.getSolutions"
        }
    });

    fluid.defaults("gpii.request.flowManager.sessionAware", {
        gradeNames: ["fluid.littleComponent", "autoInit"],
        components: {
            lifecycleManager: "{flowManager}.lifecycleManager"
        },
        invokers: {
            getActiveSessionTokens: {
                func: "{lifecycleManager}.getActiveSessionTokens"
            },
            withSession: {
                funcName: "gpii.request.flowManager.sessionAware.withSession",
                args: ["{that}", "{flowManager}.lifecycleManager", "{requestProxy}.events", "{arguments}.0", "{arguments}.1"]
            }
        }
    });

    gpii.request.flowManager.sessionAware.withSession = function (that, lifecycleManager, events, callback, failMessage) {
        var userTokens = that.getActiveSessionTokens();
        if (userTokens.length === 0) {
            failMessage = failMessage || "Error handling request which required active session, but none was active";
            events.onError.fire({
                isError: true,
                message: failMessage
            });
        } else {
            var session = lifecycleManager.getSession(userTokens);
            callback(session, userTokens);
        }
    };
})();
