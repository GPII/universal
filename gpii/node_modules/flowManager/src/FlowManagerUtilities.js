/**
 GPII Flow Manager Utilities.

 Copyright 2012 OCAD University

 Licensed under the New BSD license. You may not use this file except in
 compliance with this License.

 You may obtain a copy of the License at
 https://github.com/gpii/universal/LICENSE.txt
*/

(function () {

    "use strict";
    
    var fluid = require("infusion");
    var gpii = fluid.registerNamespace("gpii");
    fluid.registerNamespace("gpii.request.flowManager");

    gpii.request.flowManager.logAndNotify = function (msg, event, callback) {
        return function (data) {
            fluid.log(msg, data);
            event.fire(callback ? callback(data) : data);
        };
    };

    gpii.request.flowManager.getPreferences = function (preferencesDataSource, event, token) {
        preferencesDataSource.get({
            token: token
        }, gpii.request.flowManager.logAndNotify("Fetched user preferences: ", event,
            function getPreferences(data) {
                return data.preferences || data;
            }));
    };

    gpii.request.flowManager.getDevice = function (deviceReporterDataSource, event) {
        deviceReporterDataSource.get(null, gpii.request.flowManager.logAndNotify(
            "Fetched device reporter data: ", event));
    };

    gpii.request.flowManager.getMatch = function (matchMakerDataSource, event, preferences, device) {
        var callback = function (data) {
            gpii.request.flowManager.logAndNotify(
                "Matched preferences and device reporter data: ", event)(data);
        };
        matchMakerDataSource.set(null, {
            preferences: preferences,
            device: device
        }, callback);
    };

    // TODO: This component is poorly named
    fluid.defaults("gpii.request.flowManager.token", {
        gradeNames: ["fluid.eventedComponent", "autoInit"],
        invokers: {
            getPreferences: {
                funcName: "gpii.request.flowManager.getPreferences",
                args: ["{flowManager}.preferencesDataSource", "{that}.events.onPreferences", "{that}.userToken"]
            },
            getMatch: {
                funcName: "gpii.request.flowManager.getMatch",
                args: ["{flowManager}.matchMakerDataSource", "{that}.events.onMatch", "{arguments}.0", "{arguments}.1"]
            }
        },
        events: {
            onUserListener: null,
            onPreferences: null,
            onReadyToMatch: null,
            onMatch: null
        },
        listeners: {
            onUserListener: "{that}.getPreferences",
            onReadyToMatch: "{that}.getMatch"
        }
    });
    
    fluid.defaults("gpii.request.flowManager.sessionAware", {
        gradeNames: ["fluid.littleComponent", "autoInit"],
        components: {
            lifecycleManager: "{flowManager}.lifecycleManager"
        },
        invokers: {
            getActiveSessionTokens: {
                func: "{lifecycleManager}.getActiveSessionTokens"
            },
            withSession: {
                funcName: "gpii.request.flowManager.sessionAware.withSession",
                args: ["{that}", "{requestProxy}.events", "{arguments}.0", "{arguments}.1"]
            }
        }
    });
    
    gpii.request.flowManager.sessionAware.withSession = function (that, events, callback, failMessage) {
        var tokens = that.getActiveSessionTokens();
        if (tokens.length === 0) {
            failMessage = failMessage || "Error handling request which required active session, but none was active";
            events.onError.fire({
                isError: true,
                message: failMessage
            });
        } else {
            var session = that.lifecycleManager.getSession(tokens);
            callback(session, tokens);
        }
    };

})();
