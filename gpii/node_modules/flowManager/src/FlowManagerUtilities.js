/**
 * GPII Flow Manager Utilities.
 *
 * Copyright 2012 OCAD University
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

(function () {

    "use strict";

    var fluid = require("infusion"),
        $ = fluid.registerNamespace("jQuery"),
        gpii = fluid.registerNamespace("gpii"),
        kettle = fluid.registerNamespace("kettle");

    require("./PrivacyFilter.js");

    fluid.registerNamespace("gpii.request.flowManager.privacy");

    gpii.request.flowManager.logAndNotify = function (msg, event, callback) {
        return function (data) {
            fluid.log(msg, data);
            event.fire(callback ? callback(data) : data);
        };
    };

    gpii.request.flowManager.getPreferences = function (preferencesDataSource, request, event, userToken) {
        fluid.log("gpii.request.flowManager.getPreferences called - fetching preferences");
        var promise = preferencesDataSource.get({userToken: userToken});
        promise.then(function (data) {
            // Should be removed once KETTLE-33 is resolved
            if (data.isError) {
                request.events.onError.fire(data);
            }
            event.fire(data.preferences || data);
        }, function (err) {
            request.events.onError.fire("Error when retrieving preferences. ", err.message);
        });
    };

    /*
     * Asynchronous function which makes a get call to the solutions registry (1st parameter) to
     * retrieve the solutions registry matching what is passed in the `device` parameter.
     * This is appended to the matchmaker payload (mmpayload) parameter, which in turn is passed
     * as parameter in the event fired.
     *
     * @solutionsRegistry (Object) - a solutions registry data source
     * @mmpayload (Object) - the matchmaker payload on which to attach the retrieved solution object
     * @device (Object) - output from a device reporter. Used to filter solutions registry entries
     * @event (Object) - Event to be fired when the solutionsRegistry entry has been retrieved
     *
     * @return (undefined) - function is asynchronous and doesn't return anything. Instead the event
     *      is fired with the modified mmpayload.
     */
    gpii.request.flowManager.getSolutions = function (solutionsRegistryDataSource, deviceContext, event) {
        var os = fluid.get(deviceContext, "OS.id"),
            version = fluid.get(deviceContext, "OS.version");
        solutionsRegistryDataSource.get({
            os: os,
            version: version
        }, function (solutions) {
            var solutionsRegistryEntries = gpii.matchMakerFramework.filterSolutions(solutions, deviceContext);
            fluid.log("Fetched filtered solutions registry entries: " + JSON.stringify(solutionsRegistryEntries, null, 4));
            event.fire(solutionsRegistryEntries);
        });
    };

    gpii.request.flowManager.transformLifecycle = function (transformer, contextPayload) {
        var lifecycleInstructions = transformer.configurationToSettings(contextPayload.activeConfiguration, contextPayload.solutionsRegistryEntries);
        console.log("transformer got lifecycleInstructions " + JSON.stringify(lifecycleInstructions, null, 2) + " from contextPayload " + JSON.stringify(contextPayload, null, 2));
        var transformedPayload = $.extend({
            lifecycleInstructions: lifecycleInstructions
        }, contextPayload);
        return transformedPayload;
    };

    // initialPayload contains fields
    //     userToken, preferences, deviceContext, solutionsRegistryEntry
    // resulting from the initial fetch process
    gpii.request.flowManager.processMatch = function (that, initialPayload) {
        var promise = fluid.promise.fireTransformEvent(that.events.processMatch, initialPayload, {});
        promise.then(function (finalPayload) {
            that.events.onMatchDone.fire(finalPayload);
        }, function (error) {
            that.requestPromise.reject(error);
        });
    };

    // This is a table of priorities for handlers in the "processMatch" filter chain governing the MatchMaking process.
    // This will be removed in favour of a relative constraints system once we have FLUID-5506 completed
    // Higher priority numbers are handled earlier than lower ones
    // This process is kicked off by the "onReadyToMatch" event defined in the "gpii.request.flowManager.matchMakingRequest" grade
    gpii.request.flowManager.processMatch.priorities = {
        // onReadyToMatch event signals start of process
        preProcess:           100,
        matchMakerDispatcher: 90,
        privacyFilter:        80,
        runContextManager:    70,
        transform:            60
        // onMatchDone event fired to lifecycleManager or cloud-based settings endpoint
    };

    /* This component orchestrates the lifecycle for a component which assembles the raw materials required for the matchmaking
     *  process, invokes it, and distributes the results. These raw materials are the userToken (of the user whose preferences are to
     *  be fetched), the device information for the current platform, and the registry of solutions which are available to be
     *  invoked.
     *  This grade is used in the following places:
     *     UserLogonStateChange.js - where it coordinates the standard lifecycle for a user logging on to a local FlowManager
     *     CloudBasedFlowManager.js - where it coordinates the lifecycle for a user requesting settings from a cloud-based FlowManager
     */
    fluid.defaults("gpii.request.flowManager.matchMakingRequest", {
        gradeNames: ["fluid.eventedComponent", "autoInit"],
        invokers: {
            getPreferences: {
                funcName: "gpii.request.flowManager.getPreferences",
                args: ["{flowManager}.preferencesDataSource", "{request}", "{that}.events.onPreferences", "{that}.userToken"]
            },
            processMatch: {
                funcName: "gpii.request.flowManager.processMatch",
                args: [ "{that}", "{arguments}.0"]
                // initial payload
            },
            getSolutions: {
                funcName: "gpii.request.flowManager.getSolutions",
                args: [ "{flowManager}.solutionsRegistryDataSource", "{arguments}.0", "{that}.events.onSolutions"]
            }
        },
        events: {
            // Four pre-requisites for the match process to begin
            onUserToken: null,
            onPreferences: null,
            onDeviceContext: null,
            onSolutions: null,
            // The "pseudo-event" whose handlers govern the match processing chain
            processMatch: null,
            // Output of the matching process - listeners in derived grades
            onMatchDone: null,
            // Boiled event which initiates the match process
            onReadyToMatch: {
                events: {
                    preferences: "onPreferences",
                    deviceContext: "onDeviceContext",
                    solutions: "onSolutions"
                },
                args: [{
                    userToken: "{that}.userToken",
                    preferences: "{arguments}.preferences.0",
                    deviceContext: "{arguments}.deviceContext.0",
                    solutionsRegistryEntries: "{arguments}.solutions.0"
                }]
            }
        },
        listeners: {
            onUserToken: [{
                priority: "first",
                listener: "gpii.request.flowManager.setUserToken",
                args: ["{that}", "{arguments}.0"]
            }, "{that}.getPreferences"],
            onDeviceContext: "{that}.getSolutions",
            processMatch: [{ // Definition of the MatchMaking processing chain
                priority: gpii.request.flowManager.processMatch.priorities.preProcess,
                namespace: "preProcess",
                listener: "{flowManager}.matchMakerFramework.preProcess"
            }, {
                priority: gpii.request.flowManager.processMatch.priorities.matchMakerDispatcher,
                namespace: "matchMakerDispatcher",
                listener: "{flowManager}.matchMakerFramework.matchMakerDispatcher"
            }, // privacy filter inserted in here by privacyFilteredMatchMakingRequest
            {
                priority: gpii.request.flowManager.processMatch.priorities.runContextManager,
                namespace: "runContextManager",
                listener: "{flowManager}.contextManager.evaluateMatch"
            }, {
                priority: gpii.request.flowManager.processMatch.priorities.transform,
                namespace: "transform",
                listener: "gpii.request.flowManager.transformLifecycle",
                args: ["{flowManager}.transformer", "{arguments}.0"]
            }
            ]
        }
    });

    fluid.defaults("gpii.request.flowManager.nonPrivacyFilteredMatchMakingRequest", {
        gradeNames: ["gpii.request.flowManager.matchMakingRequest", "autoInit"],
        listeners: {
            onReadyToMatch: "{that}.processMatch"
        }
    });

    // TODO: Restore the ability of the ontology manager to straightforwardly form single transforms and remove this hard-coded path

    gpii.request.flowManager.privacy.privacyToSettingsTransformRules = fluid.require("${universal}/testData/ontologies/privacy-flat.json");
    gpii.request.flowManager.privacy.settingsToPrivacyTransformRules = fluid.model.transform.invertConfiguration(gpii.request.flowManager.privacy.privacyToSettingsTransformRules);

    gpii.request.flowManager.doPrivacyFilter = function (privacyFilter, payload, isAnonymousToken, privacySettings) {
        if (isAnonymousToken) {
            // For anonymous token requests, we do not perform privacy filtering.
            //
            // See https://issues.gpii.net/browse/GPII-1224?focusedCommentId=14246&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-14246
            //
            return payload;
        } else {
            return privacyFilter.filter(payload, privacySettings);
        }
    };

    fluid.defaults("gpii.request.flowManager.privacyFilteredMatchMakingRequest", {
        gradeNames: ["gpii.request.flowManager.matchMakingRequest", "autoInit"],
        components: {
            privacyFilter: {
                type: "gpii.flowManager.privacy.privacyFilter",
                options: {
                    members: {
                        settingsToPrivacyTransformRules: gpii.request.flowManager.privacy.settingsToPrivacyTransformRules,
                        privacyToSettingsTransformRules: gpii.request.flowManager.privacy.privacyToSettingsTransformRules
                    }
                }
            }
        },
        events: {
            onPrivacySettings: null,
            onReadyToMatchWithPrivacyFiltering: {
                events: {
                    readyToMatch: "onReadyToMatch",
                    privacySettings: "onPrivacySettings"
                },
                args: "{arguments}.readyToMatch.0"
            }
        },
        listeners: {
            onReadyToMatchWithPrivacyFiltering: "{that}.processMatch",
            processMatch: { // Contribute our filter into the middle of the chain
                priority: gpii.request.flowManager.processMatch.priorities.privacyFilter,
                namespace: "privacyFilter",
                listener: "gpii.request.flowManager.doPrivacyFilter",
                args: ["{privacyFilter}", "{arguments}.0", "{request}.isAnonymousToken", "{request}.privacySettings"]
            }
        }
    });

    gpii.request.flowManager.setUserToken = function (handler, userToken) {
        handler.userToken = userToken;
    };

    fluid.defaults("gpii.request.flowManager.sessionAware", {
        gradeNames: ["fluid.littleComponent", "autoInit"],
        components: {
            lifecycleManager: "{flowManager}.lifecycleManager"
        },
        invokers: {
            getActiveSessionTokens: {
                func: "{lifecycleManager}.getActiveSessionTokens"
            },
            withSession: {
                funcName: "gpii.request.flowManager.sessionAware.withSession",
                args: ["{that}", "{flowManager}.lifecycleManager", "{requestProxy}.events", "{arguments}.0", "{arguments}.1"]
            }
        }
    });

    gpii.request.flowManager.sessionAware.withSession = function (that, lifecycleManager, events, callback, failMessage) {
        var userTokens = that.getActiveSessionTokens();
        if (userTokens.length === 0) {
            failMessage = failMessage || "Error handling request which required active session, but none was active";
            events.onError.fire({
                isError: true,
                statusCode: 401,
                message: failMessage
            });
        } else {
            var session = lifecycleManager.getSession(userTokens);
            callback(session, userTokens);
        }
    };

    fluid.registerNamespace("gpii.multiServerKettleConfig");

    gpii.multiServerKettleConfig.template = {
        components: {
            server: {
                type: "fluid.eventedComponent",
                options: {
                    gradeNames: "autoInit",
                    components: null, // To be filled in
                    events: {
                        onListen: {
                            events: null // To be filled in
                        },
                        onStopped: {
                            events: null // To be filled in
                        }
                    },
                    invokers: {
                        stop: {
                            funcName: "gpii.multiServerKettleConfig.stopServers",
                            args: null // To be filled in
                        }
                    }
                }
            }
        }
    };

    gpii.multiServerKettleConfig.build = function (servers) {
        // Build multi-server config parts

        var components = {};
        var onListenEvents = {};
        var onStoppedEvents = {};
        var serverPaths = [];
        fluid.each(servers, function (server, serverName) {
            components[serverName] = gpii.multiServerKettleConfig.buildComponentForConfig(server.configName, server.configPath);
            onListenEvents["onListen" + serverName] = "{" + serverName + "}.server.events.onListen";
            onStoppedEvents["onStopped" + serverName] = "{" + serverName + "}.server.events.onStopped";
            serverPaths.push("{" + serverName + "}.server");
        });

        // Make new grade

        var newGradeDef = fluid.copy(gpii.multiServerKettleConfig.template);
        fluid.set(newGradeDef, "components.server.options.components", components);
        fluid.set(newGradeDef, "components.server.options.events.onListen.events", onListenEvents);
        fluid.set(newGradeDef, "components.server.options.events.onStopped.events", onStoppedEvents);
        fluid.set(newGradeDef, "components.server.options.invokers.stop.args", [serverPaths]);

        var newGradeName = "multiServerKettleConfig." + fluid.allocateGuid();
        fluid.defaults(newGradeName, newGradeDef);

        return newGradeName;
    };

    gpii.multiServerKettleConfig.buildComponentForConfig = function (configName, configPathExpression) {
        var baseDirs = fluid.getMembers(fluid.module.modules, "baseDir");
        var config = fluid.copy(fluid.defaults(kettle.config.createDefaults({
            configName: configName,
            configPath: fluid.stringTemplate(configPathExpression, baseDirs)
        })));
        delete config.gradeNames;
        return {
            type: "fluid.eventedComponent",
            options: config
        };
    };

    gpii.multiServerKettleConfig.stopServers = function (servers) {
        fluid.each(servers, function (server) {
            server.stop();
        });
    };

})();
