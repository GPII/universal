/*!
GPII Full SHA Revision DataSource

Copyright 2020 OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

"use strict";

var fluid = require("infusion"),
    fs = require("fs"),
    gpii = fluid.registerNamespace("gpii");

require("kettle");

fluid.registerNamespace("gpii.flowManager.repositorySolutionsLoader");

fluid.defaults("gpii.flowManager.repositorySolutionsLoader", {
    gradeNames: ["kettle.dataSource.URL"],
    urlTemplate: "%prefix/%revision/%suffix/%fileName",
    url: {
        expander: {
            funcName: "fluid.stringTemplate",
            args: ["{that}.options.urlTemplate", {
                prefix: "{that}.options.urlPrefix",
                suffix: "{that}.options.urlSuffix"
            }]
        }
    },
    termMap: {
        revision: "%directRevision",
        fileName: "%directFileName"
    },
    // The URL prefix and suffix are distributed from a config file such as
    // e.g., gpii.flowManager.config.local.base, as is the path to the local
    // folder in which to save the contents of the downloaded solutions registry
    // file.
    urlPrefix: "",
    urlSuffix: "",
    solutionsRegistryfolderPath: "",
    members: {
        // Contents of the solutions registry file downloaded from the source
        // code repository
        solutionsRegistry: null
    },
    components: {
        encoding: {
            type: "kettle.dataSource.encoding.JSON5"
        }
    },
    invokers: {
        getSolutions: {
            funcName: "gpii.flowManager.repositorySolutionsLoader.getSolutions",
            args: ["{that}", "{arguments}.0", "{arguments}.1"]
                             // gpii revision, base file name
        },
        saveToDisk: {
            funcName: "gpii.flowManager.repositorySolutionsLoader.saveToDisk",
            args: ["{arguments}.0", "{arguments}.1", "{arguments}.2"]
                   // solutions,     path to folder, file name
        }
    }
});

/**
 * Retrieve the solutions registry JSON file from the source code repository.
 * @param {Component} that - An instance of gpii.flowManager.repositorySolutionsLoader:
 * @param {Component} that.solutionsRegistry - The contents of the solutions
 *      registry fetched from the source code repository.
 * @param {String} gpiiRevision - the SHA256 revision of the repository to fetch.
 * @param {String} fileName - the name of the json file containing the
 *                            solutions registry
 * @return {Promise} A promise whose resolved value is eiher the solutions
 *      registry, or, if there is an error, an object with an "isError: true"
 *      property.
 */
gpii.flowManager.repositorySolutionsLoader.getSolutions = function (that, gpiiRevision, fileName) {
    var togo = fluid.promise();
    debugger;
    if (gpiiRevision && fileName) {
        debugger;
        var solutionsPromise = that.get({
            directRevision: gpiiRevision,
            directFileName: fileName
        });
        solutionsPromise.then(function (solutions) {
            debugger;
            that.solutionsRegistry = solutions;
            fluid.promise.follow(solutionsPromise, togo);
            var actualPath = fluid.module.resolvePath(that.options.solutionsRegistryfolderPath);
            that.saveToDisk(solutions, actualPath, fileName);
        }, function (err) {
            debugger;
            fluid.log(
                "Error retrieving solutions from repository: " + err + that.options.url
            );
            togo.resolve(err);
        });
    } else {
        var msg = "Error retrieving solutions from repository: missing ";
        if (!gpiiRevision && !fileName) {
            msg += "revision and file name";
        }
        else if (!gpiiRevision) {
            msg += "revision";
        }
        else {
            msg += "file name";
        }
        fluid.log(msg);
        togo.resolve({isError: true, message: msg, statusCode: 404});
    }
    return togo;
};

/**
 * Save the solutions registry as a local JSON5 file.  If the given folder does
 * not exist, the error is logged and the function returns.
 * @param {Object} solutions - A set of solutions registry entries.
 * @param {String} path - Full path to the folder to write to.
 * @param {Stirng} fileName - Name of the file.
 */
gpii.flowManager.repositorySolutionsLoader.saveToDisk = function (solutions, path, fileName) {
    if (!fs.existsSync(path)) {
        debugger;
        fluid.log("Folder to store solutions '", fileName, "' is missing: '" , path, "'");
        return;
    } else {
        debugger;
        fileName = "foo" + fileName;
        var fileContents = JSON.stringify(solutions, null, 4) + "\n";
        fs.writeFileSync(path + fileName, fileContents);
    }
};
