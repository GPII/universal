/*!
GPII Full SHA Revision DataSource

Copyright 2020 OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

"use strict";

var fluid = require("infusion"),
    fs = require("fs"),
    gpii = fluid.registerNamespace("gpii");

require("kettle");

fluid.registerNamespace("gpii.flowManager.repositorySolutionsLoader");

fluid.defaults("gpii.flowManager.repositorySolutionsLoader", {
    gradeNames: ["kettle.dataSource.URL"],
    urlTemplate: "%prefix/%revision/%suffix/%fileName",
    url: {
        expander: {
            funcName: "fluid.stringTemplate",
            args: ["{that}.options.urlTemplate", {
                prefix: "{that}.options.urlPrefix",
                suffix: "{that}.options.urlSuffix"
            }]
        }
    },
    termMap: {
        revision: "%directRevision",
        fileName: "%directFileName"
    },
    // prefix and suffix are distributed from a config file such as
    // e.g., gpii.flowManager.config.local
    urlPrefix: "",
    urlSuffix: "",
    
    folderPath: "%gpii-universal/testData/solutions/", // move to appropriate config
    
    members: {
        // Revision and name of the solutions registry file are set by the
        // local flowManger at startup; see LFM.computeSolutionsRegistryURL()
        gpiiRevision: "",
        fileName: "",
        
        solutionsRegistry: null
    },
    components: {
        encoding: {
            type: "kettle.dataSource.encoding.JSON5"
        }
    },
    invokers: {
        getSolutions: {
            funcName: "gpii.flowManager.repositorySolutionsLoader.getSolutions",
            args: ["{that}"]
        },
        saveToDisk: {
            funcName: "gpii.flowManager.repositorySolutionsLoader.saveToDisk",
            args: ["{arguments}.0", "{arguments}.1", "{arguments}.2"]
                   // solutions,     path to folder, file name
        }
    }
});

/**
 * Retrieve the solutions registry JSON file from the source code repository.
 * @param {Component} that - An instance of gpii.flowManager.repositorySolutionsLoader.
 * @return {Promise} A promise whose resolved value is eiher the solutions
 *      registry, or, if there is an error, an object with an "isError: true"
 *      property.
 */
gpii.flowManager.repositorySolutionsLoader.getSolutions = function (that) {
    var togo = fluid.promise();
    
    if (that.gpiiRevision && that.fileName) { // need this test?
        debugger;
        var solutionsPromise = that.get({
            directRevision: that.gpiiRevision,
            directFileName: that.fileName
        });
        solutionsPromise.then(function (solutions) {
            debugger;
            that.solutionsRegistry = solutions; // write out the file?
            fluid.promise.follow(solutionsPromise, togo);
            var actualPath = fluid.module.resolvePath(that.options.folderPath);
            that.saveToDisk(solutions, actualPath, that.fileName);
        }, function (err) {
            debugger;
            fluid.log(
                "Error retrieving solutions from repository: " + err + that.options.url
            );
            togo.resolve(err);
        });
    } else {
        var msg = "Error retrieving solutions from repository: missing "
        if (!that.gpiiRevision && !that.fileName) {
            msg += "revision and file name";
        }
        else if (!that.gpiiRevision) {
            msg += "revision";
        }
        else {
            msg += "file name";
        }
        fluid.log(msg);
        togo.resolve({isError: true, message: msg, statusCode: 404});
    }
    return togo;
};

/**
 * Save the solutions registry as a local JSON5 file.  If the given folder does
 * not exist, the error is logged and the function returns.
 * @param {Object} solutions - A set of solutions registry entries.
 * @param {String} path - Full path to the folder to write to.
 * @param {Stirng} fileName - Name of the file.
 */
gpii.flowManager.repositorySolutionsLoader.saveToDisk = function (solutions, path, fileName) {
    if (!fs.existsSync(path)) {
        debugger;
        fluid.log("Folder to store solutions '", fileName, "' is missing: '" , path, "'");
        return;
    } else {
        debugger;
        fileName = "foo" + fileName;
        fs.writeFileSync(path + fileName, JSON.stringify(solutions, null, 4));
    }
};

