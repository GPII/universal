/**
 * GPII Cloud-Based FlowManager
 *
 * Copyright 2013 OCAD University
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion"),
    $ = fluid.registerNamespace("jQuery"),
    gpii = fluid.registerNamespace("gpii");

require("gpii-oauth2");

/** BASE, UNSECURED CLOUD-BASED FLOW MANAGER -
 * This will be maintained for a while in parallel with the OAuth2-secured API and eventually deprecated
 * This exposes an unsecured HTTP GET API of the form /:userToken/settings/:device
 */

fluid.defaults("gpii.flowManager.cloudBased", {
    gradeNames: ["autoInit", "fluid.littleComponent"],
    components: {
        deviceReporterDataSource: {
            type: "fluid.emptySubcomponent"
        }
    },
    urls: {
        deviceReporter: ""
    },
    handlers: {
        settings: {
            route: "/:userToken/settings/:device",
            type: "get"
        },
        userLogin: null,
        userLogout: null,
        getUserToken: null
    }
});

// unsecured endpoint - will be removed in time
gpii.request.flowManager.onSettings = function (onError, userToken, handler, deviceString) {
    var deviceContext;
    try {
        deviceContext = JSON.parse(deviceString);
    } catch (ex) { // TODO: add proper parse fail feedback using jsonlint scheme to appear in Kettle with KETTLE-31
        onError.fire({
            isError: true,
            message: "Cloud based flow manager requires device information - failed to parse " + deviceString
        });
        return;
    }
    handler.events.onUserToken.fire(userToken);
    handler.events.onDeviceContext.fire(deviceContext);
};

gpii.flowManager.cloudBased.matchToSettings = function (finalPayload, event) {
    var lifecycleInstructions = finalPayload.lifecycleInstructions;
    var settings = {};
    fluid.each(lifecycleInstructions, function processSolution(solution, solutionId) {
        fluid.each(solution.settingsHandlers, function (settingsHandler) {
            if (settingsHandler.settings) {
                settings[solutionId] = settingsHandler.settings;
            }
        });
    });
    event.fire(settings);
};

// TODO: This component is in an absurd namespace
fluid.defaults("kettle.requests.request.handler.settings", {
    gradeNames: ["fluid.littleComponent", "gpii.request.flowManager.matchMakingRequest", "autoInit"],
    invokers: {
        handle: {
            funcName: "gpii.request.flowManager.onSettings",
            args: ["{requestProxy}.events.onError", "{request}.req.params.userToken", "{that}", "{request}.req.params.device"],
            dynamic: true
        },
        matchToSettings: {
            funcName: "gpii.flowManager.cloudBased.matchToSettings",
            args: ["{arguments}.0", "{requestProxy}.events.onSuccess"]
        }
    },
    listeners: {
        onMatchDone: "{that}.matchToSettings"
    }
});

/** BEGIN OAUTH2-SECURED CLOUD-BASED FLOW MANAGER */

fluid.defaults("gpii.flowManager.cloudBased.oauth2", {
    gradeNames: ["fluid.littleComponent", "autoInit"],
    components: {
        oauth2DataStore: {
        // TODO: We will not have implemented a signup UI and persistence for a while. For current demonstrations, we will need
        // to seed the implementation here with material similar to that which appears at
        // gpii-oauth2-datastore/src/DataStoreWithSampleData.js in order to prepopulate the system with a usable collection of
        // OAuth2 client services and users.
            type: "gpii.oauth2.inMemoryDataStore"
        },
        authServer: {
        // note that this subcomponent directly attaches express routes to our underlying express app via its direct API -
        // e.g. at the paths /login, /authorize as well as mounting infusion at /infusion and the entire privacy UI at /privacy
            type: "gpii.oauth2.authServer",
            options: {
                components: {
                    dataStore: "{gpii.oauth2.dataStore}"
                },
                members: {
                    expressApp: "{kettle.server}.expressApp"
                },
                events: {
                    onContributeMiddleware: "{kettle.server}.events.onContributeMiddleware",
                    onContributeRouteHandlers: "{kettle.server}.events.onContributeRouteHandlers"
                }
            }
        },
        deviceReporterDataSource: {
            type: "fluid.emptySubcomponent"
        }
    },
    urls: {
        deviceReporter: ""
    },
    handlers: {
        oauth2Settings: {
            route: "/settings",
            type: "get"
        },
        userLogin: null,
        userLogout: null,
        getUserToken: null
    }
});

// TODO: This component is in an absurd namespace
fluid.defaults("kettle.requests.request.handler.oauth2Settings", {
    gradeNames: ["fluid.littleComponent", "kettle.requests.request.handler.settings", "autoInit"],
    invokers: {
        handle: {
            funcName: "gpii.request.flowManager.onOauth2Settings",
            args: ["{request}", "{that}", "{gpii.flowManager.cloudBased.oauth2}.oauth2DataStore"],
            dynamic: true
        }
    },
    listeners: {
        processMatch: { // Contribute our filter into the middle of the chain
            priority: gpii.request.flowManager.processMatch.priorities.privacyFilter,
            namespace: "privacyFilter",
            funcName: "gpii.flowManager.cloudBased.privacy.filter",
            args: ["{arguments}.0", "{request}.selectedPreferences"]
        }
    }
});

fluid.registerNamespace("gpii.flowManager.cloudBased.privacy");

// TODO: Restore the ability of the ontology manager to straightforwardly form single transforms and remove this hard-coded path

gpii.flowManager.cloudBased.privacy.reverseTransform = fluid.require("${universal}/testData/ontologies/privacy-flat.json");
gpii.flowManager.cloudBased.privacy.forwardTransform = fluid.model.transform.invertConfiguration(gpii.flowManager.cloudBased.privacy.reverseTransform);

gpii.flowManager.cloudBased.privacy.applyFilterRules = function (settings, rules) {
    var holder = {
        model: {}
    };
    var applier = fluid.makeNewChangeApplier(holder);
    fluid.each(rules, function (value, path) {
        if (value) {
            var fetched = fluid.get(settings, path);
            applier.change(path, fetched); // TODO: Apparently fluid.set is not good enough to deal with change at root
        }
    });
    return holder.model;
};


gpii.flowManager.cloudBased.privacy.filterOneApplication = function (application, selectedPreferences) {
    var settings = application.settings;
    var settingsInPrivacy = fluid.model.transformWithRules(settings, gpii.flowManager.cloudBased.privacy.forwardTransform);
    fluid.log("GOT SETTINGS IN PRIVACY ONTOLOGY " + JSON.stringify(settingsInPrivacy, null, 2));
    var filteredSettings = gpii.flowManager.cloudBased.privacy.applyFilterRules(settingsInPrivacy, selectedPreferences);
    fluid.log("GOT FILTERED SETTINGS " + JSON.stringify(filteredSettings, null, 2));
    var backSettings = fluid.model.transformWithRules(filteredSettings, gpii.flowManager.cloudBased.privacy.reverseTransform);
    var filteredApplication = fluid.copy(fluid.censorKeys(application, ["settings"]));
    filteredApplication.settings = backSettings;
    fluid.log("RETURNING FILTERED APPLICATION " + JSON.stringify(filteredApplication, null, 2));
    return filteredApplication;
};

gpii.flowManager.cloudBased.privacy.filter = function (contextPayload, selectedPreferences) {
    fluid.log("|||||| PRIVACY FILTER executing with contextPayload " + JSON.stringify(contextPayload, null, 2) + "\n and selectedPreferences " + JSON.stringify(selectedPreferences, null, 2));
    var applications = contextPayload.activeConfiguration.applications;
    var filteredApplications = fluid.transform(applications, function (application) {
        return gpii.flowManager.cloudBased.privacy.filterOneApplication(application, selectedPreferences);
    });
    var filteredPayload = $.extend({}, contextPayload);
    // TODO: create helpful "copy-on-write" suite of utilities to help with all of this standard manipulation involving "megapayloadism"
    var activeConfigurationCopy = fluid.copy(fluid.censorKeys(contextPayload.activeConfiguration, ["applications"]));
    activeConfigurationCopy.applications = filteredApplications;
    filteredPayload.activeConfiguration = activeConfigurationCopy;
    return filteredPayload;
};

gpii.oauth2.sendUnauthorized = function (request) {
    request.events.onError.fire({
            isError: true,
            message: "Unauthorized",
            statusCode: 401
        });
};

gpii.flowManager.cloudBased.solutionToDeviceContext = function (solutionId) {
    return {
        OS: {
            id: "web"
        },
        solutions: [ {
            id: solutionId
        }]
    };
};

gpii.request.flowManager.onOauth2Settings = function (request, handler, dataStore) {
    var accessToken = gpii.oauth2.parseBearerAuthorizationHeader(request.req);
    if (!accessToken) {
        gpii.oauth2.sendUnauthorized(request);
    } else {
        var auth = dataStore.findAuthByAccessToken(accessToken);
        if (!auth) {
            gpii.oauth2.sendUnauthorized(request);
        } else {
            fluid.log("Got AUTH DECISION: " + JSON.stringify(auth, null, 2));
            request.selectedPreferences = auth.selectedPreferences;
            handler.events.onUserToken.fire(auth.userGpiiToken);
            handler.events.onDeviceContext.fire(gpii.flowManager.cloudBased.solutionToDeviceContext(auth.oauth2ClientId));
        }
    }
};
