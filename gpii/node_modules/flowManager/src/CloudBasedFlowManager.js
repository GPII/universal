/**
 * GPII Cloud-Based FlowManager
 *
 * Copyright 2013 OCAD University
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion"),
    kettle = require("kettle"),
    gpii = fluid.registerNamespace("gpii");

require("gpii-oauth2");

/** BASE, UNSECURED CLOUD-BASED FLOW MANAGER -
 * This will be maintained for a while in parallel with the OAuth2-secured API and eventually deprecated
 * This exposes an unsecured HTTP GET API of the form /:userToken/settings/:device
 */

fluid.defaults("gpii.flowManager.cloudBased", {
    requestHandlers: {
        settings: {
            route: "/:userToken/settings/:device",
            method: "get",
            type: "gpii.flowManager.cloudBased.settings.handler"
        },
        userLogin: null,
        userLogout: null,
        getUserToken: null
    }
});

gpii.flowManager.cloudBased.matchToSettings = function (flowManager, finalPayload, event) {
    var inferredConfiguration = fluid.get(finalPayload, [ "matchMakerOutput", "inferredConfiguration", "gpii-default"]) || {};
    var lifecycleInstructions = flowManager.transformer.configurationToSettings(inferredConfiguration, finalPayload.solutionsRegistryEntries);
    var settings = {};
    fluid.each(lifecycleInstructions, function processSolution(solution, solutionId) {
        fluid.each(solution.settingsHandlers, function (settingsHandler) {
            if (settingsHandler.settings) {
                settings[solutionId] = settingsHandler.settings;
            }
        });
    });
    event.fire(settings);
};

fluid.defaults("gpii.flowManager.cloudBased.settings.handler", {
    gradeNames: ["kettle.request.http", "gpii.flowManager.nonPrivacyFilteredMatchMakingRequest"],
    invokers: {
        handleRequest: {
            funcName: "gpii.flowManager.cloudBased.settings.handleRequest",
            args: ["{request}.events.onError", "{request}.req.params.userToken", "{that}", "{request}.req.params.device"]
        },
        matchToSettings: {
            funcName: "gpii.flowManager.cloudBased.matchToSettings",
            args: ["{flowManager}", "{arguments}.0", "{request}.events.onSuccess"]
        }
    },
    listeners: {
        onMatchDone: "{that}.matchToSettings"
    }
});

// unsecured endpoint - will be removed in time
// TODO: However, this now receives direct dispatch from untrusted workflow gpii.request.flowManager.onUntrustedSettings below
gpii.flowManager.cloudBased.settings.handleRequest = function (onError, userToken, handler, deviceString) {
    var deviceContext;
    try {
        deviceContext = kettle.JSON.parse(deviceString);
    } catch (ex) {
        onError.fire({
            isError: true,
            message: "Cloud based flow manager requires device information - failed to parse " + ex.message
        });
        return;
    }
    handler.events.onUserToken.fire(userToken);
    handler.events.onDeviceContext.fire(deviceContext);
};

/** BEGIN OAUTH2-SECURED CLOUD-BASED FLOW MANAGER */

fluid.defaults("gpii.flowManager.cloudBased.oauth2", {
    gradeNames: ["fluid.component"],
    components: {
        oauth2DataStore: {
        // TODO: We will not have implemented a signup UI and persistence for a while. For current demonstrations, we will need
        // to seed the implementation here with material similar to that which appears at
        // gpii-oauth2-datastore/src/DataStoreWithSampleData.js in order to prepopulate the system with a usable collection of
        // OAuth2 client services and users.
        // TODO: The above comment needs to be updated when the configuration for using dbDataStore is settled.
            type: "gpii.oauth2.dbDataStore"
        },
        authServer: {
        // note that this subcomponent directly attaches express routes to our underlying express app via its direct API -
        // e.g. at the paths /login, /authorize as well as mounting infusion at /infusion and the entire privacy UI at /privacy
            type: "gpii.oauth2.authServer",
            options: {
                components: {
                    dataStore: "{gpii.oauth2.dataStore}"
                },
                members: {
                    expressApp: "{kettle.server}.expressApp"
                },
                events: {
                    onContributeMiddleware: "{kettle.server}.events.onContributeMiddleware",
                    onContributeRouteHandlers: "{kettle.server}.events.onContributeRouteHandlers"
                }
            }
        },
        userService: {
            type: "gpii.oauth2.userService"
        },
        authGrantFinder: {
            type: "gpii.oauth2.authGrantFinder"
        }
    },
    distributeOptions: {
        setDataStoreOnAuthGrantFinder: {
            record: "{gpii.oauth2.dataStore}",
            target: "{that gpii.oauth2.authorizationService}.options.components.dataStore"
        },
        setDataStoreOnUserService: {
            record: "{gpii.oauth2.dataStore}",
            target: "{that gpii.oauth2.userService}.options.components.dataStore"
        }
    },
    requestHandlers: {
        // The endpoint for web preferences consumers. The filtered preferences
        // set is returned, based on user-defined privacy policy for the web
        // consumer that sends requests to this endpoint.
        oauth2Settings: {
            route: "/settings",
            method: "get",
            type: "gpii.flowManager.cloudBased.oauth2settings.handler"
        },
        // The endpoint for GPII app installations. The filtered lifecycle instructions
        // are returned, based on user-defined privacy policies for onboarded solutions
        // that are available for the GPII app installation that sends requests to this
        // endpoint.
        untrustedSettings: {
            route: "/:userToken/untrusted-settings/:device",
            method: "get",
            type: "gpii.flowManager.cloudBased.untrustedSettings.handler"
        },
        userLogin: null,
        userLogout: null,
        getUserToken: null
    }
});

// Filter by privacy policy defined for web preferences consumer clients
fluid.defaults("gpii.flowManager.cloudBased.oauth2settings.handler", {
    gradeNames: ["kettle.request.http", "gpii.flowManager.privacyFilteredMatchMakingRequest"],
    invokers: {
        handleRequest: {
            funcName: "gpii.flowManager.cloudBased.oauth2settings.handleRequest",
            args: ["{request}", "{that}", "{gpii.flowManager.cloudBased.oauth2}.authGrantFinder"]
        },
        matchToSettings: {
            funcName: "gpii.flowManager.cloudBased.matchToSettings",
            args: ["{flowManager}", "{arguments}.0", "{request}.events.onSuccess"]
        }
    },
    listeners: {
        onMatchDone: "{that}.matchToSettings"
    }
});

gpii.flowManager.cloudBased.solutionToDeviceContext = function (solutionId) {
    return {
        OS: {
            id: "web"
        },
        solutions: [ {
            id: solutionId
        }]
    };
};

gpii.flowManager.cloudBased.oauth2settings.handleRequest = function (request, handler, authGrantFinder) {
    var accessToken = gpii.oauth2.parseBearerAuthorizationHeader(request.req);
    if (!accessToken) {
        request.events.onError.fire(gpii.oauth2.errors.unauthorized);
    } else {
        var authorizationPromise = authGrantFinder.getGrantForAccessToken(accessToken);
        authorizationPromise.then(function (authorization) {
            if (!authorization) {
                request.events.onError.fire(gpii.oauth2.errors.unauthorized);
            } else {
                fluid.log("Got AUTHORIZATION: " + JSON.stringify(authorization, null, 2));
                request.privacySettings = {};
                request.privacySettings[authorization.oauth2ClientId] = authorization.selectedPreferences;
                handler.events.onPrivacySettings.fire();
                handler.events.onUserToken.fire(authorization.gpiiToken);
                handler.events.onDeviceContext.fire(gpii.flowManager.cloudBased.solutionToDeviceContext(authorization.oauth2ClientId));
            }
        }, function () {
            request.events.onError.fire(gpii.oauth2.errors.unauthorized);
        });
    }
};

// Filter by privacy policy defined for onboarded solution clients
fluid.defaults("gpii.flowManager.cloudBased.untrustedSettings.handler", {
    gradeNames: ["kettle.request.http", "gpii.flowManager.privacyFilteredMatchMakingRequest"],
    invokers: {
        handleRequest: {
            funcName: "gpii.flowManager.cloudBased.untrustedSettings.handleRequest",
            args: [
                "{request}.events.onError",
                "{request}",
                "{request}.req.params.userToken",
                "{request}.req.params.device",
                "{gpii.flowManager.cloudBased.oauth2}.userService"
            ]
        },
        matchToUntrustedSettings: {
            funcName: "gpii.flowManager.cloudBased.matchToUntrustedSettings",
            args: ["{arguments}.0", "{request}.events.onSuccess"]
        }
    },
    listeners: {
        onMatchDone: "{that}.matchToUntrustedSettings"
    }
});

gpii.flowManager.cloudBased.untrustedSettings.handleRequest = function (onError, request, userToken, deviceString, userService) {
    request.privacySettings = {};

    // If the userToken has an associated user, then we retrieve the
    // user's privacy settings. Otherwise, we consider the request to
    // be for an "anonymous" token.

    // TODO: What if these calls on userService have rejected promises?

    userService.gpiiTokenHasAssociatedUser(userToken).then(function (hasAssociatedUser) {
        if (hasAssociatedUser) {
            request.isAnonymousToken = false;
            fluid.log("Is anonymous user token: " + request.isAnonymousToken);
            userService.getAuthorizedClientsByGpiiToken(userToken).then(function (authorizedClients) {
                if (authorizedClients) {
                    fluid.each(authorizedClients.onboardedSolutionClient, function (client) {
                        request.privacySettings[client.solutionId] = client.selectedPreferences;
                    });
                }
                fluid.log("User Privacy Settings: " + JSON.stringify(request.privacySettings));
                request.events.onPrivacySettings.fire();
            });
        } else {
            request.isAnonymousToken = true;
            fluid.log("Is anonymous user token: " + request.isAnonymousToken);
            request.events.onPrivacySettings.fire();
        }
    }, function (err) {
        fluid.log("cloudBased flowManager untrusted settings request failed with error ", err);
        request.events.onError.fire(gpii.oauth2.errors.unauthorized);
    });
    gpii.flowManager.cloudBased.settings.handleRequest(onError, userToken, request, deviceString);
};

gpii.flowManager.cloudBased.matchToUntrustedSettings = function (finalPayload, event) {
    // Note that we send the filtered preferences to assist a PCP - we may do more filtering here at some point
    var settings = fluid.filterKeys(finalPayload, [
        "userToken", "activeContextName", "preferences",
        "activeConfiguration", "solutionsRegistryEntries", "matchMakerOutput"
    ]);
    fluid.log("cloudBased flowManager sending settings ", settings);
    event.fire(settings);
};
