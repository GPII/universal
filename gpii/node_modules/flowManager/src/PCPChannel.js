"use strict";


var fluid = require("infusion");
var gpii = fluid.registerNamespace("gpii");

fluid.registerNamespace("gpii.flowManager");

// A mixin grade applied to the lifecycleManager's session by the pcpChannel
fluid.defaults("gpii.pcpChannel.sessionBinder", {
    modelRelay: {
        pcpChannel: {
            source: { // Not "" because of FLUID-6192
                segs: []
            },
            target: "{flowManager}.pcpChannel.model",
            singleTransform: {
                type: "gpii.pcpChannel.sessionToPCP",
                ontologyMetadata: "{ontologyHandler}.ontologyMetadata"
            },
            // compensate for FLUID-6194
            backward: "never",
            forward: {
                // avoid notifying the client for the init of LifecycleManagerSession, simplifies test and clients
                excludeSource: "init"
            }
        }
    },
    modelListeners: {
        updatePreferences: {
            path: "{flowManager}.pcpChannel.model.settingControls",
            includeSource: "PCP",
            funcName: "gpii.pcpChannel.updatePreferences",
            args: ["{pcpChannel}", "{flowManager}.lifecycleManager", "{change}.value", "{pcpChannel}.events.preferencesApplied"]
        },
        updateContext: {
            path: "{flowManager}.pcpChannel.model.activeContextName",
            includeSource: "PCP",
            funcName: "gpii.pcpChannel.updateContext",
            args: ["{flowManager}.contextManager", "{pcpChannel}", "{change}.value"]
        }
    }
});

/**
 * The PCP channel maintains its own model of the PCP state, it contains the following data:
 *
 * "userToken": "<token name>",           // currently logged in token - { type: "string" }
 * "activeContextName": "<context name>", // currently applied context - { type: "string" }
 * "settingControls": {                   // any number of preferences with values and schemas
 *      "<preference URI 1>": {           // settings URI, note that '.'s are interpreted as paths unless escaped
 *          "value": <value for preference>,   // the value that the given preference has
 *          "schema": { ... }                  // schema for the preference
 *      },
 *      "<preference URI 2>": { .. },
 *      "<preference URI N>": { .. }
 * },
 * "preferences": {                       // Used for listing available contexts and name of NP set
 *      "name": "My Preferences Set",
 *      "contexts": {
 *          "<context 1 name>": {         // the name/id of the context
 *              "name": "<human readable name>" // name to be displayed in the PCP
 *          }
 *          "<context 2 name>": {...},
 *          "<context n name>": {...}
 *      }
 *  }
 */
fluid.defaults("gpii.pcpChannel", {
    gradeNames: ["fluid.modelComponent"],
    members: {
        outputBlocked: null
    },
    distributeOptions: {
        // Not {lifecycleManager session} because of FLUID-6193
        target: "{flowManager lifecycleManager session}.options.gradeNames",
        record: "gpii.pcpChannel.sessionBinder"
    },
    listeners: {
        "{lifecycleManager}.events.onSessionStop": {
            namespace: "pcpChannel",
            funcName: "gpii.pcpChannel.sessionStop",
            args: "{pcpChannel}"
        }
    },
    events: {
        preferencesApplied: null
    }
});

gpii.pcpChannel.updatePreferences = function (pcpChannel, lifecycleManager, newPrefs, event) {
    fluid.log("Received preferences update from PCP UI of ", newPrefs);

    // Grab current session
    var session = lifecycleManager.getSession(lifecycleManager.getActiveSessionTokens());

    // tweak payload to be in NP set format and update session
    var contextualPrefs = {};
    fluid.each(newPrefs, function (spec, pref) {
        fluid.set(contextualPrefs, fluid.pathUtil.parseEL(pref), spec.value);
    });

    session.applier.change(["preferences", "contexts", session.model.activeContextName, "preferences"], contextualPrefs);

    // get new inferred configuration to be applied:
    var newInferred = gpii.matchMakerFramework.utils.updateInferredConfiguration(session.model.preferences, session.model.matchMakerOutput.inferredConfiguration);

    // full payload from session:
    var fullPayload = fluid.extend(true, {}, session.model);
    fluid.set(fullPayload, ["matchMakerOutput", "inferredConfiguration"], newInferred);
    gpii.lifecycleManager.addLifecycleInstructionsToPayload(fullPayload);

    session.applier.change(["activeConfiguration"], fullPayload.activeConfiguration);

    lifecycleManager.update(fullPayload).then(event.fire);
};

gpii.pcpChannel.updateContext = function (contextManager, pcpChannel, newContext) {
    fluid.log("Received context update from PCP UI of ", newContext);
    // Abominable hack to avoid confusing client with numerous update messages. The ChangeApplier should really support
    // "manifest transactions" / "vertical transactions"
    pcpChannel.outputBlocked = fluid.promise();
    var clearBlock = function () {
        delete pcpChannel.outputBlocked;
    };
    pcpChannel.outputBlocked.then(clearBlock, clearBlock);
    pcpChannel.applier.change([], null, "DELETE");
    var promise = contextManager.contextChanged(newContext);
    if (promise) {
        fluid.promise.follow(promise, pcpChannel.outputBlocked);
    } else {
        pcpChannel.outputBlocked.resolve();
    }
};

gpii.pcpChannel.filterSolution = function (solution) {
    return {
        name: solution.name,
        settingsHandlers: fluid.transform(solution.settingsHandlers, function (oneHandler) {
            return fluid.filterKeys(oneHandler, ["supportedSettings"]);
        })
    };
};

/** Filter a supplied JSON schema object to remove the "default" value which is not used by the current UI
 * (specific observation by Gregg). Remove this function once the UI has developed support for rendering
 * unchanged values.
 */

gpii.pcpChannel.filterSchema = function (schema) {
    return schema && fluid.censorKeys(schema, "default");
};

/** Emit an entry in the `settingControls` block for a single setting.
 *
 * @param settingControls {Object} *This object will be modified by the function's action* One top-level member
 * will be added to this object, with a key given by composing the argument `keySegs`. The value of the
 * member will be a structure {SettingControl} consisting of
 *     @member value {Any} The actual value of the corresponding setting
 *     @member schema {JSONSchema} A JSON schema structure describing the value space of the setting
 *     @member solutionName {String} [optional] The solution name to which this setting is allocated in the preferences
 * document, if there is one. If it is defined as a top-level common term, this member will be omitted.
 *     @member liveness {String} the liveness value of the setting
 */

gpii.pcpChannel.emitSettingControl = function (settingControls, schema, prefVal, keySegs, liveness, solutionName) {
    var fullKey = fluid.pathUtil.composeSegments.apply(null, keySegs);
    if (schema) {
        settingControls[fullKey] = {
            value: prefVal,
            schema: gpii.pcpChannel.filterSchema(schema),
            solutionName: solutionName,
            liveness: liveness
        };
    }
};

/** Transduces the session model held for the currently logged-on user in the LifecycleManager's session into the model
 * structure which is suitable for shipping to the PCP over its bus. Each setting control output in the section
 * `settingControls` will be dumped using the utility `gpii.pcpChannel.emitSettingControl`. This is a model relay
 * function which is run continuously as the session's model is updated.
 * @param model {Object} The LifecycleManager's session model
 * @param transformSpec {ModelTransformSpec} The
 * @return {Object} The output model suitable for shipping to the PCP, including top-level members
 *     @member settingControls {Object} A hash keyed by preference path, whose values are {SettingControl} objects
 *     @member preferences {Object} A filtered skeleton of the user's preferences document, just containing the names
 * of `contexts`.
 */
gpii.pcpChannel.sessionToPCP = function (model, transformSpec) {
    var schemas = transformSpec.ontologyMetadata.flat.schemas;
    var outModel = fluid.filterKeys(model, ["userToken", "activeContextName"]);
    var settingControls = {};
    var activePreferences = fluid.get(model, ["preferences", "contexts", model.activeContextName, "preferences"]);
    var prefApplicationPrefix = "http://registry.gpii.net/applications/";

    fluid.each(activePreferences, function (prefsVal, prefsKey) {
        if (prefsKey.startsWith(prefApplicationPrefix)) {
            var solKey = prefsKey.substring(prefApplicationPrefix.length);
            var solution = model.solutionsRegistryEntries[solKey];
            if (solution) {
                fluid.each(prefsVal, function (innerPrefsVal, innerPrefsKey) {
                    var liveness = gpii.matchMakerFramework.utils.getLeastLiveness(innerPrefsKey, [ solution ]);
                    gpii.pcpChannel.emitSettingControl(settingControls, schemas[innerPrefsKey], innerPrefsVal, [prefsKey, innerPrefsKey], liveness, solution.name);
                });
            }
        } else {
            var activeSolutionIds = Object.keys(fluid.get(model, "activeConfiguration.inferredConfiguration.applications"));
            var activeSolutions = fluid.filterKeys(model.solutionsRegistryEntries, activeSolutionIds);
            var liveness = gpii.matchMakerFramework.utils.getLeastLiveness(prefsKey, activeSolutions);
            gpii.pcpChannel.emitSettingControl(settingControls, schemas[prefsKey], prefsVal, [prefsKey], liveness);
        }
    });
    outModel.settingControls = settingControls;
    outModel.preferences = {
        name: fluid.get(model, "preferences.name"),
        contexts: fluid.transform(fluid.get(model, "preferences.contexts"), function (contextVal) {
            return fluid.filterKeys(contextVal, ["name"]);
        })
    };
    return outModel;
};


gpii.pcpChannel.modelChangeListener = function (handler, pcpChannel, value, oldValue, path, transaction) {
    fluid.log("PCPChannel's PCP-facing modelChangeListener, sources are ", fluid.keys(transaction.sources));
    if (!transaction.sources.PCP) {
        fluid.log("Model change source is not PCP - candidate for update message");
        if (pcpChannel.outputBlocked) {
            // Ensure that we queue just a single outgoing message for when the channel unblocks
            if (!pcpChannel.outputBlocked.queued) {
                pcpChannel.outputBlocked.queued = true;
                pcpChannel.outputBlocked.then(function () {
                    fluid.log("PCPChannel sending unblocked full update message", JSON.stringify(pcpChannel.model, null, 2));
                    handler.sendTypedMessage("modelChanged", {path: [], type: "ADD", value: pcpChannel.model});
                });
            }
        } else {
            var changes = fluid.modelPairToChanges(value, oldValue);
            var hasDeletion = fluid.find(changes, function (change) {
                return change.type === "DELETE";
            });
            if (hasDeletion) {
                changes.forEach(function (change) {
                    handler.sendTypedMessage("modelChanged", change);
                });
            } else {
                handler.sendTypedMessage("modelChanged", {path: [], type: "ADD", value: value});
            }
        }
    }
};

gpii.pcpChannel.sessionStop = function (pcpChannel) {
    pcpChannel.applier.change("", null, "DELETE");
};

fluid.defaults("gpii.pcpChannel.handler", {
    gradeNames: ["kettle.request.ws"],
    invokers: {
        modelChangeListener: {
            funcName: "gpii.pcpChannel.modelChangeListener",
            args: ["{that}", "{pcpChannel}", "{arguments}.0", "{arguments}.1", "{arguments}.2", "{arguments}.4"]
            // value, oldValue, pathSegs, transaction: http://docs.fluidproject.org/infusion/development/ChangeApplierAPI.html#programmatic-style-for-listening-to-changes
        }
    },
    listeners: {
        onBindWs: {
            funcName: "gpii.pcpChannel.bindWs",
            args: ["{that}", "{pcpChannel}"]
        },
        "{pcpChannel}.events.preferencesApplied": {
            funcName: "{that}.sendTypedMessage",
            args: [ "preferencesApplied" ]
        },
        onReceiveMessage: {
            funcName: "gpii.pcpChannel.receiveMessage",
            args: ["{arguments}.1", "{pcpChannel}"]
        },
        "onDestroy.unbindModel": {
            func: "{pcpChannel}.applier.modelChanged.removeListener",
            args: ["{that}.id"]
        }
    }
});

gpii.pcpChannel.bindWs = function (handler, pcpChannel) {
    pcpChannel.applier.modelChanged.addListener("", handler.modelChangeListener, handler.id);
    // Note that this is inconsistent with the Nexus' protocol, but is more correct - for example if the model consists
    // purely of a primitive or is undefined, the initial Nexus message will break
    handler.sendTypedMessage("modelChanged", {path: [], type: "ADD", value: pcpChannel.model});
};

/**
 * Adjusts the preference message payload to match the local model. E.g. a preference change from the PCP has the
 * following path: [ "preferences", "http://registry\\.gpii\\.net/common/magnification" ] which should be
 * translated to something that matches the PCP Channels model, such as
 * [ "settingControls", "http://registry\\.gpii\\.net/common/magnification", "value" ]
 *
 * @param message {Object} the message recieved via the PCP socket. WARNING - note that the `path` value of
 *     this object will be modified.
 */
gpii.pcpChannel.adjustPreferenceMessage = function (message) {
    message.path[0] = "settingControls";
    message.path.push("value");
};

gpii.pcpChannel.receiveMessage = function (message, pcpChannel) {
    fluid.log("pcpChannel received a message: ", message);
    if (message.path && message.path[0] === "preferences") {
        gpii.pcpChannel.adjustPreferenceMessage(message);     // Modify to fit model if it is a change in preferences
    }
    pcpChannel.applier.change(message.path, message.value, "ADD", "PCP");
};
