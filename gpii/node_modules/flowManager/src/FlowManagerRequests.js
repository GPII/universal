/**
 * GPII Flow Manager Requests
 *
 * Copyright 2012 OCAD University
 * Copyright 2015 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

/* eslint-env browser */
/* eslint strict: ["error", "function"] */

(function () {

    "use strict";

    var fluid = require("infusion"),
        gpii = fluid.registerNamespace("gpii");

    fluid.registerNamespace("gpii.flowManager");

    gpii.logFully = function () {
        var oldRenderChars = fluid.logObjectRenderChars;
        fluid.logObjectRenderChars = 2 << 20;
        fluid.log.apply(null, arguments);
        fluid.logObjectRenderChars = oldRenderChars;
    };

    /** Render an instance of the "megapayload" which circulates amongst the FlowManager, MatchMaker, LifecycleManager etc. methods.
     * This builds up incrementally starting with the GPII key during logon until we reach the "finalPayload" dispatched to the
     * lifecycleManager. This method transforms the payload into a form appropriate for logging to the console as an aid
     * to diagnosing and debugging issues encountered in the field. Currently it only performs the action of suppressing the
     * body of any entries of `solutionsRegistryEntries` since these are bulky and can easily be recovered from the
     * solutions registry itself.
     * @param {Object} megapayload - A megapayload record.
     * @return {Object} The megapayload transformed to a more appropriate form for logging.
     */
    gpii.renderMegapayload = function (megapayload) {
        var solutionsRegistryEntries = fluid.transform(megapayload.solutionsRegistryEntries, function () {
            return "<consult solutions registry for full contents>";
        });
        return fluid.extend({}, megapayload, {
            solutionsRegistryEntries: solutionsRegistryEntries
        });
    };

    gpii.flowManager.logAndNotify = function (msg, event, callback) {
        return function (data) {
            gpii.logFully(msg, data);
            event.fire(callback ? callback(data) : data);
        };
    };

    gpii.flowManager.getPreferences = function (preferencesDataSource, request, event, gpiiKey) {
        fluid.log("gpii.flowManager.getPreferences called - fetching preferences from URL " + preferencesDataSource.options.url);
        var promise = preferencesDataSource.get({gpiiKey: gpiiKey});
        promise.then(function (data) {
            event.fire(data.preferences || data);
        }, function (err) {
            request.events.onError.fire({
                isError: true,
                message: "Error when retrieving preferences: " + err.message,
                statusCode: 404
            });
        });
    };

    /*
     * Asynchronous function which makes a get call to the solutions registry (1st parameter) to
     * retrieve the solutions registry matching what is passed in the `device` parameter.
     * This is appended to the matchmaker payload (mmpayload) parameter, which in turn is passed
     * as parameter in the event fired.
     *
     * @solutionsRegistryDataSource (Object) - a solutions registry data source
     * @deviceContext (Object) - output from a device reporter. Used to filter solutions registry entries
     * @event (Object) - Event to be fired when the solutionsRegistry entry has been retrieved
     * @onError (Object) - Event to be fired when an error occurs
     *
     * @return (undefined) - function is asynchronous and doesn't return anything. Instead the event
     *      is fired with the modified mmpayload.
     */
    gpii.flowManager.getSolutions = function (solutionsRegistryDataSource, deviceContext, event, onError) {
        var os = fluid.get(deviceContext, "OS.id");
        var promise = solutionsRegistryDataSource.get({});
        promise.then(function (solutions) {
            var solutionsRegistryEntries = gpii.matchMakerFramework.filterSolutions(solutions[os], deviceContext);
            fluid.log("Fetched filtered solutions registry entries: ", gpii.renderMegapayload({solutionsRegistryEntries: solutionsRegistryEntries}));
            event.fire(solutionsRegistryEntries, solutions);
        }, onError.fire);
    };

    // initialPayload contains fields
    //     gpiiKey, preferences, deviceContext, solutionsRegistryEntry
    // resulting from the initial fetch process
    gpii.flowManager.processMatch = function (that, initialPayload) {
        var promise = fluid.promise.fireTransformEvent(that.events.processMatch, initialPayload, {});
        promise.then(function (finalPayload) {
            that.events.onMatchDone.fire(finalPayload);
        }, function (error) { // TODO: This rejection handler is untested
            that.handlerPromise.reject(error);
        });
    };

    // This is a table of priorities for handlers in the "processMatch" filter chain governing the MatchMaking process.
    // This will be removed in favour of a relative constraints system once we have FLUID-5506 completed
    // Higher priority numbers are handled earlier than lower ones
    // This process is kicked off by the "onReadyToMatch" event defined in the "gpii.flowManager.matchMakingRequest" grade
    gpii.flowManager.processMatch.priorities = {
        // onReadyToMatch event signals start of process
        preProcess:           100,
        matchMakerDispatcher: 90
        // onMatchDone event fired to lifecycleManager or cloud-based settings endpoint
    };

    /* This component orchestrates the lifecycle for a component which assembles the raw materials required for the matchmaking
     *  process, invokes it, and distributes the results. These raw materials are the gpiiKey (of the user whose preferences are to
     *  be fetched), the device information for the current platform, and the registry of solutions which are available to be
     *  invoked. It is a request-scoped grade and intended as a mixin for a request handler such as kettle.request.http.
     *  This grade is used in the following places:
     *     UserLogonStateChange.js - where it coordinates the standard lifecycle for a user logging on to a local FlowManager
     *     CloudBasedFlowManager.js - where it coordinates the lifecycle for a user requesting settings from a cloud-based FlowManager
     */
    fluid.defaults("gpii.flowManager.matchMakingRequest", {
        invokers: {
            getPreferences: {
                funcName: "gpii.flowManager.getPreferences",
                args: ["{flowManager}.preferencesDataSource", "{request}", "{that}.events.onPreferences", "{that}.gpiiKey"]
            },
            processMatch: {
                funcName: "gpii.flowManager.processMatch",
                args: [ "{that}", "{arguments}.0"]
                // initial payload
            },
            getSolutions: {
                funcName: "gpii.flowManager.getSolutions",
                args: [ "{flowManager}.solutionsRegistryDataSource", "{arguments}.0", "{that}.events.onSolutions", "{request}.events.onError"]
            }
        },
        events: {
            // Four pre-requisites for the match process to begin
            onGpiiKey: null,
            onPreferences: null,
            onDeviceContext: null,
            onSolutions: null,
            // The "pseudo-event" whose handlers govern the match processing chain
            processMatch: null,
            // Output of the matching process - listeners in derived grades
            onMatchDone: null,
            // Boiled event which initiates the match process
            onReadyToMatch: {
                events: {
                    preferences: "onPreferences",
                    deviceContext: "onDeviceContext",
                    solutions: "onSolutions"
                },
                args: [{
                    gpiiKey: "{that}.gpiiKey",
                    preferences: "{arguments}.preferences.0",
                    deviceContext: "{arguments}.deviceContext.0",
                    solutionsRegistryEntries: "{arguments}.solutions.0",
                    fullSolutionsRegistry: "{arguments}.solutions.1"
                }]
            }
        },
        listeners: {
            "onGpiiKey.setGpiiKey": {
                listener: "gpii.flowManager.setGpiiKey",
                args: ["{that}", "{arguments}.0"]
            },
            "onGpiiKey.getPreferences": {
                func: "{that}.getPreferences",
                priority: "after:setGpiiKey"
            },
            "onDeviceContext.getSolutions": "{that}.getSolutions",
            processMatch: [{ // Definition of the MatchMaking processing chain
                priority: gpii.flowManager.processMatch.priorities.preProcess,
                namespace: "preProcess",
                listener: "gpii.matchMakerFramework.utils.preProcess"
            }, {
                priority: gpii.flowManager.processMatch.priorities.matchMakerDispatcher,
                namespace: "matchMakerDispatcher",
                listener: "{flowManager}.matchMakerFramework.matchMakerDispatcher"
            }],
            "onReadyToMatch.processMatch": "{that}.processMatch"
        }
    });


    gpii.flowManager.setGpiiKey = function (handler, gpiiKey) {
        handler.gpiiKey = gpiiKey;
    };

    /** A mixin request grade for requests which require an active user session to do their work. Exposes a method
      * withSession which will acquire the session tokens and supply them as an argument or else fail if none is available.
      */
    fluid.defaults("gpii.flowManager.sessionAware", {
        components: {
            lifecycleManager: "{flowManager}.lifecycleManager"
        },
        invokers: {
            getActiveSessionGpiiKeys: {
                func: "{lifecycleManager}.getActiveSessionGpiiKeys"
            },
            withSession: {
                funcName: "gpii.flowManager.sessionAware.withSession",
                args: ["{that}", "{flowManager}.lifecycleManager", "{arguments}.0", "{arguments}.1", "{arguments}.2"]
            }
        }
    });

    gpii.flowManager.sessionAware.withSession = function (that, lifecycleManager, onSuccess, failMessage, onError) {
        onError = onError || that.events.onError.fire;
        var gpiiKeys = that.getActiveSessionGpiiKeys();
        if (gpiiKeys.length === 0) {
            failMessage = failMessage || "Error handling request which required active session, but none was active";
            onError({
                isError: true,
                statusCode: 401,
                message: failMessage
            });
        } else {
            var session = lifecycleManager.getSession(gpiiKeys);
            onSuccess(session, gpiiKeys);
        }
    };

})();
