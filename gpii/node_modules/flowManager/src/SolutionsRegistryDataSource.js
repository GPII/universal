/*
 * GPII Solutions Registry Datasource
 *
 * Copyright 2016 RtF-I
 * Copyright 2020 OCAD University
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion"),
    gpii = fluid.registerNamespace("gpii"),
    fs = require("fs");

require("kettle");
require("./GpiiRevisionRequester.js");
require("./RepositorySolutionsLoader.js");

fluid.registerNamespace("gpii.flowManager.solutionsRegistry");

// The base solutions registry data source, containing information and functions
// shared by derived grades.
fluid.defaults("gpii.flowManager.solutionsRegistry.dataSource", {
    gradeNames: ["kettle.dataSource"],
    termMap: {
        "os": "%os",
        "version": "%version"
    },
    components: {
        encoding: {
            type: "kettle.dataSource.encoding.none"
        }
    },
    members: {
        fullSolutionsRegistry: null
    },
    invokers: {
        loadFromLocalDisk: {
            funcName: "gpii.flowManager.solutionsRegistry.dataSource.loadFromLocalDisk",
            args: ["{that}"]
        }
    },
    events: {
        loadSolutions: null,
        solutionsRegistryReady: null
    },
    listeners: {
        "onCreate.loadSolutions": {
            listener: "fluid.promise.fireTransformEvent",
            args: ["{that}.events.loadSolutions"]
        }
    }
});

/**
 * Load the solutions registry from the local file system -- the file system
 * that this solutions registry data source is running on.
 *
 * @param {Object} that - The gpii.flowManager.solutionsRegistry.dataSource.
 * @param {String} that.options.path - The path to the solutions registry
 *          directory.
 * @param {Object} that.fullSolutionsRegistry - This will be set to the
 *          collection of solution registries given by path.
 */
gpii.flowManager.solutionsRegistry.dataSource.loadFromLocalDisk = function (that) {
    fluid.log("TRACE:  SolutionsRegistryDataSource creation (", that.id, ") ... START");
    if (!that.options.path) {
        fluid.fail("The solutionsRegistry datasource ", that, " needs a \"path\" option pointing to the solution entries folder");
    }
    var url = fluid.module.resolvePath(that.options.path);
    if (!fs.existsSync(url)) {
        fluid.fail("The path provided to the solutionsRegistry datasource (", url, ") has not been found on the file system");
    }
    that.fullSolutionsRegistry = fluid.freezeRecursive(require(url));
    fluid.log("TRACE:  SolutionsRegistryDataSource creation (", that.id, ") ... END");
};

// Solutions registry data source used by the Cloud Based Flow Manager
fluid.defaults("gpii.flowManager.solutionsRegistry.dataSource.cloud", {
    gradeNames: ["gpii.flowManager.solutionsRegistry.dataSource"],
    readOnlyGrade: "gpii.flowManager.solutionsRegistry.dataSource.cloud",
    invokers: {
        getImpl: {
            funcName: "gpii.flowManager.solutionsRegistry.dataSource.cloud.handle",
            args: ["{that}", "{arguments}.1", "{arguments}.2"]
                             // options, directModel
        }
    },
    listeners: {
        "loadSolutions.loadFromLocalDisk": {
            listener: "{that}.loadFromLocalDisk",
            priority: "first"
        },
        "loadSolutions.solutionsLoaded": {
            listener: "gpii.flowManager.solutionsRegistry.dataSource.finishedLoading",
            args: ["{that}.events.solutionsRegistryReady"],
            priority: "after:loadFromLocalDisk"
        }
    }
});

/**
 * Handler for get requests to the solutions registry used by the Cloud Based
 * Flow Manager. It will return either an object containing solutions registries
 * for all platforms, or, if a platform is provided, only the solutions registry
 * for that platform will be returned.
 *
 * @param {Object} that - The gpii.flowManager.solutionsRegistry.dataSource.cloud
 * @param {Object} requestOptions - Currently the only request option supported
 *          is "os". If provided, the returned solutions registry will be
 *          filtered by OS version.
 * @return {Promise} A promise that will be resolved with results (see above) or
 *          rejected on error.
 */
gpii.flowManager.solutionsRegistry.dataSource.cloud.handle = function (that, requestOptions) {
    fluid.log("TRACE:  SolutionsRegistryDataSource return solutions (", that.id, ") ... START");
    var promise = fluid.promise();
    if (requestOptions.os) { // if "os" is defined, return only solution registry entries for that OS
        if (requestOptions.os in that.fullSolutionsRegistry) {
            fluid.log("TRACE:  SolutionsRegistryDataSource return SPECIFIED [", requestOptions.os, "] solutions (", that.id, ") ... END");
            promise.resolve(that.fullSolutionsRegistry[requestOptions.os]);
        } else {
            promise.reject({
                isError: true,
                message: "The requested OS (" + requestOptions.os + ") was not present in the solutions registry",
                statusCode: 404
            });
        }
    } else { // if no "os" is requested, return the full solutions registry
        fluid.log("TRACE:  SolutionsRegistryDataSource return ALL solutions (", that.id, ") ", that.fullSolutionsRegistry, "... END");
        promise.resolve(that.fullSolutionsRegistry);
    }
    return promise;
};

// Solutions registry datasource used by the Local Flow Manager.  It loads both
// solutions from the source code repository as well as the local file sysmtem.
fluid.defaults("gpii.flowManager.solutionsRegistry.dataSource.local", {
    gradeNames: ["gpii.flowManager.solutionsRegistry.dataSource"],
    components: {
        revisionRequester: {
            type: "gpii.flowmanager.revisionRequester"
        },
        repositorySolutionsLoader: {
            type: "gpii.flowManager.repositorySolutionsLoader"
        },
        platformReporter: {
            type: "gpii.platformReporter.native"
        }
    },
    readOnlyGrade: "gpii.flowManager.solutionsRegistry.dataSource.local",
    members: {
        repositorySolutionsRegistry: null
    },
    invokers: {
        getImpl: {
            funcName: "gpii.flowManager.solutionsRegistry.dataSource.local.handle",
            args: ["{that}", "{arguments}.1"]
                             // options
        }
    },
    listeners: {
        "loadSolutions.loadFromLocalDisk": {
            listener: "{that}.loadFromLocalDisk",
            priority: "first"
        },
        "loadSolutions.getRevision": {
            listener: "{revisionRequester}.getRevision",
            priority: "after:loadFromLocalDisk"
        },
        "loadSolutions.loadFromRepository": {
            listener: "gpii.flowManager.solutionsRegistry.dataSource.local.loadFromRepository",
            args: ["{that}", "{arguments}.0", "{that}.platformReporter"],
                             // revision
            priority: "after:getRevision"
        },
        "loadSolutions.solutionsLoaded": {
            listener: "gpii.flowManager.solutionsRegistry.dataSource.finishedLoading",
            args: ["{that}.events.solutionsRegistryReady"],
            priority: "after:loadFromRepository"
        }
    }
});

/**
 * Retrieve the solutions registry JSON file from the source code repository.
 * If successful, sets the repositorySolutionsRegistry member to the fetched
 * solutions registry.
 * @param {Component} that - An instance of gpii.flowManager.solutionsRegistry.dataSource
 * @param {Component} that.repositorySolutionsLoader - An instance of
 *                    gpii.flowManager.repositorySolutionsLoader.
 * @param {Object} that.repositorySolutionsRegistry - Set to point to the
 *                 solutions registry retrieved from the respository, or null if
 *                 none were retrieved.
 * @param {Object} revision - the SHA256 revision of the repository in the form:
 *                            { sha256: ... }.
 * @param {Component} platformReporter - used to get the name of the platform,
 *                                       e.g., "win32".
 * @return {Promise} A promise whose resolved value is eiher the solutions
 *      registry, or, if there is an error, an object with an "isError: true"
 *      property.
 */
gpii.flowManager.solutionsRegistry.dataSource.local.loadFromRepository = function (that, revision, platformReporter) {
    fluid.log("TRACE:  SRDS onCreate gets solutions from github ... START");
    var gpiiRevision = revision.sha256;
    var platformId = platformReporter.reportPlatform().id;
    var fileName = platformId + ".json5";
    var togo = that.repositorySolutionsLoader.getSolutions(gpiiRevision, fileName, platformId);
    togo.then(function () {
        // Either the solutions registry has been successfully retrieved from the
        // repository, or it hasn't.  Set that.repositorySolutionsRegistry to
        // whatever the result.
        that.repositorySolutionsRegistry = that.repositorySolutionsLoader.solutionsRegistry;
        fluid.log("TRACE:  SRDS onCreate gets solutions from github ... END");
    });
    return togo;
};

/**
 * Handler for get requests when running with the gpii-app client and the Local
 * Flow Manager.  If a solutions registry was retrieved from the source code
 * repository, it is used to mask the equivalent platform in the full set of
 * solutions registries.  This handler will return either an object containing
 * solutions registries for all platforms, or, if a platform is provided, only
 * the solutions registry for that platform will be returned.
 * @param {Object} that - The gpii.flowManager.solutionsRegistry.dataSource.local
          instance.
 * @param {Object} that.repositorySolutionsRegistry - The solutions registry
 *        for the client platform previously as from the repository.
 * @param {Object} that.fullSolutionsRegistry - The solutions registries loaded
 *        from the local file system.
 * @param {Object} requestOptions - Currently the only request option supported
 *        is "os". If provided, the returned solutions registry will be filtered
 *        by OS version.
 * @return {Promise} A promise that will be resolved with results (see above) or
 *         rejected on error.
 */
gpii.flowManager.solutionsRegistry.dataSource.local.handle = function (that, requestOptions) {
    fluid.log("TRACE:  LFM SolutionsRegistryDataSource return solutions (", that.id, ") ... START");
    var promise = fluid.promise();
    if (requestOptions && requestOptions.os) {
        if (that.repositorySolutionsRegistry && (requestOptions.os in that.repositorySolutionsRegistry)) {
            fluid.log("TRACE:  LFM SolutionsRegistryDataSource with OS (",  requestOptions.os, "), return repository solutions (", that.id, "... END");
            promise.resolve(that.repositorySolutionsRegistry);
        } else if (requestOptions.os in that.fullSolutionsRegistry) {
            fluid.log("TRACE:  LFM SolutionsRegistryDataSource with OS (",  requestOptions.os, "), returns local file system solutions (", that.id, ") ... END");
            promise.resolve(that.fullSolutionsRegistry[requestOptions.os]);
        } else {
            fluid.log("TRACE:  LFM SolutionsRegistryDataSource no such OS (", requestOptions.os, "); (", that.id, ") ... END");
            promise.reject({
                isError: true,
                message: "The requested OS (" + requestOptions.os + ") was not present in the solutions registry",
                statusCode: 404
            });
        }
    } else {
        // No platform requested -- return all of the solutions registries, but
        // substitute repositorySolutionsRegistry into fullSolutionsRegistry if
        // available.
        // NOTE:  (JS) could do this substitution during the
        // onCreate.loadSolutions listener pipeline, but the loadFromLocalDisk()
        // invoker is public -- it could be called at any time and wipe out any
        // previous substitution.
        if (that.repositorySolutionsRegistry) {
            fluid.log("TRACE:  LFM SolutionsRegistryDataSource, returning ALL repository solutions MASKING (", that.id, ")... END");
            var fullSolutionsToReturn = fluid.copy(that.fullSolutionsRegistry);
            var repoPlatform = fluid.keys(that.repositorySolutionsRegistry)[0];
            fluid.set(fullSolutionsToReturn, repoPlatform, that.repositorySolutionsRegistry[repoPlatform]);
            promise.resolve(fluid.freezeRecursive(fullSolutionsToReturn));
        } else {
            fluid.log("TRACE:  LFM SolutionsRegistryDataSource, returning ALL repository solutions NOMASKING (", that.id, ")... END");
            promise.resolve(that.fullSolutionsRegistry);
        }
    }
    return promise;
};

/**
 * Fire an event to indicate that the pipeline for loading the repository and
 * local solutions registries has completed.
 * NOTE:  (JS) This is here for debugging, and will be called directly from the
 *   transform event pipeline defined in the listeners block of the relevant
 *   solutions registry data source.
 * @param {Event} solutionsRegistryReadyEvent - The event to fire.
 */
gpii.flowManager.solutionsRegistry.dataSource.finishedLoading = function (solutionsRegistryReadyEvent) {
    fluid.log("TRACE:  SRDS onCreate.loadSolutions ... DONE");
    solutionsRegistryReadyEvent.fire();
};

/** A mixin grade which automatically expands any %terms corresponding to module names registered in Infusion's module database */
// TODO: This is a duplicate of kettle.dataSource.file.moduleTerms - this should be rewritten after KETTLE-50 is resolved
fluid.defaults("gpii.flowManager.solutionsRegistry.dataSource.moduleTerms", {
    gradeNames: "gpii.flowManager.solutionsRegistry.dataSource",
    termMap: "@expand:fluid.module.terms()"
});
