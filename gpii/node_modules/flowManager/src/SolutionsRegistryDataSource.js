/*
 * GPII Solutions Registry Datasource
 *
 * Copyright 2016 RtF-I
 * Copyright 2020 OCAD University
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion"),
    gpii = fluid.registerNamespace("gpii"),
    fs = require("fs");

require("kettle");
require("./GpiiRevisionRequester.js");
require("./RepositorySolutionsLoader.js");

fluid.registerNamespace("gpii.flowManager.solutionsRegistry");

// The base solutions registry data source, containing information and functions
// shared by derived grades.
fluid.defaults("gpii.flowManager.solutionsRegistry.dataSource", {
    gradeNames: ["kettle.dataSource"],
    termMap: {
        "os": "%os",
        "version": "%version"
    },
    components: {
        encoding: {
            type: "kettle.dataSource.encoding.none"
        }
    },
    members: {
        fullSolutionsRegistry: null
    },
    invokers: {
        loadFromLocalDisk: {
            funcName: "gpii.flowManager.solutionsRegistry.dataSource.loadFromLocalDisk",
            args: ["{that}"]
        }
    },
    events: {
        loadSolutions: null,
        solutionsRegistryReady: null
    },
    listeners: {
        "onCreate.loadSolutions": {
            listener: "fluid.promise.fireTransformEvent",
            args: ["{that}.events.loadSolutions"]
        }
    }
});

/**
 * Load the solutions registry from the local file system -- the file system
 * that this solutions registry data source is running on.
 *
 * @param {Object} that - The gpii.flowManager.solutionsRegistry.dataSource.
 * @param {String} that.options.path - The path to the solutions registry
 *          directory.
 * @param {Object} that.fullSolutionsRegistry - This will be set to the
 *          collection of solution registries given by path.
 */
gpii.flowManager.solutionsRegistry.dataSource.loadFromLocalDisk = function (that) {
    if (!that.options.path) {
        fluid.fail("The solutionsRegistry datasource ", that, " needs a \"path\" option pointing to the solution entries folder");
    }
    var url = fluid.module.resolvePath(that.options.path);
    if (!fs.existsSync(url)) {
        fluid.fail("The path provided to the solutionsRegistry datasource (", url, ") has not been found on the file system");
    }
    that.fullSolutionsRegistry = fluid.freezeRecursive(require(url));
};

// Solutions registry data source used by the Cloud Based Flow Manager
fluid.defaults("gpii.flowManager.solutionsRegistry.dataSource.cloudBased", {
    gradeNames: ["gpii.flowManager.solutionsRegistry.dataSource"],
    readOnlyGrade: "gpii.flowManager.solutionsRegistry.dataSource.cloudBased",
    invokers: {
        getImpl: {
            funcName: "gpii.flowManager.solutionsRegistry.dataSource.cloudBased.handle",
            args: ["{that}", "{arguments}.1", "{arguments}.2"]
                             // options, directModel
        }
    },
    listeners: {
        "loadSolutions.loadFromLocalDisk": {
            listener: "{that}.loadFromLocalDisk",
            priority: "first"
        },
        "loadSolutions.solutionsLoaded": {
            listener: "{that}.events.solutionsRegistryReady",
            priority: "after:loadFromLocalDisk"
        }
    }
});

/**
 * Handler for get requests to the solutions registry used by the Cloud Based
 * Flow Manager. It will return an object containing the solutions registry for
 * the given platform.
 *
 * @param {Object} that - The gpii.flowManager.solutionsRegistry.dataSource.cloudBased
            instance that is handling the GET request.
 * @param {Object} requestOptions - Currently the only request option supported
 *          is "os". The returned solutions registry will be the solutions for
 *          the OS version provided.
 * @return {Promise} A promise that will be resolved with results (see above) or
 *          rejected on error.
 */
gpii.flowManager.solutionsRegistry.dataSource.cloudBased.handle = function (that, requestOptions) {
    var promise = fluid.promise();
    if (requestOptions.os && requestOptions.os in that.fullSolutionsRegistry) {
        promise.resolve(that.fullSolutionsRegistry[requestOptions.os]);
    } else {
        promise.reject({
            isError: true,
            message: "The requested OS (" + requestOptions.os + ") was not present in the solutions registry"
        });
    }
    return promise;
};

// Solutions registry datasource used by the Local Flow Manager.  On creation,
// it first loads all of the solution registries from the local file system for
// all of the platforms (win32, linux, darwin, android, etc).  Then, the
// solutions for the current platform are downloaded from the source code
// repository.  The current platform is the platform on which the Local Flow
// Manager is running.  The solutions fetched from the source code repository
// overlay the set retrieved from the local file system at the first step.  If
// the download from the source code repository fails, then the solutions loaded
// from the local file system are used.
fluid.defaults("gpii.flowManager.solutionsRegistry.dataSource.local", {
    gradeNames: ["gpii.flowManager.solutionsRegistry.dataSource"],
    components: {
        revisionRequester: {
            type: "gpii.flowmanager.revisionRequester"
        },
        repositorySolutionsLoader: {
            type: "gpii.flowManager.repositorySolutionsLoader"
        }
// The platformReporter is distributed down from the local flowManager
//      platformReporter: {
//          type: "gpii.platformReporter.native"
//      }
    },
    readOnlyGrade: "gpii.flowManager.solutionsRegistry.dataSource.local",
    members: {
        repositorySolutionsRegistry: null
    },
    invokers: {
        getImpl: {
            funcName: "gpii.flowManager.solutionsRegistry.dataSource.local.handle",
            args: ["{that}", "{arguments}.1"]
                             // options
        }
    },
    listeners: {
        "loadSolutions.loadFromLocalDisk": {
            listener: "{that}.loadFromLocalDisk",
            priority: "first"
        },
        "loadSolutions.getRevision": {
            listener: "{revisionRequester}.getRevision",
            priority: "after:loadFromLocalDisk"
        },
        "loadSolutions.loadFromRepository": {
            listener: "gpii.flowManager.solutionsRegistry.dataSource.local.loadFromRepository",
            args: ["{that}", "{arguments}.0", "{that}.platformReporter"],
                             // revision
            priority: "after:getRevision"
        },
        "loadSolutions.solutionsLoaded": {
            listener: "{that}.events.solutionsRegistryReady",
            priority: "after:loadFromRepository"
        }
    }
});

/**
 * Retrieve the solutions registry JSON file from the source code repository.
 * If successful, sets the repositorySolutionsRegistry member to the fetched
 * solutions registry.
 * @param {Component} that - An instance of gpii.flowManager.solutionsRegistry.dataSource
 * @param {Object} that.repositorySolutionsRegistry - Set to point to the
 *                 solutions registry retrieved from the respository, or null if
 *                 none were retrieved.
 * @param {Object} revision - the SHA256 revision of the repository in the form:
 *                            { sha256: ... }.  If the sha256 is missing, the
 *                            result of the load is null.
 * @param {Component} platformReporter - used to get the name of the platform,
 *                                       e.g., "win32".
 * @return {Promise} A promise whose resolved value is either the solutions
 *      registry from the source code repository, or null, if there was an error.
 */
gpii.flowManager.solutionsRegistry.dataSource.local.loadFromRepository = function (that, revision, platformReporter) {
    var togo = fluid.promise();
    if (revision) {
        var gpiiRevision = revision.sha256;
        var platformId = platformReporter.reportPlatform().id;
        var repoLoadPromise = that.repositorySolutionsLoader.getSolutions(gpiiRevision, platformId);

        // Either the solutions registry has been successfully retrieved from the
        // repository, or it hasn't.  Set that.repositorySolutionsRegistry to
        // to either the result, or to null.
        repoLoadPromise.then(
            function (repositorySolutions) {
                that.repositorySolutionsRegistry = repositorySolutions;
                togo.resolve(repositorySolutions);
            },
            function () {
                that.repositorySolutionsRegistry = null;
                togo.resolve(null);
            }
        );
    } else {
        that.repositorySolutionsRegistry = null;
        togo.resolve(null);
    }
    return togo;
};

/**
 * Handler for get requests when running with the gpii-app client and the Local
 * Flow Manager.  If a solutions registry was retrieved from the source code
 * repository, it is used to mask the equivalent platform in the full set of
 * solutions registries.  This handler will return the solutions registry for
 * the given platform.
 * @param {Object} that - The gpii.flowManager.solutionsRegistry.dataSource.local
 *        instance.
 * @param {Object} requestOptions - Currently the only request option supported
 *        is "os". The returned solutions registry will be the solutions for the
 *        given OS version.
 * @return {Promise} A promise that will be resolved with results (see above) or
 *         rejected on error.
 */
gpii.flowManager.solutionsRegistry.dataSource.local.handle = function (that, requestOptions) {
    var promise = fluid.promise();
    if (requestOptions && requestOptions.os) {
        if (that.repositorySolutionsRegistry && (requestOptions.os in that.repositorySolutionsRegistry)) {
            promise.resolve(that.repositorySolutionsRegistry[requestOptions.os]);
        } else if (requestOptions.os in that.fullSolutionsRegistry) {
            promise.resolve(that.fullSolutionsRegistry[requestOptions.os]);
        } else {
            promise.reject({
                isError: true,
                message: "The requested OS (" + requestOptions.os + ") was not present in the solutions registry"
            });
        }
    } else {
        promise.reject({
            isError: true,
            message: "Missing OS (undefined) for accessing the solutions registry"
        });
    }
    return promise;
};

/** A mixin grade which automatically expands any %terms corresponding to module names registered in Infusion's module database */
// TODO: This is a duplicate of kettle.dataSource.file.moduleTerms - this should be rewritten after KETTLE-50 is resolved
fluid.defaults("gpii.flowManager.solutionsRegistry.dataSource.moduleTerms", {
    gradeNames: "gpii.flowManager.solutionsRegistry.dataSource",
    termMap: "@expand:fluid.module.terms()"
});
