/*
 * GPII Solutions Registry Datasource
 *
 * Copyright 2016 RtF-I
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion"),
    gpii = fluid.registerNamespace("gpii"),
    fs = require("fs");


require("kettle");

fluid.registerNamespace("gpii.flowManager.solutionsRegistry");

fluid.defaults("gpii.flowManager.solutionsRegistry.dataSource", {
    gradeNames: ["kettle.dataSource"],
    components: {
        encoding: {
            type: "kettle.dataSource.encoding.none"
        }
    },
    members: {
        fullSolutionsRegistry: null
    },
    readOnlyGrade: "gpii.flowManager.solutionsRegistry.dataSource",
    invokers: {
        getImpl: {
            funcName: "gpii.flowManager.solutionsRegistry.dataSource.handle",
            args: ["{that}", "{arguments}.1", "{arguments}.2"]
                             // options, directModel
        }
    },
    listeners: {
        onCreate: "gpii.flowManager.solutionsRegistry.dataSource.loadSolutionsRegistry"
    }
});

// TODO: Add an invoker to reload once we are "more live".
gpii.flowManager.solutionsRegistry.dataSource.loadSolutionsRegistry = function (that) {
    fluid.log("TRACE:  SolutionsRegistryDataSource creation (", that.id, ") ... START");
    if (!that.options.path) {
        fluid.fail("The solutionsRegistry datasource ", that, " needs a \"path\" option pointing to the solution entries folder");
    }
    var url = fluid.module.resolvePath(that.options.path);
    if (!fs.existsSync(url)) {
        fluid.fail("The path provided to the solutionsRegistry datasource (", url, ") has not been found on the file system");
    }

    that.fullSolutionsRegistry = fluid.freezeRecursive(require(url));
    fluid.log("TRACE:  SolutionsRegistryDataSource creation (", that.id, ") ... END");
};

/**
 * Handler for get requests of solutions registry. It will return either a full solution registry,
 * or if an 'os' is provided in the requestOptions, only the entries for that os will be returned
 *
 * @param {Object} that - The gpii.flowManager.solutionsRegistry.dataSource.
 * @param {Object} requestOptions - Currently the only request option supported is "os". If provided,
 *           the returned solutions registry will be filtered by OS version.
 * @return {Promise} A promise that will be resolved with results (see above) or rejected on error.
 */
gpii.flowManager.solutionsRegistry.dataSource.handle = function (that, requestOptions) {
    fluid.log("TRACE:  SolutionsRegistryDataSource onCreate fetch local solutions (", that.id, ") ... START");
    var promise = fluid.promise();
    if (requestOptions.os) { // if "os" is defined, return only solution registry entries for that OS
        if (requestOptions.os in that.fullSolutionsRegistry) {
            fluid.log("TRACE:  SolutionsRegistryDataSource fetch local solutions (", that.id, ") ... END");
            promise.resolve(that.fullSolutionsRegistry[requestOptions.os]);
        } else {
            promise.reject({
                isError: true,
                message: "The requested OS (" + requestOptions.os + ") was not present in the solutions registry",
                statusCode: 404
            });
        }
    } else { // if no "os" is requested, return the full solutions registry
        fluid.log("TRACE:  SolutionsRegistryDataSource fetch local solutions (", that.id, ")... END");
        promise.resolve(that.fullSolutionsRegistry);
    }
    return promise;
};

/** A mixin grade which automatically expands any %terms corresponding to module names registered in Infusion's module database */
// TODO: This is a duplicate of kettle.dataSource.file.moduleTerms - this should be rewritten after KETTLE-50 is resolved
fluid.defaults("gpii.flowManager.solutionsRegistry.dataSource.moduleTerms", {
    gradeNames: "gpii.flowManager.solutionsRegistry.dataSource",
    termMap: "@expand:fluid.module.terms()"
});
