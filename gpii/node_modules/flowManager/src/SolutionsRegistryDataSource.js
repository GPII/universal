/*
 * GPII Solutions Registry Datasource
 *
 * Copyright 2016 RtF-I
 * Copyright 2020 OCAD University
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion"),
    gpii = fluid.registerNamespace("gpii"),
    fs = require("fs");

require("kettle");
require("./GpiiRevisionRequester.js");
require("./RepositorySolutionsLoader.js");

fluid.registerNamespace("gpii.flowManager.solutionsRegistry");

// The base solutions registry data source, containing information and functions
// shared by derived grades.
fluid.defaults("gpii.flowManager.solutionsRegistry.dataSource", {
    gradeNames: ["kettle.dataSource"],
    termMap: {
        "os": "%os",
        "version": "%version"
    },
    components: {
        encoding: {
            type: "kettle.dataSource.encoding.none"
        }
    },
    members: {
        fullSolutionsRegistry: null
    },
    invokers: {
        loadFromLocalDisk: {
            funcName: "gpii.flowManager.solutionsRegistry.dataSource.loadFromLocalDisk",
            args: ["{that}"]
        }
    },
    events: {
        loadSolutions: null,
        solutionsRegistryReady: null
    },
    listeners: {
        "onCreate.loadSolutions": {
            listener: "fluid.promise.fireTransformEvent",
            args: ["{that}.events.loadSolutions"]
        }
    }
});

/**
 * Load the solutions registry from the local file system -- the file system
 * that this solutions registry data source is running on.
 *
 * @param {Object} that - The gpii.flowManager.solutionsRegistry.dataSource.
 * @param {String} that.options.path - The path to the solutions registry
 *          directory.
 * @param {Object} that.fullSolutionsRegistry - This will be set to the
 *          collection of solution registries given by path.
 */
gpii.flowManager.solutionsRegistry.dataSource.loadFromLocalDisk = function (that) {
    if (!that.options.path) {
        fluid.fail("The solutionsRegistry datasource ", that, " needs a \"path\" option pointing to the solution entries folder");
    }
    var url = fluid.module.resolvePath(that.options.path);
    if (!fs.existsSync(url)) {
        fluid.fail("The path provided to the solutionsRegistry datasource (", url, ") has not been found on the file system");
    }
    that.fullSolutionsRegistry = fluid.freezeRecursive(require(url));
};

// Solutions registry data source used by the Cloud Based Flow Manager
fluid.defaults("gpii.flowManager.solutionsRegistry.dataSource.cloud", {
    gradeNames: ["gpii.flowManager.solutionsRegistry.dataSource"],
    readOnlyGrade: "gpii.flowManager.solutionsRegistry.dataSource.cloud",
    invokers: {
        getImpl: {
            funcName: "gpii.flowManager.solutionsRegistry.dataSource.cloud.handle",
            args: ["{that}", "{arguments}.1", "{arguments}.2"]
                             // options, directModel
        }
    },
    listeners: {
        "loadSolutions.loadFromLocalDisk": {
            listener: "{that}.loadFromLocalDisk",
            priority: "first"
        },
        "loadSolutions.solutionsLoaded": {
            listener: "{that}.events.solutionsRegistryReady",
            priority: "after:loadFromLocalDisk"
        }
    }
});

/**
 * Handler for get requests to the solutions registry used by the Cloud Based
 * Flow Manager. It will return either an object containing solutions registries
 * for the given platform.
 *
 * @param {Object} that - The gpii.flowManager.solutionsRegistry.dataSource.cloud
 * @param {Object} requestOptions - Currently the only request option supported
 *          is "os". The returned solutions registry will be the solutions for
 *          the OS version provided.
 * @return {Promise} A promise that will be resolved with results (see above) or
 *          rejected on error.
 */
gpii.flowManager.solutionsRegistry.dataSource.cloud.handle = function (that, requestOptions) {
    var promise = fluid.promise();
    if (requestOptions.os && requestOptions.os in that.fullSolutionsRegistry) {
        promise.resolve(that.fullSolutionsRegistry[requestOptions.os]);
    } else {
        promise.reject({
            isError: true,
            message: "The requested OS (" + requestOptions.os + ") was not present in the solutions registry",
            statusCode: 404
        });
    }
    return promise;
};

// Solutions registry datasource used by the Local Flow Manager.  It loads both
// solutions from the source code repository as well as the local file sysmtem.
fluid.defaults("gpii.flowManager.solutionsRegistry.dataSource.local", {
    gradeNames: ["gpii.flowManager.solutionsRegistry.dataSource"],
    components: {
        revisionRequester: {
            type: "gpii.flowmanager.revisionRequester"
        },
        repositorySolutionsLoader: {
            type: "gpii.flowManager.repositorySolutionsLoader"
        },
        platformReporter: {
            type: "gpii.platformReporter.native"
        }
    },
    readOnlyGrade: "gpii.flowManager.solutionsRegistry.dataSource.local",
    members: {
        repositorySolutionsRegistry: null
    },
    invokers: {
        getImpl: {
            funcName: "gpii.flowManager.solutionsRegistry.dataSource.local.handle",
            args: ["{that}", "{arguments}.1"]
                             // options
        }
    },
    listeners: {
        "loadSolutions.loadFromLocalDisk": {
            listener: "{that}.loadFromLocalDisk",
            priority: "first"
        },
        "loadSolutions.getRevision": {
            listener: "{revisionRequester}.getRevision",
            priority: "after:loadFromLocalDisk"
        },
        "loadSolutions.loadFromRepository": {
            listener: "gpii.flowManager.solutionsRegistry.dataSource.local.loadFromRepository",
            args: ["{that}", "{arguments}.0", "{that}.platformReporter"],
                             // revision
            priority: "after:getRevision"
        },
        "loadSolutions.solutionsLoaded": {
            listener: "{that}.events.solutionsRegistryReady",
            priority: "after:loadFromRepository"
        }
    }
});

/**
 * Retrieve the solutions registry JSON file from the source code repository.
 * If successful, sets the repositorySolutionsRegistry member to the fetched
 * solutions registry.
 * @param {Component} that - An instance of gpii.flowManager.solutionsRegistry.dataSource
 * @param {Component} that.repositorySolutionsLoader - An instance of
 *                    gpii.flowManager.repositorySolutionsLoader.
 * @param {Object} that.repositorySolutionsRegistry - Set to point to the
 *                 solutions registry retrieved from the respository, or null if
 *                 none were retrieved.
 * @param {Object} revision - the SHA256 revision of the repository in the form:
 *                            { sha256: ... }.
 * @param {Component} platformReporter - used to get the name of the platform,
 *                                       e.g., "win32".
 * @return {Promise} A promise whose resolved value is eiher the solutions
 *      registry, or, if there is an error, an object with an "isError: true"
 *      property.
 */
gpii.flowManager.solutionsRegistry.dataSource.local.loadFromRepository = function (that, revision, platformReporter) {
    var gpiiRevision = revision.sha256;
    var platformId = platformReporter.reportPlatform().id;
    var fileName = platformId + ".json5";
    var togo = that.repositorySolutionsLoader.getSolutions(gpiiRevision, fileName, platformId);
    togo.then(function () {
        // Either the solutions registry has been successfully retrieved from the
        // repository, or it hasn't.  Set that.repositorySolutionsRegistry to
        // whatever the result.
        that.repositorySolutionsRegistry = that.repositorySolutionsLoader.solutionsRegistry;
    });
    return togo;
};

/**
 * Handler for get requests when running with the gpii-app client and the Local
 * Flow Manager.  If a solutions registry was retrieved from the source code
 * repository, it is used to mask the equivalent platform in the full set of
 * solutions registries.  This handler will return the solutions registry for
 * the given platform.
 * @param {Object} that - The gpii.flowManager.solutionsRegistry.dataSource.local
 *        instance.
 * @param {Object} requestOptions - Currently the only request option supported
 *        is "os". The returned solutions registry will be the solutions for the
 *        given OS version.
 * @return {Promise} A promise that will be resolved with results (see above) or
 *         rejected on error.
 */
gpii.flowManager.solutionsRegistry.dataSource.local.handle = function (that, requestOptions) {
    var promise = fluid.promise();
    if (requestOptions && requestOptions.os) {
        if (that.repositorySolutionsRegistry && (requestOptions.os in that.repositorySolutionsRegistry)) {
            promise.resolve(that.repositorySolutionsRegistry[requestOptions.os]);
        } else if (requestOptions.os in that.fullSolutionsRegistry) {
            promise.resolve(that.fullSolutionsRegistry[requestOptions.os]);
        } else {
            promise.reject({
                isError: true,
                message: "The requested OS (" + requestOptions.os + ") was not present in the solutions registry",
                statusCode: 404
            });
        }
    }
    return promise;
};

/** A mixin grade which automatically expands any %terms corresponding to module names registered in Infusion's module database */
// TODO: This is a duplicate of kettle.dataSource.file.moduleTerms - this should be rewritten after KETTLE-50 is resolved
fluid.defaults("gpii.flowManager.solutionsRegistry.dataSource.moduleTerms", {
    gradeNames: "gpii.flowManager.solutionsRegistry.dataSource",
    termMap: "@expand:fluid.module.terms()"
});
