/*
 * GPII Solutions Registry Datasource
 *
 * Copyright 2016 RtF-I
 * Copyright 2020 OCAD University
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion"),
    gpii = fluid.registerNamespace("gpii"),
    fs = require("fs"),
    os = require("os");

require("kettle");
require("./GpiiRevisionRequester.js");
require("./RepositorySolutionsLoader.js");

fluid.registerNamespace("gpii.flowManager.solutionsRegistry");

// The base solutions registry data source, containing information and functions
// shared by derived grades.
fluid.defaults("gpii.flowManager.solutionsRegistry.dataSource", {
    gradeNames: ["kettle.dataSource"],
    termMap: {
        "os": "%os",
        "version": "%version"
    },
    components: {
        encoding: {
            type: "kettle.dataSource.encoding.none"
        }
    },
    members: {
        fullSolutionsRegistry: null
    },
    invokers: {
        loadFromLocalDisk: {
            funcName: "gpii.flowManager.solutionsRegistry.dataSource.loadFromLocalDisk",
            args: ["{that}"]
        }
    },
    events: {
        loadSolutions: null,
        solutionsRegistryReady: null
    },
    listeners: {
        "onCreate.loadSolutions": {
            listener: "fluid.promise.fireTransformEvent",
            args: ["{that}.events.loadSolutions"]
        }
    }
});

/**
 * Load the solutions registry from the local file system -- the file system
 * that this solutions registry data source is running on.
 *
 * @param {Object} that - The gpii.flowManager.solutionsRegistry.dataSource.
 * @param {String} that.options.path - The path to the solutions registry
 *          directory.
 * @param {Object} that.fullSolutionsRegistry - This will be set to the
 *          collection of solution registries given by path.
 */
gpii.flowManager.solutionsRegistry.dataSource.loadFromLocalDisk = function (that) {
    fluid.log("TRACE:  SolutionsRegistryDataSource creation (", that.id, ") ... START");
    debugger;
    if (!that.options.path) {
        fluid.fail("The solutionsRegistry datasource ", that, " needs a \"path\" option pointing to the solution entries folder");
    }
    var url = fluid.module.resolvePath(that.options.path);
    if (!fs.existsSync(url)) {
        fluid.fail("The path provided to the solutionsRegistry datasource (", url, ") has not been found on the file system");
    }
    that.fullSolutionsRegistry = fluid.freezeRecursive(require(url));
    fluid.log("TRACE:  SolutionsRegistryDataSource creation (", that.id, ") ... END");
};

// Solutions registry data source used by the Cloud Based Flow Manager
fluid.defaults("gpii.flowManager.solutionsRegistry.dataSource.cloud", {
    gradeNames: ["gpii.flowManager.solutionsRegistry.dataSource"],
    readOnlyGrade: "gpii.flowManager.solutionsRegistry.dataSource.cloud",
    invokers: {
        getImpl: {
            funcName: "gpii.flowManager.solutionsRegistry.dataSource.cloud.handle",
            args: ["{that}", "{arguments}.1", "{arguments}.2"]
                             // options, directModel
        }
    },
    listeners: {
        "loadSolutions.loadFromLocalDisk": {
            listener: "{that}.loadFromLocalDisk",
            priority: "first"
        },
        "loadSolutions.solutionsLoaded": {
            listener: "gpii.flowManager.solutionsRegistry.dataSource.finishedLoading",
            args: ["{that}.events.solutionsRegistryReady"],
            priority: "after:loadFromLocalDisk"
        }
    }
});

/**
 * Handler for get requests to the solutions registry used by the Cloud Based
 * Flow Manager. It will return either an object containing solutions registries
 * for all platforms, or, if a platform is provided, only the solutions registry
 * for that platform will be returned.
 *
 * @param {Object} that - The gpii.flowManager.solutionsRegistry.dataSource.cloud
 * @param {Object} requestOptions - Currently the only request option supported
 *          is "os". If provided, the returned solutions registry will be
 *          filtered by OS version.
 * @return {Promise} A promise that will be resolved with results (see above) or
 *          rejected on error.
 */
gpii.flowManager.solutionsRegistry.dataSource.cloud.handle = function (that, requestOptions) {
    fluid.log("TRACE:  SolutionsRegistryDataSource return solutions (", that.id, ") ... START");
    debugger;
    var promise = fluid.promise();
    if (requestOptions.os) { // if "os" is defined, return only solution registry entries for that OS
        if (requestOptions.os in that.fullSolutionsRegistry) {
            fluid.log("TRACE:  SolutionsRegistryDataSource return SPECIFIED [", requestOptions.os, "] solutions (", that.id, ") ... END");
            promise.resolve(that.fullSolutionsRegistry[requestOptions.os]);
        } else {
            promise.reject({
                isError: true,
                message: "The requested OS (" + requestOptions.os + ") was not present in the solutions registry",
                statusCode: 404
            });
        }
    } else { // if no "os" is requested, return the full solutions registry
        fluid.log("TRACE:  SolutionsRegistryDataSource return ALL solutions (", that.id, ") ", that.fullSolutionsRegistry, "... END");
        promise.resolve(that.fullSolutionsRegistry);
    }
    return promise;
};

// Solutions registry datasource used by the Local Flow Manager.  It loads both
// solutions from the source code repository as well as the local file sysmtem.
fluid.defaults("gpii.flowManager.solutionsRegistry.dataSource.local", {
    gradeNames: ["gpii.flowManager.solutionsRegistry.dataSource"],
    components: {
        revisionRequester: {
            type: "gpii.flowmanager.revisionRequester"
        },
        repositorySolutionsLoader: {
            type: "gpii.flowManager.repositorySolutionsLoader"
        }
    },
    platformId: os.platform(),
    readOnlyGrade: "gpii.flowManager.solutionsRegistry.dataSource.local",
    members: {
        repositorySolutionsRegistry: null
    },
    invokers: {
        getImpl: {
            funcName: "gpii.flowManager.solutionsRegistry.dataSource.local.handle",
            args: ["{that}"]
        }
    },
    listeners: {
        "loadSolutions.loadFromLocalDisk": {
            listener: "{that}.loadFromLocalDisk",
            priority: "first"
        },
        "loadSolutions.getRevision": {
            listener: "{revisionRequester}.getRevision",
            priority: "after:loadFromLocalDisk"
        },
        "loadSolutions.loadFromRepository": {
            listener: "gpii.flowManager.solutionsRegistry.dataSource.local.loadFromRepository",
            args: ["{that}", "{arguments}.0", "{that}.options.platformId"],
                             // revision
            priority: "after:getRevision"
        },
        "loadSolutions.solutionsLoaded": {
            listener: "gpii.flowManager.solutionsRegistry.dataSource.finishedLoading",
            args: ["{that}.events.solutionsRegistryReady"],
            priority: "after:loadFromRepository"
        }
    }
});

/**
 * Retrieve the solutions registry JSON file from the source code repository.
 * If successful, sets the repositorySolutionsRegistry member to the fetched
 * solutions registry.
 * @param {Component} that - An instance of gpii.flowManager.solutionsRegistry.dataSource
 * @param {Component} that.repositorySolutionsLoader - An instance of
 *                    gpii.flowManager.repositorySolutionsLoader.
 * @param {Object} that.repositorySolutionsRegistry - Set to point to the
 *                 solutions registry retrieved from the respository, or null if
 *                 none were retrieved.
 * @param {Object} revision - the SHA256 revision of the repository in the form:
 *                            { sha256: ... }.
 * @param {String} platformId - the name of the platform, e.g., "win32".
 * @return {Promise} A promise whose resolved value is eiher the solutions
 *      registry, or, if there is an error, an object with an "isError: true"
 *      property.
 */
gpii.flowManager.solutionsRegistry.dataSource.local.loadFromRepository = function (that, revision, platformId) {
    fluid.log("TRACE:  SRDS onCreate gets solutions from github ... START");
    debugger;
    var gpiiRevision = revision.sha256;
    var fileName = platformId + ".json5";
    var togo = that.repositorySolutionsLoader.getSolutions(gpiiRevision, fileName, platformId);
    togo.then(function () {
        // If the solutions registry has been successfully retrieved from the
        // repository, replace (or add) the one in the fullSolutionsRegistry
        // with it.  Otherwise, leave the fullSolutionsRegistry as is.
        if (that.repositorySolutionsLoader.solutionsRegistry) {
            var newFullSolutions = that.fullSolutionsRegistry;
            newFullSolutions[platformId] = that.repositorySolutionsLoader.solutionsRegistry;
            that.fullSolutionsRegistry = fluid.freezeRecursive(newFullSolutions);
        }
        fluid.log("TRACE:  SRDS onCreate gets solutions from github ... END");
    });
    return togo;
};

/**
 * Handler for get requests of solutions registry running with the gpii-app
 * client and associated with the local flow manager.  The solutions registry
 * returned depends on whether the repository solutions registry waa
 * successfully retrieved:
 * - if the solutions registry has been downloaded from the source code
 *   repository, return it,
 * - otherwise, return the solutions as retrieved from the local file system.
 *
 * @param {Object} that - The gpii.flowManager.solutionsRegistry.dataSource.
 * @return {Promise} A promise that will be resolved with results (see above) or
 *          rejected on error.
 */
gpii.flowManager.solutionsRegistry.dataSource.local.handle = function (that, requestOptions) {
    fluid.log("TRACE:  LFM SolutionsRegistryDataSource return solutions (", that.id, ") ... START");
    var promise = fluid.promise();
    if (that.repositorySolutionsRegistry) {
        fluid.log("TRACE:  LFM SolutionsRegistryDataSource return repository solutions (", that.id, "... END");
        promise.resolve(that.repositorySolutionsRegistry);
    } else {
        fluid.log("TRACE:  LFM SolutionsRegistryDataSource returns local file system solutions (", that.id, ") ... END");
        promise.resolve(that.fullSolutionsRegistry[that.options.platformId]);
    }
    return promise;
};

/**
 * Fire an event to indicate that the pipeline for loading the repository and
 * local solutions registries has completed.
 * NOTE:  (JS) This is here for debugging, and will be called directly from the
 *   transform event pipeline defined in the listeners block of the relevant
 *   solutions registry data source.
 * @param {Event} solutionsRegistryReadyEvent - The event to fire.
 */
gpii.flowManager.solutionsRegistry.dataSource.finishedLoading = function (solutionsRegistryReadyEvent) {
    fluid.log("TRACE:  SRDS onCreate.loadSolutions ... DONE");
    debugger; 
    solutionsRegistryReadyEvent.fire();
};

/** A mixin grade which automatically expands any %terms corresponding to module names registered in Infusion's module database */
// TODO: This is a duplicate of kettle.dataSource.file.moduleTerms - this should be rewritten after KETTLE-50 is resolved
fluid.defaults("gpii.flowManager.solutionsRegistry.dataSource.moduleTerms", {
    gradeNames: "gpii.flowManager.solutionsRegistry.dataSource",
    termMap: "@expand:fluid.module.terms()"
});
