"use strict";


var fluid = require("infusion");
var gpii = fluid.registerNamespace("gpii");

fluid.registerNamespace("gpii.flowManager");

// A mixin grade applied to the lifecycleManager's session by the pspChannel
fluid.defaults("gpii.pspChannel.sessionBinder", {
    modelRelay: {
        pspChannel: {
            source: "",
            target: "{flowManager}.pspChannel.model",
            singleTransform: {
                type: "gpii.pspChannel.sessionToPSP",
                ontologyMetadata: "{ontologyHandler}.ontologyMetadata",
                defaultSettingControls: "{pspChannel}.defaultSettingControls"
            },
            // compensate for FLUID-6194
            backward: "never",
            forward: {
                // avoid notifying the client for the init of LifecycleManagerSession, simplifies test and clients
                excludeSource: "init"
            }
        }
    },
    modelListeners: {
        // When PSP channel receives a setting change request from PSP clients, this model listener informs flowManager
        // to apply this new setting.
        updatePreferences: {
            path: "{flowManager}.pspChannel.model.settingControls",
            includeSource: "PSP",
            funcName: "{flowManager}.lifecycleManager.applyPreferences",
            args: ["{change}.value", "{pspChannel}.events.preferencesAppliedLocal"]
        },
        updateContext: {
            path: "{flowManager}.pspChannel.model.activeContextName",
            includeSource: "PSP",
            funcName: "gpii.pspChannel.updateContext",
            args: ["{flowManager}.contextManager", "{pspChannel}", "{change}.value"]
        },
        savePreferences: { // explicit save when the save button is clicked
            path: "{flowManager}.pspChannel.model.saveButtonClickCount",
            includeSource: "PSP",
            listener: "gpii.pspChannel.savePreferences",
            args: ["{flowManager}", "{lifecycleManager}", "{pspChannel}.events.preferencesAppliedLocal"]
        }
    }
});

/**
 * The PSP channel maintains its own model of the PSP state, it contains the following data:
 *
 * "gpiiKey": "<GPII key>",           // currently logged in GPII key - { type: "string" }
 * "activeContextName": "<context name>", // currently applied context - { type: "string" }
 * "settingControls": {                   // any number of preferences with values and schemas
 *      "<preference URI 1>": {           // settings URI, note that '.'s are interpreted as paths unless escaped
 *          "value": <value for preference>,   // the value that the given preference has
 *          "schema": { ... }                  // schema for the preference
 *      },
 *      "<preference URI 2>": { .. },
 *      "<preference URI N>": { .. }
 * },
 * "preferences": {                       // Used for listing available contexts and name of preference set
 *      "name": "My preference set",
 *      "contexts": {
 *          "<context 1 name>": {         // the name/id of the context
 *              "name": "<human readable name>" // name to be displayed in the PSP
 *          }
 *          "<context 2 name>": {...},
 *          "<context n name>": {...}
 *      }
 *  },
 * saveButtonClickCount                   // increments by 1 every time the save button is clicked
 */
fluid.defaults("gpii.pspChannel", {
    gradeNames: ["fluid.modelComponent"],
    members: {
        outputBlocked: null,
        // "defaultSettingControls" holds schemas containing default preferences and their values
        // defined in the reset to default file.
        defaultSettingControls: {
            expander: {
                funcName: "gpii.pspChannel.generateDefaultSettingControls",
                args: ["{flowManager}.options.defaultSettings", "{ontologyHandler}.ontologyMetadata.flat"]
            }
        }
    },
    listeners: {
        "{lifecycleManager}.events.onSessionStop": {
            namespace: "pspChannel",
            funcName: "gpii.pspChannel.sessionStop",
            args: "{pspChannel}"
        }
    },
    events: {
        // Fired when preferences are applied to the local computer. Its main current purpose is to compose the aggregate event "preferencesApplied"
        preferencesAppliedLocal: null,
        // Fired when preferences are applied to the local computer and saved to the cloud.
        preferencesApplied: {
            events: {
                preferencesAppliedLocal: "preferencesAppliedLocal",
                preferencesSavedSuccess: "{gpii.flowManager}.events.preferencesSavedSuccess"
            }
        },
        // Fired when the read of a preference completes successfully
        preferenceReadSuccess: null,
        // Fired when the read of a preference fails
        preferenceReadFail: null
    }
});

/**
 * Calculate the schemas containing preferences with their default values from the reset to default file.
 * @param {Object} defaultSettings - The value of flowManager.options.defaultSettings.
 * @param {Object} schemas - The value of ontologyHandler.ontologyMetadata.flat.
 * @return {Object}  - A collected schema containing schemas for each preference defined in the reset to default file.
 * The default preference values defined in the reset to default file are populated into the "default" field of
 * the returned schema. An example:
 * {
 *     "http://registry\\.gpii\\.net/common/cursorSize": {
 *         "schema": {
 *             "title": "Cursor Size",
 *             "description": "Cursor size",
 *             "type": "number",
 *             "default": 0.8,   // This default value is from the reset to default file
 *             "minimum": 0,
 *             "maximum": 1,
 *             "multipleOf": 0.1
 *         },
 *         "liveness": "live"
 *     },
 *     ...
 * }
 */
gpii.pspChannel.generateDefaultSettingControls = function (defaultSettings, schemas) {
    var defaultSettingControls = {};
    var defaultPreferences = fluid.get(defaultSettings, ["contexts", "gpii-default", "preferences"]);

    // Set the setting default values from reset to standard file to schema.default field for each setting in
    // "settingControls" block.
    fluid.each(defaultPreferences, function (defaultPrefsVal, defaultPrefsKey) {
        if (schemas[defaultPrefsKey]) {
            var schemaWithDefault = fluid.copy(schemas[defaultPrefsKey]);
            fluid.set(schemaWithDefault, ["schema", "default"], defaultPrefsVal);
            gpii.pspChannel.emitSettingControl(defaultSettingControls, schemaWithDefault, undefined, [defaultPrefsKey], "live");
        }
    });
    return defaultSettingControls;
};

gpii.pspChannel.updateContext = function (contextManager, pspChannel, newContext) {
    fluid.log("Received context update from PSP UI of ", newContext);
    // Abominable hack to avoid confusing client with numerous update messages. The ChangeApplier should really support
    // "manifest transactions" / "vertical transactions"
    pspChannel.outputBlocked = fluid.promise();
    var clearBlock = function () {
        delete pspChannel.outputBlocked;
    };
    pspChannel.outputBlocked.then(clearBlock, clearBlock);
    pspChannel.applier.change([], null, "DELETE");
    var promise = contextManager.contextChanged(newContext);
    if (promise) {
        fluid.promise.follow(promise, pspChannel.outputBlocked);
    } else {
        pspChannel.outputBlocked.resolve();
    }
};

gpii.pspChannel.filterSolution = function (solution) {
    return {
        name: solution.name,
        settingsHandlers: fluid.transform(solution.settingsHandlers, function (oneHandler) {
            return fluid.filterKeys(oneHandler, ["supportedSettings"]);
        })
    };
};

// Explicit save when the save button is clicked
gpii.pspChannel.savePreferences = function (flowManager, lifecycleManager, preferencesAppliedLocalEvent) {
    // Grab current active lifecycle manager session
    var userSession = lifecycleManager.getSession();
    var gpiiKey = userSession.model.gpiiKey;
    var preferences = userSession.model.preferences;
    fluid.log("PSPChannel: explicit save for gpiiKey (", gpiiKey, "), with preferences: ", preferences);
    flowManager.savePreferences(gpiiKey, preferences);

    // At explicit save, preferencesAppliedLocal event will not be triggered. This event is only triggered when
    // there is setting change that needs to be applied to the local computer. Directly firing this event is to
    // trigger its parent aggregate event "preferencesApplied" to be fired.
    preferencesAppliedLocalEvent.fire();
};

/** Emit an entry in the `settingControls` block for a single setting.
 *
 * @param {Object} settingControls - *This object will be modified by the function's action* One top-level member
 * will be added to this object, with a key given by composing the argument `keySegs`. The value of the
 * member will be a structure {SettingControl} consisting of:
 *     @member {Any} value - The actual value of the corresponding setting.
 *     @member {JSONSchema} schema - A JSON schema structure describing the value space of the setting.
 *     @member {String} [solutionName] - [optional] The solution name to which this setting is allocated in the preferences
 * document, if there is one. If it is defined as a top-level common term, this member will be omitted.
 *     @member {String} liveness - The liveness value of the setting.
 */

gpii.pspChannel.emitSettingControl = function (settingControls, schema, prefVal, keySegs, liveness, solutionName) {
    var fullKey = fluid.pathUtil.composeSegments.apply(null, keySegs);
    if (schema) {
        settingControls[fullKey] = {
            schema: schema.schema,
            liveness: liveness
        };
    }
    if (solutionName) {
        fluid.set(settingControls, [fullKey, "solutionName"], solutionName);
    }
    if (prefVal !== null && prefVal !== undefined) {
        fluid.set(settingControls, [fullKey, "value"], prefVal);
    }
};

/** Transduces the session model held for the currently logged-on user in the LifecycleManager's session into the model
 * structure which is suitable for shipping to the PSP over its bus. Each setting control output in the section
 * `settingControls` will be dumped using the utility `gpii.pspChannel.emitSettingControl`. This is a model relay
 * function which is run continuously as the session's model is updated.
 *
 * @param {Object} model - The LifecycleManager's session model.
 * @param {ModelTransformSpec} transformSpec - The model transformation spec.
 * @return {Object} The output model suitable for shipping to the PSP, including top-level members:
 *     - {Object} settingControls - A hash keyed by preference path, whose values are {SettingControl} objects.
 *     - {Object} preferences - A filtered skeleton of the user's preferences document, just containing the names of `contexts.
 */
gpii.pspChannel.sessionToPSP = function (model, transformSpec) {
    var schemas = transformSpec.ontologyMetadata.flat;
    var outModel = fluid.filterKeys(model, ["gpiiKey", "activeContextName"]);
    var settingControls = {};
    var activePreferences = fluid.get(model, ["currentPreferences"]);
    var prefApplicationPrefix = "http://registry.gpii.net/applications/";

    fluid.each(activePreferences, function (prefsVal, prefsKey) {
        if (prefsKey.startsWith(prefApplicationPrefix)) {
            var solKey = prefsKey.substring(prefApplicationPrefix.length);
            var solution = model.solutionsRegistryEntries[solKey];
            if (solution) {
                fluid.each(prefsVal, function (innerPrefsVal, innerPrefsKey) {
                    var liveness = gpii.matchMakerFramework.utils.getLeastLiveness([ solution ], innerPrefsKey);
                    gpii.pspChannel.emitSettingControl(settingControls, schemas[innerPrefsKey], innerPrefsVal, [prefsKey, innerPrefsKey], liveness, solution.name);
                });
            }
        } else {
            var liveness;
            var applications = fluid.get(model, "activeConfiguration.inferredConfiguration.applications");
            // "activeConfiguration" only tracks applied preferences. Preferences requested via the read API may or
            // may not have entries here depending on if this read preference has ever been requested as an applied
            // preference. For preferences that don't have an entry in "applications", "liveness" will not be
            // calculated and returned to pspChannel clients.
            if (applications) {
                var activeSolutionIds = Object.keys(applications);
                var activeSolutions = fluid.filterKeys(model.solutionsRegistryEntries, activeSolutionIds);
                liveness = gpii.matchMakerFramework.utils.getLeastLiveness(activeSolutions, prefsKey);
            }
            gpii.pspChannel.emitSettingControl(settingControls, schemas[prefsKey], prefsVal, [prefsKey], liveness);
        }
    });
    // GPII-3828: Return default values defined in the reset to default file rather than ones from the ontologyMetadata
    outModel.settingControls = fluid.extend(true, {}, settingControls, transformSpec.defaultSettingControls || {});
    outModel.preferences = {
        name: fluid.get(model, "preferences.name"),
        contexts: fluid.transform(fluid.get(model, "preferences.contexts"), function (contextVal) {
            return fluid.filterKeys(contextVal, ["name"]);
        })
    };
    return outModel;
};


gpii.pspChannel.modelChangeListener = function (handler, pspChannel, value, oldValue, path, transaction) {
    fluid.log("PSPChannel's PSP-facing modelChangeListener, sources are ", fluid.keys(transaction.sources));
    if (!transaction.sources.PSP && !transaction.sources.SessionCleanup) {
        fluid.log("Model change source is not PSP - candidate for update message");
        if (pspChannel.outputBlocked) {
            // Ensure that we queue just a single outgoing message for when the channel unblocks
            if (!pspChannel.outputBlocked.queued) {
                pspChannel.outputBlocked.queued = true;
                pspChannel.outputBlocked.then(function () {
                    fluid.log("PSPChannel sending unblocked full update message", JSON.stringify(pspChannel.model, null, 2));
                    handler.sendTypedMessage("modelChanged", {path: [], type: "ADD", value: pspChannel.model});
                });
            }
        } else {
            var changes = fluid.modelPairToChanges(value, oldValue);
            var hasDeletion = fluid.find(changes, function (change) {
                return change.type === "DELETE";
            });
            if (hasDeletion) {
                changes.forEach(function (change) {
                    handler.sendTypedMessage("modelChanged", change);
                });
            } else {
                handler.sendTypedMessage("modelChanged", {path: [], type: "ADD", value: value});
            }
        }
    }
};

gpii.pspChannel.sessionStop = function (pspChannel) {
    pspChannel.applier.change("", null, "DELETE");
};

fluid.defaults("gpii.pspChannel.handler", {
    gradeNames: ["kettle.request.ws"],
    invokers: {
        modelChangeListener: {
            funcName: "gpii.pspChannel.modelChangeListener",
            args: ["{that}", "{pspChannel}", "{arguments}.0", "{arguments}.1", "{arguments}.2", "{arguments}.4"]
                                             // value, oldValue, pathSegs, transaction: http://docs.fluidproject.org/infusion/development/ChangeApplierAPI.html#programmatic-style-for-listening-to-changes
        }
    },
    listeners: {
        onBindWs: {
            funcName: "gpii.pspChannel.bindWs",
            args: ["{that}", "{pspChannel}"]
        },
        "{pspChannel}.events.preferencesApplied": {
            funcName: "{that}.sendTypedMessage",
            args: ["preferencesApplied"]
        },
        "{pspChannel}.events.preferenceReadSuccess": {
            funcName: "{that}.sendTypedMessage",
            args: ["preferenceReadSuccess"]
        },
        "{pspChannel}.events.preferenceReadFail": {
            funcName: "{that}.sendTypedMessage",
            args: ["preferenceReadFail"]
        },
        onReceiveMessage: {
            funcName: "gpii.pspChannel.receiveMessage",
            args: ["{arguments}.1", "{pspChannel}", "{lifecycleManager}"]
        },
        "onDestroy.unbindModel": {
            func: "{pspChannel}.applier.modelChanged.removeListener",
            args: ["{that}.id"]
        }
    }
});

gpii.pspChannel.bindWs = function (handler, pspChannel) {
    pspChannel.applier.modelChanged.addListener("", handler.modelChangeListener, handler.id);
    // Note that this is inconsistent with the Nexus' protocol, but is more correct - for example if the model consists
    // purely of a primitive or is undefined, the initial Nexus message will break
    handler.sendTypedMessage("modelChanged", {path: [], type: "ADD", value: pspChannel.model});
};

gpii.pspChannel.receiveMessage = function (message, pspChannel, lifecycleManager) {
    fluid.log("pspChannel received a message: ", message);
    if (message.type === "modelChanged") {
        pspChannel.applier.change("", message.value, "ADD", "PSP");
    }
    if (message.type === "pullModel") {
        lifecycleManager.readPreferences(message.value.settingControls, pspChannel.events.preferenceReadSuccess, pspChannel.events.preferenceReadFail);
    }
};
