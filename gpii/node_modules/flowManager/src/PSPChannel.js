"use strict";


var fluid = require("infusion");
var gpii = fluid.registerNamespace("gpii");

fluid.registerNamespace("gpii.flowManager");

// A mixin grade applied to the lifecycleManager's session by the pspChannel
fluid.defaults("gpii.pspChannel.sessionBinder", {
    modelRelay: {
        pspChannel: {
            source: { // Not "" because of FLUID-6192
                segs: []
            },
            target: "{flowManager}.pspChannel.model",
            singleTransform: {
                type: "gpii.pspChannel.sessionToPSP",
                ontologyMetadata: "{ontologyHandler}.ontologyMetadata"
            },
            // compensate for FLUID-6194
            backward: "never",
            forward: {
                // avoid notifying the client for the init of LifecycleManagerSession, simplifies test and clients
                excludeSource: "init"
            }
        }
    },
    modelListeners: {
        updatePreferences: {
            path: "{flowManager}.pspChannel.model.settingControls",
            includeSource: "PSP",
            funcName: "{flowManager}.lifecycleManager.applyPreferences",
            args: ["{change}.value", "{pspChannel}.events.preferencesAppliedLocal"]
        },
        updateContext: {
            path: "{flowManager}.pspChannel.model.activeContextName",
            includeSource: "PSP",
            funcName: "gpii.pspChannel.updateContext",
            args: ["{flowManager}.contextManager", "{pspChannel}", "{change}.value"]
        },
        savePreferences: { // explicit save when the save button is clicked
            path: "{flowManager}.pspChannel.model.saveButtonClickCount",
            includeSource: "PSP",
            listener: "gpii.pspChannel.savePreferences",
            args: ["{flowManager}", "{lifecycleManager}", "{pspChannel}.events.preferencesAppliedLocal"]
        }
    }
});

/**
 * The PSP channel maintains its own model of the PSP state, it contains the following data:
 *
 * "gpiiKey": "<GPII key>",           // currently logged in GPII key - { type: "string" }
 * "activeContextName": "<context name>", // currently applied context - { type: "string" }
 * "settingControls": {                   // any number of preferences with values and schemas
 *      "<preference URI 1>": {           // settings URI, note that '.'s are interpreted as paths unless escaped
 *          "value": <value for preference>,   // the value that the given preference has
 *          "schema": { ... }                  // schema for the preference
 *      },
 *      "<preference URI 2>": { .. },
 *      "<preference URI N>": { .. }
 * },
 * "preferences": {                       // Used for listing available contexts and name of preference set
 *      "name": "My preference set",
 *      "contexts": {
 *          "<context 1 name>": {         // the name/id of the context
 *              "name": "<human readable name>" // name to be displayed in the PSP
 *          }
 *          "<context 2 name>": {...},
 *          "<context n name>": {...}
 *      }
 *  },
 * saveButtonClickCount                   // increments by 1 every time the save button is clicked
 */
fluid.defaults("gpii.pspChannel", {
    gradeNames: ["fluid.modelComponent"],
    members: {
        outputBlocked: null
    },
    listeners: {
        "{lifecycleManager}.events.onSessionStop": {
            namespace: "pspChannel",
            funcName: "gpii.pspChannel.sessionStop",
            args: "{pspChannel}"
        }
    },
    events: {
        // Fired when preferences are applied to the local computer. Its main current purpose is to compose the aggregate event "preferencesApplied"
        preferencesAppliedLocal: null,
        // Fired when preferences are applied to the local computer and saved to the cloud.
        preferencesApplied: {
            events: {
                preferencesAppliedLocal: "preferencesAppliedLocal",
                preferencesSavedSuccess: "{gpii.flowManager}.events.preferencesSavedSuccess"
            }
        }
    }
});

gpii.pspChannel.updateContext = function (contextManager, pspChannel, newContext) {
    fluid.log("Received context update from PSP UI of ", newContext);
    // Abominable hack to avoid confusing client with numerous update messages. The ChangeApplier should really support
    // "manifest transactions" / "vertical transactions"
    pspChannel.outputBlocked = fluid.promise();
    var clearBlock = function () {
        delete pspChannel.outputBlocked;
    };
    pspChannel.outputBlocked.then(clearBlock, clearBlock);
    pspChannel.applier.change([], null, "DELETE");
    var promise = contextManager.contextChanged(newContext);
    if (promise) {
        fluid.promise.follow(promise, pspChannel.outputBlocked);
    } else {
        pspChannel.outputBlocked.resolve();
    }
};

gpii.pspChannel.filterSolution = function (solution) {
    return {
        name: solution.name,
        settingsHandlers: fluid.transform(solution.settingsHandlers, function (oneHandler) {
            return fluid.filterKeys(oneHandler, ["supportedSettings"]);
        })
    };
};

// Explicit save when the save button is clicked
gpii.pspChannel.savePreferences = function (flowManager, lifecycleManager, preferencesAppliedLocalEvent) {
    // Grab current active lifecycle manager session
    var userSession = lifecycleManager.getSession();
    var gpiiKey = userSession.model.gpiiKey;
    var preferences = userSession.model.preferences;
    fluid.log("PSPChannel: explicit save for gpiiKey (", gpiiKey, "), with preferences: ", preferences);
    flowManager.savePreferences(gpiiKey, preferences);

    // At explicit save, preferencesAppliedLocal event will not be triggered. This event is only triggered when
    // there is setting change that needs to be applied to the local computer. Directly firing this event is to
    // trigger its parent aggregate event "preferencesApplied" to be fired.
    preferencesAppliedLocalEvent.fire();
};

/** Emit an entry in the `settingControls` block for a single setting.
 *
 * @param {Object} settingControls - *This object will be modified by the function's action* One top-level member
 * will be added to this object, with a key given by composing the argument `keySegs`. The value of the
 * member will be a structure {SettingControl} consisting of:
 *     @member {Any} value - The actual value of the corresponding setting.
 *     @member {JSONSchema} schema - A JSON schema structure describing the value space of the setting.
 *     @member {String} [solutionName] - [optional] The solution name to which this setting is allocated in the preferences
 * document, if there is one. If it is defined as a top-level common term, this member will be omitted.
 *     @member {String} liveness - The liveness value of the setting.
 */

gpii.pspChannel.emitSettingControl = function (settingControls, schema, prefVal, keySegs, liveness, solutionName) {
    var fullKey = fluid.pathUtil.composeSegments.apply(null, keySegs);
    if (schema) {
        settingControls[fullKey] = {
            value: prefVal,
            schema: schema.schema,
            solutionName: solutionName,
            liveness: liveness
        };
    }
};

/** Transduces the session model held for the currently logged-on user in the LifecycleManager's session into the model
 * structure which is suitable for shipping to the PSP over its bus. Each setting control output in the section
 * `settingControls` will be dumped using the utility `gpii.pspChannel.emitSettingControl`. This is a model relay
 * function which is run continuously as the session's model is updated.
 *
 * @param {Object} model - The LifecycleManager's session model.
 * @param {ModelTransformSpec} transformSpec - The model transformation spec.
 * @return {Object} The output model suitable for shipping to the PSP, including top-level members:
 *     - {Object} settingControls - A hash keyed by preference path, whose values are {SettingControl} objects.
 *     - {Object} preferences - A filtered skeleton of the user's preferences document, just containing the names of `contexts.
 */
gpii.pspChannel.sessionToPSP = function (model, transformSpec) {
    var schemas = transformSpec.ontologyMetadata.flat;
    var outModel = fluid.filterKeys(model, ["gpiiKey", "activeContextName"]);
    var settingControls = {};
    var activePreferences = fluid.get(model, ["preferences", "contexts", model.activeContextName, "preferences"]);
    var prefApplicationPrefix = "http://registry.gpii.net/applications/";

    fluid.each(activePreferences, function (prefsVal, prefsKey) {
        if (prefsKey.startsWith(prefApplicationPrefix)) {
            var solKey = prefsKey.substring(prefApplicationPrefix.length);
            var solution = model.solutionsRegistryEntries[solKey];
            if (solution) {
                fluid.each(prefsVal, function (innerPrefsVal, innerPrefsKey) {
                    var liveness = gpii.matchMakerFramework.utils.getLeastLiveness([ solution ], innerPrefsKey);
                    gpii.pspChannel.emitSettingControl(settingControls, schemas[innerPrefsKey], innerPrefsVal, [prefsKey, innerPrefsKey], liveness, solution.name);
                });
            }
        } else {
            var activeSolutionIds = Object.keys(fluid.get(model, "activeConfiguration.inferredConfiguration.applications"));
            var activeSolutions = fluid.filterKeys(model.solutionsRegistryEntries, activeSolutionIds);
            var liveness = gpii.matchMakerFramework.utils.getLeastLiveness(activeSolutions, prefsKey);
            gpii.pspChannel.emitSettingControl(settingControls, schemas[prefsKey], prefsVal, [prefsKey], liveness);
        }
    });
    outModel.settingControls = settingControls;
    outModel.preferences = {
        name: fluid.get(model, "preferences.name"),
        contexts: fluid.transform(fluid.get(model, "preferences.contexts"), function (contextVal) {
            return fluid.filterKeys(contextVal, ["name"]);
        })
    };
    return outModel;
};


gpii.pspChannel.modelChangeListener = function (handler, pspChannel, value, oldValue, path, transaction) {
    fluid.log("PSPChannel's PSP-facing modelChangeListener, sources are ", fluid.keys(transaction.sources));
    if (!transaction.sources.PSP && !transaction.sources.SessionCleanup) {
        fluid.log("Model change source is not PSP - candidate for update message");
        if (pspChannel.outputBlocked) {
            // Ensure that we queue just a single outgoing message for when the channel unblocks
            if (!pspChannel.outputBlocked.queued) {
                pspChannel.outputBlocked.queued = true;
                pspChannel.outputBlocked.then(function () {
                    fluid.log("PSPChannel sending unblocked full update message", JSON.stringify(pspChannel.model, null, 2));
                    handler.sendTypedMessage("modelChanged", {path: [], type: "ADD", value: pspChannel.model});
                });
            }
        } else {
            var changes = fluid.modelPairToChanges(value, oldValue);
            var hasDeletion = fluid.find(changes, function (change) {
                return change.type === "DELETE";
            });
            if (hasDeletion) {
                changes.forEach(function (change) {
                    handler.sendTypedMessage("modelChanged", change);
                });
            } else {
                handler.sendTypedMessage("modelChanged", {path: [], type: "ADD", value: value});
            }
        }
    }
};

gpii.pspChannel.sessionStop = function (pspChannel) {
    pspChannel.applier.change("", null, "DELETE");
};

fluid.defaults("gpii.pspChannel.handler", {
    gradeNames: ["kettle.request.ws"],
    invokers: {
        modelChangeListener: {
            funcName: "gpii.pspChannel.modelChangeListener",
            args: ["{that}", "{pspChannel}", "{arguments}.0", "{arguments}.1", "{arguments}.2", "{arguments}.4"]
                                             // value, oldValue, pathSegs, transaction: http://docs.fluidproject.org/infusion/development/ChangeApplierAPI.html#programmatic-style-for-listening-to-changes
        }
    },
    listeners: {
        onBindWs: {
            funcName: "gpii.pspChannel.bindWs",
            args: ["{that}", "{pspChannel}"]
        },
        "{pspChannel}.events.preferencesApplied": {
            funcName: "{that}.sendTypedMessage",
            args: [ "preferencesApplied" ]
        },
        onReceiveMessage: {
            funcName: "gpii.pspChannel.receiveMessage",
            args: ["{arguments}.1", "{pspChannel}"]
        },
        "onDestroy.unbindModel": {
            func: "{pspChannel}.applier.modelChanged.removeListener",
            args: ["{that}.id"]
        }
    }
});

gpii.pspChannel.bindWs = function (handler, pspChannel) {
    pspChannel.applier.modelChanged.addListener("", handler.modelChangeListener, handler.id);
    // Note that this is inconsistent with the Nexus' protocol, but is more correct - for example if the model consists
    // purely of a primitive or is undefined, the initial Nexus message will break
    handler.sendTypedMessage("modelChanged", {path: [], type: "ADD", value: pspChannel.model});
};

/**
 * Adjusts the preference message payload to match the local model. E.g. a preference change from the PSP has the
 * following path: [ "preferences", "http://registry\\.gpii\\.net/common/magnification" ] which should be
 * translated to something that matches the PSP Channels model, such as
 * [ "settingControls", "http://registry\\.gpii\\.net/common/magnification", "value" ]
 *
 * @param {Object} message - The message recieved via the PSP socket. WARNING - note that the `path` value of
 *     this object will be modified.
 */
gpii.pspChannel.adjustPreferenceMessage = function (message) {
    message.path[0] = "settingControls";
    message.path.push("value");
};

gpii.pspChannel.receiveMessage = function (message, pspChannel) {
    fluid.log("pspChannel received a message: ", message);
    if (message.path && message.path[0] === "preferences") {
        gpii.pspChannel.adjustPreferenceMessage(message);     // Modify to fit model if it is a change in preferences
    }
    pspChannel.applier.change(message.path, message.value, "ADD", "PSP");
};
