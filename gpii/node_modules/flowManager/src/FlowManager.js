/*
 * GPII Flow Manager
 *
 * Copyright 2012 OCAD University
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion"),
    gpii = fluid.registerNamespace("gpii");

require("kettle");

require("./UserLogonHandlers.js");
require("./BrowserChannel.js");
require("./PSPChannel.js");
require("./CloudBasedFlowManager.js"); // TODO: move this include to be operated by a config
require("./SettingsGetHandler.js");
require("./SettingsPutHandler.js");
require("./SettingsDataSource.js");
require("./UntrustedFlowManager.js");

require("preferencesServer");
require("lifecycleManager");
require("transformer");
require("journal");
require("singleInstance");
require("eventLog");
require("gpii-user-errors");

fluid.defaults("gpii.flowManager", {
    gradeNames: ["kettle.app"],
    components: {
        solutionsRegistryDataSource: {
            type: "kettle.dataSource",
            options: {
                termMap: {
                    "os": "%os",
                    "version": "%version"
                },
                components: {
                    encoding: {
                        type: "kettle.dataSource.encoding.JSON5"
                    }
                }
            }
        },
        matchMakerFramework: {
            type: "gpii.matchMakerFramework"
        },
        browserChannel: {
            type: "gpii.flowManager.browserChannel"
        },
        ontologyHandler: {
            type: "gpii.ontologyHandler"
        }
    }
});


// Mixin grades for the FlowManager

fluid.defaults("gpii.flowManager.local", {
    // Distribute the grade to handle user logon requests.
    // In all-in-local config, the handler is "gpii.lifecycleManager.userLogonHandling.matchMakingStateChangeHandler".
    // In untrusted config, the handler should be "gpii.lifecycleManager.untrusted.stateChangeHandler".
    distributeOptions: {
        "lifecycleManager.loginRequestHandler": {
            record: "gpii.lifecycleManager.userLogonHandling.matchMakingStateChangeHandler",
            target: "{that gpii.lifecycleManager.loginRequest}.options.gradeNames"
        }
    },
    components: {
        lifecycleManager: {
            type: "gpii.lifecycleManager",
            options: {
                components: {
                    userErrors: "{gpii.flowManager.local}.userErrors"
                }
            }
        },
        deviceReporterDataSource: {
            type: "kettle.dataSource"
        },
        journal: {
            type: "gpii.journal",
            options: {
                gradeNames: ["gpii.journalLifecycleManager", "gpii.journalApp"]
            }
        },
        eventLog: {
            type: "gpii.eventLog"
        },
        userListeners: {
            type: "gpii.userListeners"
        },
        webSocketsSettingsHandlerComponent: {
            type: "gpii.settingsHandlers.webSockets.component"
        },
        pspChannel: {
            type: "gpii.pspChannel"
        },
        userErrors: {
            type: "gpii.userErrors"
        }
    },
    requestHandlers: {
        userLogin: {
            route: "/user/:gpiiKey/login",
            method: "get",
            type: "gpii.flowManager.userLogin.handler"
        },
        userLogout: {
            route: "/user/:gpiiKey/logout",
            method: "get",
            type: "gpii.flowManager.userLogout.handler"
        },
        proximityTriggered: {
            route: "/user/:gpiiKey/proximityTriggered",
            method: "get",
            type: "gpii.flowManager.proximityTrigger.handler"
        },
        browserChannel: {
            route: "/browserChannel",
            type: "gpii.flowManager.browserChannel.handler"
        },
        pspChannel: {
            route: "/pspChannel",
            type: "gpii.pspChannel.handler"
        }
    },
    invokers: {
        // This placeholder function simply returns an empty promise. It should be
        // overridden if a handling is required when users update their preferences.
        setSettings: "gpii.flowManager.local.setSettings",
        savePreferences: {
            funcName: "gpii.flowManager.local.savePreferences",
            args: ["{that}", "{arguments}.0", "{arguments}.1"]
        }
    },
    events: {
        preferencesSavedSuccess: null,
        preferencesSavedError: null,
        noUserLoggedIn: null
    },
    listeners: {
        "onCreate.registerInstance": "gpii.singleInstance.registerInstance",
        "onCreate.mountWebSocketsSettingsHandler": {
            funcName: "gpii.flowManager.local.mountWebSocketsSettingsHandler",
            args: ["{webSocketsSettingsHandlerComponent}"]
        },
        // login with "noUser" when GPII starts so that QSS is still operable
        "{kettle.server}.events.onListen": {
            listener: "gpii.flowManager.local.noUserLoggedIn",
            args: ["{lifecycleManager}", "{that}.events.noUserLoggedIn"],
            namespace: "loginWithNoUser"
        },
        "afterDestroy.deregisterInstance": "gpii.singleInstance.deregisterInstance",
        "{lifecycleManager}.events.preferencesUserUpdated": {
            namespace: "savePreferences",
            listener: "{that}.savePreferences"
        }
    }
});

gpii.flowManager.local.mountWebSocketsSettingsHandler = function (webSocketsSettingsHandlerComponent) {
    gpii.settingsHandlers.webSockets.instance = webSocketsSettingsHandlerComponent;
};

gpii.flowManager.local.setSettings = function () {
    return fluid.promise().resolve();
};

gpii.flowManager.local.noUserLoggedIn = function (lifecycleManager, noUserLoggedInEvent) {
    var promise = lifecycleManager.addToUserLogonRequestQueue({
        gpiiKey: "noUser",
        logonState: "login"
    });
    promise.then(noUserLoggedInEvent.fire);
};

/**
 * Auto save updated preferences received from PSP or QSS.
 * @param {Component} that - An instance of gpii.flowManager.local.
 * @param {String} [gpiiKey] - [optional] The GPII key that the auto-saved preferences associates with.
 * @param {Object} [preferences] - [optional] The preferences to be auto saved to the cloud.
 * Note: when there isn't any preference to be auto saved, gpiiKey and preferences should not be provided.
 * In this case, preferencesSavedSuccess event will be fired, which will trigger the firing of its parent
 * aggregate event preferencesApplied for the auto save process to proceed.
 */
gpii.flowManager.local.savePreferences = function (that, gpiiKey, preferences) {
    // Don't support the save when the active user is "noUser"
    if (gpiiKey && preferences && gpiiKey !== "noUser") {
        // Auto save updated preferences that are allowed to be auto saved.
        var savePromise = that.setSettings(gpiiKey, preferences);
        savePromise.then(that.events.preferencesSavedSuccess.fire, that.events.preferencesSavedError.fire);
    } else {
        // When the updated preferences are not allowed to be auto saved, fire success event automatically
        that.events.preferencesSavedSuccess.fire();
    }
};
