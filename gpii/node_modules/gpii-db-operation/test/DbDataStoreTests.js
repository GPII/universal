/**
 GPII DB Data Store Tests

 Copyright 2016-2017 OCAD University

 Licensed under the New BSD license. You may not use this file except in
 compliance with this License.

 You may obtain a copy of the License at
 https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion"),
    gpii  = fluid.registerNamespace("gpii");

require("gpii-couchdb-test-harness");
gpii.test.couchdb.loadTestingSupport();

require("gpii-db-operation");
require("./DbDataStoreTestsUtils.js");

// The test data is from %gpii-db-operation/test/data/*.json
fluid.defaults("gpii.tests.dbDataStore.findGpiiKey", {
    gradeNames: ["gpii.tests.dbDataStore.environment"],
    rawModules: [{
        name: "Test findGpiiKey()",
        tests: [
            {
                name: "Find a GPII key record by a GPII key",
                sequence: [{
                    task: "{dbDataStore}.findGpiiKey",
                    args: ["chrome_high_contrast"],
                    resolve: "jqUnit.assertDeepEq",
                    resolveArgs: ["The expected GPII key data is received", gpii.tests.dbDataStore.testData.gpiiKeyChromehcDefault, "{arguments}.0"]
                }]
            },
            {
                name: "Finding a GPII key record by a non-existing GPII key returns undefined",
                sequence: [
                    {
                        task: "{dbDataStore}.findGpiiKey",
                        args: ["non-existing"],
                        resolve: "jqUnit.assertUndefined",
                        resolveArgs: ["Finding an user by a non-existing GPII key returns undefined", "{arguments}.0"]
                    }]
            },
            {
                name: "Not providing a GPII key returns 400 status code and error message",
                sequence: [{
                    task: "{dbDataStore}.findGpiiKey",
                    args: [],
                    reject: "jqUnit.assertDeepEq",
                    rejectArgs: ["The expected error is received", {
                        message: "The input field \"id\" was undefined",
                        statusCode: 400,
                        isError: true
                    }, "{arguments}.0"]
                }]
            }
        ]
    }]
});

fluid.defaults("gpii.tests.dbDataStore.findPrefsSafeByGpiiKey", {
    gradeNames: ["gpii.tests.dbDataStore.environment"],
    rawModules: [{
        name: "Test findPrefsSafeByGpiiKey()",
        tests: [
            {
                name: "Find preferences by a proper GPII key that associates with a prefs safe",
                sequence: [{
                    task: "{dbDataStore}.findPrefsSafeByGpiiKey",
                    args: ["chrome_high_contrast"],
                    resolve: "jqUnit.assertDeepEq",
                    resolveArgs: ["The expected client data is received", gpii.tests.dbDataStore.testData.findPrefsSafeByGpiiKey_withPrefsSafe, "{arguments}.0"]
                }]
            },
            {
                name: "Find preferences by a proper GPII key that does not associate with any prefs safe",
                sequence: [{
                    task: "{dbDataStore}.findPrefsSafeByGpiiKey",
                    args: ["chrome_high_contrast_dark"],
                    resolve: "jqUnit.assertDeepEq",
                    resolveArgs: ["The expected client data is received", gpii.tests.dbDataStore.testData.findPrefsSafeByGpiiKey_noPrefsSafe, "{arguments}.0"]
                }]
            },
            {
                name: "Finding preferences by a non-existing GPII key returns undefined",
                sequence: [{
                    task: "{dbDataStore}.findPrefsSafeByGpiiKey",
                    args: ["non-existing"],
                    resolve: "jqUnit.assertUndefined",
                    resolvArgs: ["Finding preferences by a non-existing GPII key returns undefined", "{arguments}.0"]
                }]
            },
            {
                name: "Not providing an GPII key returns 400 status code and error message",
                sequence: [{
                    task: "{dbDataStore}.findPrefsSafeByGpiiKey",
                    args: [],
                    reject: "jqUnit.assertDeepEq",
                    rejectArgs: ["The expected error is received", {
                        message: "The input field \"gpiiKey\" was undefined",
                        statusCode: 400,
                        isError: true
                    }, "{arguments}.0"]
                }]
            }]
    }]
});

fluid.defaults("gpii.tests.dbDataStore.findClientById", {
    gradeNames: ["gpii.tests.dbDataStore.environment"],
    rawModules: [{
        name: "Test findClientById()",
        tests: [
            {
                name: "Find a client record by a proper client id",
                sequence: [{
                    task: "{dbDataStore}.findClientById",
                    args: ["gpiiAppInstallationClient-1"],
                    resolve: "jqUnit.assertDeepEq",
                    resolveArgs: ["The expected client data is received", gpii.tests.dbDataStore.testData.client1, "{arguments}.0"]
                }]
            },
            {
                name: "Finding a client record by a non-existing client id returns undefined",
                sequence: [{
                    task: "{dbDataStore}.findClientById",
                    args: ["non-existing"],
                    resolve: "jqUnit.assertUndefined",
                    resolveArgs: ["Finding a client by a non-existing client id returns undefined", "{arguments}.0"]
                }]
            },
            {
                name: "Not providing client id returns 400 status code and error message",
                sequence: [{
                    task: "{dbDataStore}.findClientById",
                    args: [],
                    reject: "jqUnit.assertDeepEq",
                    rejectArgs: ["The expected error is received", {
                        message: "The input field \"id\" was undefined",
                        statusCode: 400,
                        isError: true
                    }, "{arguments}.0"]
                }]
            }
        ]
    }]
});

fluid.defaults("gpii.tests.dbDataStore.findClientCredentialById", {
    gradeNames: ["gpii.tests.dbDataStore.environment"],
    rawModules: [{
        name: "Test findClientCredentialById()",
        tests: [
            {
                name: "Find a client credential record by a proper client credential id",
                sequence: [{
                    task: "{dbDataStore}.findClientCredentialById",
                    args: ["clientCredential-1"],
                    resolve: "jqUnit.assertDeepEq",
                    resolveArgs: ["The expected client data is received", gpii.tests.dbDataStore.testData.clientCredential1, "{arguments}.0"]
                }]
            },
            {
                name: "Finding a client record by a non-existing client credential id returns undefined",
                sequence: [{
                    task: "{dbDataStore}.findClientCredentialById",
                    args: ["non-existing"],
                    resolve: "jqUnit.assertUndefined",
                    resolveArgs: ["Finding a client by a non-existing client credential id returns undefined", "{arguments}.0"]
                }]
            },
            {
                name: "Not providing client credential id returns 400 status code and error message",
                sequence: [{
                    task: "{dbDataStore}.findClientCredentialById",
                    args: [],
                    reject: "jqUnit.assertDeepEq",
                    rejectArgs: ["The expected error is received", {
                        message: "The input field \"id\" was undefined",
                        statusCode: 400,
                        isError: true
                    }, "{arguments}.0"]
                }]
            }
        ]
    }]
});

fluid.defaults("gpii.tests.dbDataStore.findClientByOauth2ClientId", {
    gradeNames: ["gpii.tests.dbDataStore.environment"],
    rawModules: [{
        name: "Test findClientByOauth2ClientId()",
        tests: [
            {
                name: "Find a client record by a proper oauth2 client id",
                sequence: [{
                    task: "{dbDataStore}.findClientByOauth2ClientId",
                    args: ["net.gpii.ajc.bakersfield"],
                    resolve: "jqUnit.assertDeepEq",
                    resolveArgs: ["The expected client data is received", gpii.tests.dbDataStore.testData.findClientByOauth2ClientId, "{arguments}.0"]
                }]
            },
            {
                name: "Finding a client record by a non-existing oauth2 client id returns undefined",
                sequence: [{
                    task: "{dbDataStore}.findClientByOauth2ClientId",
                    args: ["non-existing"],
                    resolve: "jqUnit.assertUndefined",
                    resolveArgs: ["Finding a client by a non-existing oauth2 client id returns undefined", "{arguments}.0"]
                }]
            },
            {
                name: "Not providing an oauth2 client id returns 400 status code and error message",
                sequence: [{
                    task: "{dbDataStore}.findClientByOauth2ClientId",
                    args: [],
                    reject: "jqUnit.assertDeepEq",
                    rejectArgs: ["The expected error is received", {
                        message: "The input field \"oauth2ClientId\" was undefined",
                        statusCode: 400,
                        isError: true
                    }, "{arguments}.0"]
                }]
            }
        ]
    }]
});

fluid.defaults("gpii.tests.dbDataStore.findAuthorizationByAccessToken", {
    gradeNames: ["gpii.tests.dbDataStore.environment"],
    rawModules: [{
        name: "Test findAuthorizationByAccessToken()",
        tests: [
            {
                name: "Find an authorization information by a GPII app installation access token",
                sequence: [{
                    task: "{dbDataStore}.findAuthorizationByAccessToken",
                    args: ["gpii-app-installation-accessToken-1"],
                    resolve: "jqUnit.assertDeepEq",
                    resolveArgs: ["The expected data is received", gpii.tests.dbDataStore.testData.findGpiiAppInstallationAuthorizationByAccessToken, "{arguments}.0"]
                }]
            },
            {
                name: "Returns undefined when the authorization is revoked",
                sequence: [{
                    task: "{dbDataStore}.findAuthorizationByAccessToken",
                    args: ["gpii-app-installation-accessToken-3"],
                    resolve: "jqUnit.assertDeepEq",
                    resolveArgs: ["The expected undefined is received", undefined, "{arguments}.0"]
                }]
            },
            {
                name: "Not providing an input argument returns 400 status code and error message",
                sequence: [{
                    task: "{dbDataStore}.findAuthorizationByAccessToken",
                    args: [],
                    reject: "jqUnit.assertDeepEq",
                    rejectArgs: ["The expected error is received", {
                        message: "The input field \"accessToken\" was undefined",
                        statusCode: 400,
                        isError: true
                    }, "{arguments}.0"]
                }]
            },
            {
                name: "Find by a non-existing access token returns undefined",
                sequence: [{
                    task: "{dbDataStore}.findAuthorizationByAccessToken",
                    args: ["non-existing"],
                    resolve: "jqUnit.assertDeepEq",
                    resolveArgs: ["The expected error is received", undefined, "{arguments}.0"]
                }]
            }
        ]
    }]
});

fluid.defaults("gpii.tests.dbDataStore.findAllViews", {
    gradeNames: ["gpii.tests.dbDataStore.environment"],
    rawModules: [{
        name: "Test findAllViews()",
        tests: [{
            name: "Find all views",
            sequence: [{
                task: "{dbDataStore}.findAllViews",
                args: [],
                resolve: "jqUnit.assertValue",
                resolveArgs: ["The views received", "{arguments}.0.views"]
            }]
        }]
    }]
});

fluid.defaults("gpii.tests.dbDataStore.addGpiiKey", {
    gradeNames: ["gpii.tests.dbDataStore.environment"],
    rawModules: [{
        name: "Test addGpiiKey()",
        tests: [
            {
                name: "Add a GPII key - auto generates the GPII key if the key value is not provided at the input",
                sequence: [{
                    task: "gpii.tests.dbDataStore.executeFnAndVerifyResults",
                    args: ["{dbDataStore}", "addGpiiKey", [gpii.tests.dbDataStore.testData.gpiiKeyToCreate_noGpiiKey], "{testCaseHolder}"], // dbDataStore, fnName, fnArgs, caseHolder
                    resolve: "gpii.tests.dbDataStore.verifyFetchedGpiiKey",
                    resolveArgs: ["{arguments}.0", gpii.tests.dbDataStore.testData.gpiiKeyToCreate_noGpiiKey, "{that}"]
                }]
            },
            {
                name: "Add a GPII key - use the provided GPII key if it is provided at the input",
                sequence: [{
                    task: "gpii.tests.dbDataStore.executeFnAndVerifyResults",
                    args: ["{dbDataStore}", "addGpiiKey", [gpii.tests.dbDataStore.testData.gpiiKeyToCreate_withGpiiKey], "{testCaseHolder}"], // dbDataStore, fnName, fnArgs, caseHolder
                    resolve: "gpii.tests.dbDataStore.verifyFetchedGpiiKey",
                    resolveArgs: ["{arguments}.0", gpii.tests.dbDataStore.testData.gpiiKeyToCreate_withGpiiKey, "{that}"]
                }]
            },
            {
                name: "Not providing gpiiKeyData still creates a new GPII key but it does not associate with a prefs safe.",
                sequence: [{
                    task: "gpii.tests.dbDataStore.executeFnAndVerifyResults",
                    args: ["{dbDataStore}", "addGpiiKey", [undefined], "{testCaseHolder}"], // dbDataStore, fnName, fnArgs, caseHolder
                    resolve: "gpii.tests.dbDataStore.verifyFetchedGpiiKey",
                    resolveArgs: ["{arguments}.0", {
                        prefsSafeId: null,
                        prefsSetId: null
                    }, "{that}"]
                }]
            }
        ]
    }]
});

fluid.defaults("gpii.tests.dbDataStore.updateGpiiKey", {
    gradeNames: ["gpii.tests.dbDataStore.environment"],
    rawModules: [{
        name: "Test updateGpiiKey()",
        tests: [
            {
                name: "Update a GPII key",
                sequence: [{
                    task: "gpii.tests.dbDataStore.executeFnAndVerifyResults",
                    args: ["{dbDataStore}", "updateGpiiKey", ["chrome_high_contrast", gpii.tests.dbDataStore.testData.gpiiKeyToUpdate], "{testCaseHolder}"], // dbDataStore, fnName, fnArgs, caseHolder
                    resolve: "gpii.tests.dbDataStore.verifyUpdatedRecord",
                    resolveArgs: ["{arguments}.0", gpii.tests.dbDataStore.testData.gpiiKeyToUpdate, "{that}"]
                }]
            },
            {
                name: "Not providing gpiiKey returns error",
                sequence: [{
                    task: "{dbDataStore}.updateGpiiKey",
                    args: [undefined, gpii.tests.dbDataStore.testData.gpiiKeyToUpdate],
                    reject: "jqUnit.assertDeepEq",
                    rejectArgs: ["The expected error is received", {
                        message: "The input field \"gpiiKey\" was undefined",
                        statusCode: 400,
                        isError: true
                    }, "{arguments}.0"]
                }]
            },
            {
                name: "Updating an empty object returns error",
                sequence: [{
                    task: "{dbDataStore}.updateGpiiKey",
                    args: ["chrome_high_contrast", undefined],
                    reject: "jqUnit.assertDeepEq",
                    rejectArgs: ["The expected error is received", {
                        message: "A record of type \"gpiiKey\" was not found",
                        statusCode: 400,
                        isError: true
                    }, "{arguments}.0"]
                }]
            },
            {
                name: "Updating a document type other than gpiiKey returns an error",
                sequence: [{
                    task: "{dbDataStore}.updateGpiiKey",
                    args: ["prefsSafe-1", {type: "non-gpiiKey"}],
                    reject: "jqUnit.assertDeepEq",
                    rejectArgs: ["The expected error is received", {
                        message: "The document type must be \"gpiiKey\" instead of the selected document type \"non-gpiiKey\"",
                        statusCode: 400,
                        isError: true
                    }, "{arguments}.0"]
                }]
            }
        ]
    }]
});

fluid.defaults("gpii.tests.dbDataStore.addPrefsSafe", {
    gradeNames: ["gpii.tests.dbDataStore.environment"],
    rawModules: [{
        name: "Test addPrefsSafe()",
        tests: [
            {
                name: "Add a prefs safe",
                sequence: [{
                    task: "gpii.tests.dbDataStore.executeFnAndVerifyResults",
                    args: ["{dbDataStore}", "addPrefsSafe", [gpii.tests.dbDataStore.testData.prefsSafeToCreate], "{testCaseHolder}"], // dbDataStore, fnName, fnArgs, caseHolder
                    resolve: "gpii.tests.dbDataStore.verifyCreatedPrefsSafe",
                    resolveArgs: ["{arguments}.0", gpii.tests.dbDataStore.testData.prefsSafeToCreate, "{that}"]
                }]
            },
            {
                name: "Adding an empty object returns error",
                sequence: [{
                    task: "{dbDataStore}.addPrefsSafe",
                    args: [undefined],
                    reject: "jqUnit.assertDeepEq",
                    rejectArgs: ["The expected error is received", {
                        message: "A record of type \"prefsSafe\" was not found",
                        statusCode: 400,
                        isError: true
                    }, "{arguments}.0"]
                }]
            }
        ]
    }]
});

fluid.defaults("gpii.tests.dbDataStore.updatePrefsSafe", {
    gradeNames: ["gpii.tests.dbDataStore.environment"],
    rawModules: [{
        name: "Test updatePrefsSafe()",
        tests: [
            {
                name: "Update a prefs safe",
                sequence: [{
                    task: "gpii.tests.dbDataStore.executeFnAndVerifyResults",
                    args: ["{dbDataStore}", "updatePrefsSafe", ["prefsSafe-1", gpii.tests.dbDataStore.testData.prefsSafeToUpdate], "{testCaseHolder}"], // dbDataStore, fnName, fnArgs, caseHolder
                    resolve: "gpii.tests.dbDataStore.verifyUpdatedRecord",
                    resolveArgs: ["{arguments}.0", gpii.tests.dbDataStore.testData.prefsSafeToUpdate, "{that}"]
                }]
            },
            {
                name: "Not providing prefsSafeId returns error",
                sequence: [{
                    task: "{dbDataStore}.updatePrefsSafe",
                    args: [undefined, gpii.tests.dbDataStore.testData.prefsSafeToUpdate],
                    reject: "jqUnit.assertDeepEq",
                    rejectArgs: ["The expected error is received", {
                        message: "The input field \"prefsSafeId\" was undefined",
                        statusCode: 400,
                        isError: true
                    }, "{arguments}.0"]
                }]
            },
            {
                name: "Updating an empty object returns error",
                sequence: [{
                    task: "{dbDataStore}.updatePrefsSafe",
                    args: ["prefsSafe-1", undefined],
                    reject: "jqUnit.assertDeepEq",
                    rejectArgs: ["The expected error is received", {
                        message: "A record of type \"prefsSafe\" was not found",
                        statusCode: 400,
                        isError: true
                    }, "{arguments}.0"]
                }]
            },
            {
                name: "Updating a document type other that prefsSafe returns an error",
                sequence: [{
                    task: "{dbDataStore}.updatePrefsSafe",
                    args: ["prefsSafe-1", {type: "non-prefsSafe"}],
                    reject: "jqUnit.assertDeepEq",
                    rejectArgs: ["The expected error is received", {
                        message: "The document type must be \"prefsSafe\" instead of the selected document type \"non-prefsSafe\"",
                        statusCode: 400,
                        isError: true
                    }, "{arguments}.0"]
                }]
            }]
    }]
});

fluid.defaults("gpii.tests.dbDataStore.addAuthorization", {
    gradeNames: ["gpii.tests.dbDataStore.environment"],
    rawModules: [{
        name: "Test addAuthorization()",
        tests: [
            {
                name: "Add a GPII app installation authorization",
                sequence: [{
                    task: "gpii.tests.dbDataStore.executeFnAndVerifyResults",
                    args: ["{dbDataStore}", "addAuthorization", [gpii.tests.dbDataStore.testData.gpiiAppInstallationAuthorizationToCreate], "{testCaseHolder}"], // dbDataStore, fnName, fnArgs, caseHolder
                    resolve: "gpii.tests.dbDataStore.verifyFetchedGpiiAppInstallationAuthorization",
                    resolveArgs: ["{arguments}.0", gpii.tests.dbDataStore.testData.gpiiAppInstallationAuthorizationToCreate, "{that}"]
                }]
            },
            {
                name: "Adding an empty object returns error",
                sequence: [{
                    task: "{dbDataStore}.addAuthorization",
                    args: [undefined],
                    reject: "jqUnit.assertDeepEq",
                    rejectArgs: ["The expected error is received", {
                        message: "A record of type \"gpiiAppInstallationAuthorization\" was not found",
                        statusCode: 400,
                        isError: true
                    }, "{arguments}.0"]
                }]
            }
        ]
    }]
});

fluid.defaults("gpii.tests.dbDataStore.findPrefsSafeList", {
    gradeNames: ["gpii.tests.dbDataStore.environment"],
    rawModules: [{
        name: "Test findPrefsSafeList()",
        tests: [{
            name: "List prefs safes",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.findPrefsSafeList", [], "{that}"]
            }, {
                listener: "jqUnit.assertDeepEq",
                args: ["Expecing a list of all the safes.", gpii.tests.dbDataStore.testData.findPrefsSafeList_listing, "{arguments}.0"],
                event: "{that}.events.onResponse"
            }]
        }]
    }]
});

fluid.defaults("gpii.tests.dbDataStore.findRelatedDocsForPrefsSafe", {
    gradeNames: ["gpii.tests.dbDataStore.environment"],
    rawModules: [{
        name: "Test findRelatedDocsForPrefsSafe()",
        tests: [{
            name: "List prefs safes",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.findRelatedDocsForPrefsSafe", ["prefsSafe-1"], "{that}"]
            }, {
                listener: "jqUnit.assertLeftHand",
                args: ["Expecing a list of keys for prefsSafe-1.", gpii.tests.dbDataStore.testData.findRelatedDocsForPrefsSafe_prefsSafe1, "{arguments}.0"],
                event: "{that}.events.onResponse"
            }]
        }]
    }]
});

fluid.defaults("gpii.tests.dbDataStore.findSafeByExpressUserLookup", {
    gradeNames: ["gpii.tests.dbDataStore.environment"],
    rawModules: [{
        name: "Test findSafeByExpressUserLookup()",
        tests: [{
            name: "List prefs safes",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.findSafeByExpressUserLookup", ["org.couch.db.user:prefs1user"], "{that}"]
            }, {
                listener: "jqUnit.assertDeepEq",
                args: ["Expecing a safe from the express lookup.", gpii.tests.dbDataStore.testData.findSafeByExpressUserLookup_credential, "{arguments}.0"],
                event: "{that}.events.onResponse"
            }]
        }]
    }]
});

fluid.test.runTests([
    "gpii.tests.dbDataStore.findGpiiKey",
    "gpii.tests.dbDataStore.findClientById",
    "gpii.tests.dbDataStore.findClientCredentialById",
    "gpii.tests.dbDataStore.findPrefsSafeByGpiiKey",
    "gpii.tests.dbDataStore.findClientByOauth2ClientId",
    "gpii.tests.dbDataStore.findAuthorizationByAccessToken",
    "gpii.tests.dbDataStore.findAllViews",
    "gpii.tests.dbDataStore.addGpiiKey",
    "gpii.tests.dbDataStore.updateGpiiKey",
    "gpii.tests.dbDataStore.addPrefsSafe",
    "gpii.tests.dbDataStore.updatePrefsSafe",
    "gpii.tests.dbDataStore.addAuthorization",
    "gpii.tests.dbDataStore.findPrefsSafeList",
    "gpii.tests.dbDataStore.findRelatedDocsForPrefsSafe",
    "gpii.tests.dbDataStore.findSafeByExpressUserLookup"
]);
