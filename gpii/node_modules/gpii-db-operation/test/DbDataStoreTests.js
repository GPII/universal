/**
GPII DB Data Store Tests

Copyright 2016-2017 OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

"use strict";

var fluid = require("infusion"),
    gpii = fluid.registerNamespace("gpii");

require("gpii-pouchdb");
gpii.pouch.loadTestingSupport();

require("gpii-db-operation");
require("./DbDataStoreTestsUtils.js");

// The test data is from %gpii-db-operation/test/data/*.json
fluid.defaults("gpii.tests.dbDataStore.findGpiiKey", {
    gradeNames: ["gpii.tests.dbDataStore.environment"],
    rawModules: [{
        name: "Test findGpiiKey()",
        tests: [{
            name: "Find a GPII key record by a GPII key",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.findGpiiKey", ["chrome_high_contrast"], "{that}"]
            }, {
                listener: "jqUnit.assertDeepEq",
                args: ["The expected GPII key data is received", gpii.tests.dbDataStore.testData.gpiiKeyChromehcDefault, "{arguments}.0"],
                event: "{that}.events.onResponse"
            }]
        }, {
            name: "Finding a GPII key record by a non-existing GPII key returns undefined",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.findGpiiKey", ["non-existing"], "{that}"]
            }, {
                listener: "jqUnit.assertUndefined",
                args: ["Finding an user by a non-existing GPII key returns undefined", "{arguments}.0"],
                event: "{that}.events.onResponse"
            }]
        }, {
            name: "Not providing a GPII key returns 400 status code and error message",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.findGpiiKey", [], "{that}"]
            }, {
                listener: "jqUnit.assertDeepEq",
                args: ["The expected error is received", {
                    message: "The input field \"id\" was undefined",
                    statusCode: 400,
                    isError: true
                }, "{arguments}.0"],
                event: "{that}.events.onError"
            }]
        }]
    }]
});

fluid.defaults("gpii.tests.dbDataStore.findPrefsSafeByGpiiKey", {
    gradeNames: ["gpii.tests.dbDataStore.environment"],
    rawModules: [{
        name: "Test findPrefsSafeByGpiiKey()",
        tests: [{
            name: "Find preferences by a proper GPII key that associates with a prefs safe",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.findPrefsSafeByGpiiKey", ["chrome_high_contrast"], "{that}"]
            }, {
                listener: "jqUnit.assertDeepEq",
                args: ["The expected client data is received", gpii.tests.dbDataStore.testData.findPrefsSafeByGpiiKey_withPrefsSafe, "{arguments}.0"],
                event: "{that}.events.onResponse"
            }]
        }, {
            name: "Find preferences by a proper GPII key that does not associate with any prefs safe",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.findPrefsSafeByGpiiKey", ["chrome_high_contrast_dark"], "{that}"]
            }, {
                listener: "jqUnit.assertDeepEq",
                args: ["The expected client data is received", gpii.tests.dbDataStore.testData.findPrefsSafeByGpiiKey_noPrefsSafe, "{arguments}.0"],
                event: "{that}.events.onResponse"
            }]
        }, {
            name: "Finding preferences by a non-existing GPII key returns undefined",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.findPrefsSafeByGpiiKey", ["non-existing"], "{that}"]
            }, {
                listener: "jqUnit.assertUndefined",
                args: ["Finding preferences by a non-existing GPII key returns undefined", "{arguments}.0"],
                event: "{that}.events.onResponse"
            }]
        }, {
            name: "Not providing an GPII key returns 400 status code and error message",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.findPrefsSafeByGpiiKey", [], "{that}"]
            }, {
                listener: "jqUnit.assertDeepEq",
                args: ["The expected error is received", {
                    message: "The input field \"gpiiKey\" was undefined",
                    statusCode: 400,
                    isError: true
                }, "{arguments}.0"],
                event: "{that}.events.onError"
            }]
        }]
    }]
});

fluid.defaults("gpii.tests.dbDataStore.findClientById", {
    gradeNames: ["gpii.tests.dbDataStore.environment"],
    rawModules: [{
        name: "Test findClientById()",
        tests: [{
            name: "Find a client record by a proper client id",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.findClientById", ["gpiiAppInstallationClient-1"], "{that}"]
            }, {
                listener: "jqUnit.assertDeepEq",
                args: ["The expected client data is received", gpii.tests.dbDataStore.testData.client1, "{arguments}.0"],
                event: "{that}.events.onResponse"
            }]
        }, {
            name: "Finding a client record by a non-existing client id returns undefined",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.findClientById", ["non-existing"], "{that}"]
            }, {
                listener: "jqUnit.assertUndefined",
                args: ["Finding a client by a non-existing client id returns undefined", "{arguments}.0"],
                event: "{that}.events.onResponse"
            }]
        }, {
            name: "Not providing client id returns 400 status code and error message",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.findClientById", [], "{that}"]
            }, {
                listener: "jqUnit.assertDeepEq",
                args: ["The expected error is received", {
                    message: "The input field \"id\" was undefined",
                    statusCode: 400,
                    isError: true
                }, "{arguments}.0"],
                event: "{that}.events.onError"
            }]
        }]
    }]
});

fluid.defaults("gpii.tests.dbDataStore.findClientCredentialById", {
    gradeNames: ["gpii.tests.dbDataStore.environment"],
    rawModules: [{
        name: "Test findClientCredentialById()",
        tests: [{
            name: "Find a client credential record by a proper client credential id",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.findClientCredentialById", ["clientCredential-1"], "{that}"]
            }, {
                listener: "jqUnit.assertDeepEq",
                args: ["The expected client data is received", gpii.tests.dbDataStore.testData.clientCredential1, "{arguments}.0"],
                event: "{that}.events.onResponse"
            }]
        }, {
            name: "Finding a client record by a non-existing client credential id returns undefined",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.findClientCredentialById", ["non-existing"], "{that}"]
            }, {
                listener: "jqUnit.assertUndefined",
                args: ["Finding a client by a non-existing client credential id returns undefined", "{arguments}.0"],
                event: "{that}.events.onResponse"
            }]
        }, {
            name: "Not providing client credential id returns 400 status code and error message",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.findClientCredentialById", [], "{that}"]
            }, {
                listener: "jqUnit.assertDeepEq",
                args: ["The expected error is received", {
                    message: "The input field \"id\" was undefined",
                    statusCode: 400,
                    isError: true
                }, "{arguments}.0"],
                event: "{that}.events.onError"
            }]
        }]
    }]
});

fluid.defaults("gpii.tests.dbDataStore.findClientByOauth2ClientId", {
    gradeNames: ["gpii.tests.dbDataStore.environment"],
    rawModules: [{
        name: "Test findClientByOauth2ClientId()",
        tests: [{
            name: "Find a client record by a proper oauth2 client id",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.findClientByOauth2ClientId", ["net.gpii.ajc.bakersfield"], "{that}"]
            }, {
                listener: "jqUnit.assertDeepEq",
                args: ["The expected client data is received", gpii.tests.dbDataStore.testData.findClientByOauth2ClientId, "{arguments}.0"],
                event: "{that}.events.onResponse"
            }]
        }, {
            name: "Finding a client record by a non-existing oauth2 client id returns undefined",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.findClientByOauth2ClientId", ["non-existing"], "{that}"]
            }, {
                listener: "jqUnit.assertUndefined",
                args: ["Finding a client by a non-existing oauth2 client id returns undefined", "{arguments}.0"],
                event: "{that}.events.onResponse"
            }]
        }, {
            name: "Not providing an oauth2 client id returns 400 status code and error message",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.findClientByOauth2ClientId", [], "{that}"]
            }, {
                listener: "jqUnit.assertDeepEq",
                args: ["The expected error is received", {
                    message: "The input field \"oauth2ClientId\" was undefined",
                    statusCode: 400,
                    isError: true
                }, "{arguments}.0"],
                event: "{that}.events.onError"
            }]
        }]
    }]
});

fluid.defaults("gpii.tests.dbDataStore.findAuthorizationByAccessToken", {
    gradeNames: ["gpii.tests.dbDataStore.environment"],
    rawModules: [{
        name: "Test findAuthorizationByAccessToken()",
        tests: [{
            name: "Find an authorization information by a GPII app installation access token",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.findAuthorizationByAccessToken", ["gpii-app-installation-accessToken-1"], "{that}"]
            }, {
                listener: "jqUnit.assertDeepEq",
                args: ["The expected data is received", gpii.tests.dbDataStore.testData.findGpiiAppInstallationAuthorizationByAccessToken, "{arguments}.0"],
                event: "{that}.events.onResponse"
            }]
        }, {
            name: "Returns undefined when the authorization is revoked",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.findAuthorizationByAccessToken", ["gpii-app-installation-accessToken-3"], "{that}"]
            }, {
                listener: "jqUnit.assertDeepEq",
                args: ["The expected undefined is received", undefined, "{arguments}.0"],
                event: "{that}.events.onResponse"
            }]
        }, {
            name: "Not providing an input argument returns 400 status code and error message",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.findAuthorizationByAccessToken", [], "{that}"]
            }, {
                listener: "jqUnit.assertDeepEq",
                args: ["The expected error is received", {
                    message: "The input field \"accessToken\" was undefined",
                    statusCode: 400,
                    isError: true
                }, "{arguments}.0"],
                event: "{that}.events.onError"
            }]
        }, {
            name: "Find by a non-existing access token returns undefined",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.findAuthorizationByAccessToken", ["non-existing"], "{that}"]
            }, {
                listener: "jqUnit.assertDeepEq",
                args: ["The expected error is received", undefined, "{arguments}.0"],
                event: "{that}.events.onResponse"
            }]
        }]
    }]
});

fluid.defaults("gpii.tests.dbDataStore.findAllViews", {
    gradeNames: ["gpii.tests.dbDataStore.environment"],
    rawModules: [{
        name: "Test findAllViews()",
        tests: [{
            name: "Find all views",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.findAllViews", [], "{that}"]
            }, {
                listener: "jqUnit.assertValue",
                args: ["The views received", "{arguments}.0.views"],
                event: "{that}.events.onResponse"
            }]
        }]
    }]
});

fluid.defaults("gpii.tests.dbDataStore.addGpiiKey", {
    gradeNames: ["gpii.tests.dbDataStore.environment"],
    rawModules: [{
        name: "Test addGpiiKey()",
        tests: [{
            name: "Add a GPII key - auto generates the GPII key if the key value is not provided at the input",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.addGpiiKey", [gpii.tests.dbDataStore.testData.gpiiKeyToCreate_noGpiiKey], "{that}"]
            }, {
                listener: "gpii.tests.dbDataStore.saveAndInvokeFetch",
                args: ["{dbDataStore}.findById", "{arguments}.0.id", "{that}"],
                event: "{that}.events.onResponse"
            }, {
                listener: "gpii.tests.dbDataStore.verifyFetchedGpiiKey",
                args: ["{arguments}.0", gpii.tests.dbDataStore.testData.gpiiKeyToCreate_noGpiiKey, "{that}"],
                event: "{that}.events.onResponse"
            }]
        }, {
            name: "Add a GPII key - use the provided GPII key if it is provided at the input",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.addGpiiKey", [gpii.tests.dbDataStore.testData.gpiiKeyToCreate_withGpiiKey], "{that}"]
            }, {
                listener: "gpii.tests.dbDataStore.saveAndInvokeFetch",
                args: ["{dbDataStore}.findById", "{arguments}.0.id", "{that}"],
                event: "{that}.events.onResponse"
            }, {
                listener: "gpii.tests.dbDataStore.verifyFetchedGpiiKey",
                args: ["{arguments}.0", gpii.tests.dbDataStore.testData.gpiiKeyToCreate_withGpiiKey, "{that}"],
                event: "{that}.events.onResponse"
            }]
        }, {
            name: "Not providing gpiiKeyData still creates a new GPII key but it does not associate with a prefs safe.",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.addGpiiKey", [undefined], "{that}"]
            }, {
                listener: "gpii.tests.dbDataStore.saveAndInvokeFetch",
                args: ["{dbDataStore}.findById", "{arguments}.0.id", "{that}"],
                event: "{that}.events.onResponse"
            }, {
                listener: "gpii.tests.dbDataStore.verifyFetchedGpiiKey",
                args: ["{arguments}.0", {
                    prefsSafeId: null,
                    prefsSetId: null
                }, "{that}"],
                event: "{that}.events.onResponse"
            }]
        }]
    }]
});

fluid.defaults("gpii.tests.dbDataStore.updateGpiiKey", {
    gradeNames: ["gpii.tests.dbDataStore.environment"],
    rawModules: [{
        name: "Test updateGpiiKey()",
        tests: [{
            name: "Update a GPII key",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.updateGpiiKey", ["chrome_high_contrast", gpii.tests.dbDataStore.testData.gpiiKeyToUpdate], "{that}"]
            }, {
                listener: "gpii.tests.dbDataStore.saveAndInvokeFetch",
                args: ["{dbDataStore}.findById", "{arguments}.0.id", "{that}"],
                event: "{that}.events.onResponse"
            }, {
                listener: "gpii.tests.dbDataStore.verifyUpdatedRecord",
                args: ["{arguments}.0", gpii.tests.dbDataStore.testData.gpiiKeyToUpdate, "{that}"],
                event: "{that}.events.onResponse"
            }]
        }, {
            name: "Not providing gpiiKey returns error",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.updateGpiiKey", [undefined, gpii.tests.dbDataStore.testData.gpiiKeyToUpdate], "{that}"]
            }, {
                listener: "jqUnit.assertDeepEq",
                args: ["The expected error is received", {
                    message: "The input field \"gpiiKey\" was undefined",
                    statusCode: 400,
                    isError: true
                }, "{arguments}.0"],
                event: "{that}.events.onError"
            }]
        }, {
            name: "Updating an empty object returns error",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.updateGpiiKey", ["chrome_high_contrast", undefined], "{that}"]
            }, {
                listener: "jqUnit.assertDeepEq",
                args: ["The expected error is received", {
                    message: "A record of type \"gpiiKey\" was not found",
                    statusCode: 400,
                    isError: true
                }, "{arguments}.0"],
                event: "{that}.events.onError"
            }]
        }, {
            name: "Updating a document type other than gpiiKey returns an error",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.updateGpiiKey", ["prefsSafe-1", {type: "non-gpiiKey"}], "{that}"]
            }, {
                listener: "jqUnit.assertDeepEq",
                args: ["The expected error is received", {
                    message: "The document type must be \"gpiiKey\" instead of the selected document type \"non-gpiiKey\"",
                    statusCode: 400,
                    isError: true
                }, "{arguments}.0"],
                event: "{that}.events.onError"
            }]
        }]
    }]
});

fluid.defaults("gpii.tests.dbDataStore.addPrefsSafe", {
    gradeNames: ["gpii.tests.dbDataStore.environment"],
    rawModules: [{
        name: "Test addPrefsSafe()",
        tests: [{
            name: "Add a prefs safe",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.addPrefsSafe", [gpii.tests.dbDataStore.testData.prefsSafeToCreate], "{that}"]
            }, {
                listener: "gpii.tests.dbDataStore.saveAndInvokeFetch",
                args: ["{dbDataStore}.findById", "{arguments}.0.id", "{that}"],
                event: "{that}.events.onResponse"
            }, {
                listener: "gpii.tests.dbDataStore.verifyCreatedPrefsSafe",
                args: ["{arguments}.0", gpii.tests.dbDataStore.testData.prefsSafeToCreate, "{that}"],
                event: "{that}.events.onResponse"
            }]
        }, {
            name: "Adding an empty object returns error",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.addPrefsSafe", [undefined], "{that}"]
            }, {
                listener: "jqUnit.assertDeepEq",
                args: ["The expected error is received", {
                    message: "A record of type \"prefsSafe\" was not found",
                    statusCode: 400,
                    isError: true
                }, "{arguments}.0"],
                event: "{that}.events.onError"
            }]
        }]
    }]
});

fluid.defaults("gpii.tests.dbDataStore.updatePrefsSafe", {
    gradeNames: ["gpii.tests.dbDataStore.environment"],
    rawModules: [{
        name: "Test updatePrefsSafe()",
        tests: [{
            name: "Update a prefs safe",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.updatePrefsSafe", ["prefsSafe-1", gpii.tests.dbDataStore.testData.prefsSafeToUpdate], "{that}"]
            }, {
                listener: "gpii.tests.dbDataStore.saveAndInvokeFetch",
                args: ["{dbDataStore}.findById", "{arguments}.0.id", "{that}"],
                event: "{that}.events.onResponse"
            }, {
                listener: "gpii.tests.dbDataStore.verifyUpdatedRecord",
                args: ["{arguments}.0", gpii.tests.dbDataStore.testData.prefsSafeToUpdate, "{that}"],
                event: "{that}.events.onResponse"
            }]
        }, {
            name: "Not providing prefsSafeId returns error",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.updatePrefsSafe", [undefined, gpii.tests.dbDataStore.testData.prefsSafeToUpdate], "{that}"]
            }, {
                listener: "jqUnit.assertDeepEq",
                args: ["The expected error is received", {
                    message: "The input field \"prefsSafeId\" was undefined",
                    statusCode: 400,
                    isError: true
                }, "{arguments}.0"],
                event: "{that}.events.onError"
            }]
        }, {
            name: "Updating an empty object returns error",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.updatePrefsSafe", ["prefsSafe-1", undefined], "{that}"]
            }, {
                listener: "jqUnit.assertDeepEq",
                args: ["The expected error is received", {
                    message: "A record of type \"prefsSafe\" was not found",
                    statusCode: 400,
                    isError: true
                }, "{arguments}.0"],
                event: "{that}.events.onError"
            }]
        }, {
            name: "Updating a document type other that prefsSafe returns an error",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.updatePrefsSafe", ["prefsSafe-1", {type: "non-prefsSafe"}], "{that}"]
            }, {
                listener: "jqUnit.assertDeepEq",
                args: ["The expected error is received", {
                    message: "The document type must be \"prefsSafe\" instead of the selected document type \"non-prefsSafe\"",
                    statusCode: 400,
                    isError: true
                }, "{arguments}.0"],
                event: "{that}.events.onError"
            }]
        }]
    }]
});

fluid.defaults("gpii.tests.dbDataStore.addAuthorization", {
    gradeNames: ["gpii.tests.dbDataStore.environment"],
    rawModules: [{
        name: "Test addAuthorization()",
        tests: [{
            name: "Add a GPII app installation authorization",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.addAuthorization", [gpii.tests.dbDataStore.testData.gpiiAppInstallationAuthorizationToCreate], "{that}"]
            }, {
                listener: "gpii.tests.dbDataStore.saveAndInvokeFetch",
                args: ["{dbDataStore}.findById", "{arguments}.0.id", "{that}"],
                event: "{that}.events.onResponse"
            }, {
                listener: "gpii.tests.dbDataStore.verifyFetchedGpiiAppInstallationAuthorization",
                args: ["{arguments}.0", gpii.tests.dbDataStore.testData.gpiiAppInstallationAuthorizationToCreate, "{that}"],
                event: "{that}.events.onResponse"
            }]
        }, {
            name: "Adding an empty object returns error",
            sequence: [{
                func: "gpii.tests.invokePromiseProducer",
                args: ["{dbDataStore}.addAuthorization", [undefined], "{that}"]
            }, {
                listener: "jqUnit.assertDeepEq",
                args: ["The expected error is received", {
                    message: "A record of type \"gpiiAppInstallationAuthorization\" was not found",
                    statusCode: 400,
                    isError: true
                }, "{arguments}.0"],
                event: "{that}.events.onError"
            }]
        }]
    }]
});

fluid.test.runTests([
    "gpii.tests.dbDataStore.findGpiiKey",
    "gpii.tests.dbDataStore.findClientById",
    "gpii.tests.dbDataStore.findClientCredentialById",
    "gpii.tests.dbDataStore.findPrefsSafeByGpiiKey",
    "gpii.tests.dbDataStore.findClientByOauth2ClientId",
    "gpii.tests.dbDataStore.findAuthorizationByAccessToken",
    "gpii.tests.dbDataStore.findAllViews",
    "gpii.tests.dbDataStore.addGpiiKey",
    "gpii.tests.dbDataStore.updateGpiiKey",
    "gpii.tests.dbDataStore.addPrefsSafe",
    "gpii.tests.dbDataStore.updatePrefsSafe",
    "gpii.tests.dbDataStore.addAuthorization"
]);
