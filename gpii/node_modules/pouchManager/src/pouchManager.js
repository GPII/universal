/*!
GPII Pouch Manager

Copyright 2016 OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

"use strict";

var fluid = require("infusion"),
    gpii = fluid.registerNamespace("gpii");

/*
 * Pouch Manager manages the pouchDB that is used as the auth server data storage when GPII runs in the development mode. It provides:
 * 1. A pouchdb-express server that allows the GPII to integrate with PouchDB exposed over a CouchDB-like HTTP API.
 *    This express server makes use of gpii-pouchdb repo: https://github.com/gpii/gpii-pouchdb/
 * 2. An express server that provides a /reset-pouch API to restore the pouchDB in 1 above with its initial data set.
 * Note that the reset uses a separate express server specified in 2 above because it needs to re-instantiate the entire pouchDB express server in order to force it to re-init databases.
 * This re-instatiation would interrupt the request to send back the response. The reset cannot simply re-instantiate the pouch-express middleware within the pouchDB express server
 * because GPII express server has its own way to wire up children middleware so it doesn't make sense to programmatically control the creation/recreation of a middleware.
 *
 * Pouch Manager accepts these options:
 * @authDBServerPort {Integer} The port on which the pouchDB express server will run.
 * @resetServerPort {Integer} The port on which the express server for restoring the pouchDB express server with its initial data set will run.
 * @baseDir: {String} The path to the directory used for saving pouchDB data.
 * @pouchConfig {Object} Configuration options to config the pouchDB. Refer to https://github.com/GPII/gpii-pouchdb/blob/master/docs/pouch-component.md on details of accepted options.
 */
fluid.defaults("gpii.pouchManager", {
    gradeNames: ["fluid.component"],
    authDBServerPort: 8058,
    resetServerPort: 8060,
    baseDir: "@expand:{settingsDir}.getBaseSettingsDir()",
    members: {
        recreatePouchHarnessAfterDestroy: false
    },
    components: {
        settingsDir: {
            type: "gpii.settingsDir"
        },
        pouchHarness: {
            type: "gpii.pouch.harness.persistent",
            createOnEvent: "onCreatePouchHarness",
            options: {
                port: "{pouchManager}.options.authDBServerPort",
                baseDir: "{pouchManager}.options.baseDir",
                listeners: {
                    "onReady.escalate": "{pouchManager}.events.onPouchHarnessReady",
                    "afterDestroy.recreatePouchHarness": {
                        listener: "gpii.pouchManager.recreatePouchHarness",
                        args: ["{pouchManager}"]
                    }
                }
            }
        },
        expressReset: {
            type: "gpii.express",
            options: {
                port: "{pouchManager}.options.resetServerPort",
                components: {
                    resetMiddleware: {
                        type: "gpii.pouchManager.resetMiddleware"
                    }
                },
                listeners: {
                    "onStarted.escalate": "{pouchManager}.events.onExpressResetServerStarted.fire"
                }
            }
        }
    },
    events: {
        onCreatePouchHarness: null,
        onPouchHarnessReady: null,
        onPouchHarnessRecreated: null,
        onExpressResetServerStarted: null,
        onReady: {
            events: {
                onPouchHarnessReady: "onPouchHarnessReady",
                onExpressResetServerStarted: "onExpressResetServerStarted"
            }
        },
        onPouchHarnessRecreatedReady: {
            events: {
                onPouchHarnessReady: "onPouchHarnessReady",
                onPouchHarnessRecreated: "onPouchHarnessRecreated"
            }
        }
    },
    listeners: {
        "onCreate.createPouchHarness": "{that}.events.onCreatePouchHarness.fire"
    },
    distributeOptions: {
        distributePouchConfig: {
            source: "{that}.options.pouchConfig",
            target: "{that gpii.pouch.express}.options"
        },
        distributePouchExpressListeners: {
            record: {
                "onCleanupComplete.destroyPouchHarness": "{pouchHarness}.destroy"
            },
            target: "{that gpii.pouch.express}.options.listeners"
        }
    }
});

gpii.pouchManager.recreatePouchHarness = function (pouchManager) {
    if (pouchManager.recreatePouchHarnessAfterDestroy) {
        pouchManager.events.onCreatePouchHarness.fire();
        pouchManager.events.onPouchHarnessRecreated.fire();
        pouchManager.recreatePouchHarnessAfterDestroy = false;
    }
};

//*************** Reset pouch middleware and its handler ***************

fluid.defaults("gpii.pouchManager.resetMiddleware", {
    gradeNames: ["gpii.express.middleware.requestAware"],
    path: "/reset-pouch",
    namespace: "resetMiddleware",
    method: "get",
    handlerGrades: ["gpii.pouchManager.reset.handler"]
});

fluid.defaults("gpii.pouchManager.reset.handler", {
    gradeNames: ["gpii.express.handler"],
    invokers: {
        handleRequest: {
            funcName: "gpii.pouchManager.reset.handler.reset",
            args: ["{that}", "{pouchManager}"]
        }
    },
    listeners: {
        "{pouchManager}.events.onPouchHarnessRecreatedReady": {
            funcName: "{that}.sendResponse",
            args: ["{that}.options.responses.success.statusCode", "{that}.options.responses.success.message"]
        }
    },
    responses: {
        success: {
            statusCode: 200,
            message: "Success: Pouch has been restored with the initial data set."
        },
        error: {
            statusCode: 500
        }
    }
});

gpii.pouchManager.reset.handler.reset = function (that, pouchManager) {
    pouchManager.recreatePouchHarnessAfterDestroy = true;
    var cleanupPromise = pouchManager.pouchHarness.express.expressPouch.cleanup();

    // The success call back is unnecessary here, which is substituted by the onCleanupComplete listener.
    cleanupPromise.then(null, function (err) {
        that.sendResponse(that.options.responses.error.statusCode, err);
    });
};
