/*
GPII Web Processes Bridge Unit Tests

Copyright 2014-2017 Inclusive Design Research Centre, OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

/* global fluid, jqUnit, require, gpii */

"use strict";

fluid.registerNamespace("gpii.tests.processes");

// Mock 'node' process.
gpii.tests.processes.mockNode = fluid.freezeRecursive({
    command: "node",
    pid: 2345,
    ppid: 968,
    uid: 501,
    gid: 20,
    fullPath: "/usr/local/bin/node",
    argv: ["/usr/local/bin/node"],
    state: "Running"
});

// mock 'firefox' process
gpii.tests.processes.mockFirefox = fluid.freezeRecursive({
    command: "firefox",
    pid: 2563,
    ppid: 1,
    uid: 501,
    gid: -1,
    fullPath: "/Applications/Firefox8.app/Contents/MacOS/firefox",
    argv: ["/Applications/Firefox8.app/Contents/MacOS/firefox", "-foreground"],
    state: "Sleeping"
});

// Mock list of running processes.
gpii.tests.processes.mockProcessesList = [
    gpii.tests.processes.mockNode,
    gpii.tests.processes.mockFirefox,
    {
        command: "node",    // second mock node process -- different user
        pid: 666,
        ppid: 968,
        uid: 505,
        gid: 20,
        fullPath: "/usr/local/bin/node",
        argv: ["/usr/local/bin/node"],
        state: "Running"
    }, {
        command: "BBEdit",
        pid: 2725,
        ppid: 1,
        uid: 501,
        gid: 20,
        fullPath: "Applications/BBEdit.app/Contents/MacOS/BBEdit",
        argv: ["Applications/BBEdit.app/Contents/MacOS/BBEdit", "file.txt"],
        state: "Stopped"
    }
];

fluid.defaults("gpii.tests.processes.mock", {
    gradeNames: ["gpii.processes", "gpii.contexts.test"],
    members: {
        mockNode: gpii.tests.processes.mockNode,
        mockFirefox: gpii.tests.processes.mockFirefox
    },
    invokers: {
        getProcessList: {
            funcName: "gpii.tests.getProcessList",
            args: ["{arguments}.0"]
        }
    }
});

gpii.tests.getProcessList = function (identifier) {
    var togo;
    var aProcInfo = null;
    if (identifier) {
        aProcInfo = fluid.find(
            gpii.tests.processes.mockProcessesList,
            function (procInfo) {
                if (procInfo.pid === identifier) {
                    return procInfo;
                }
            }, null
        );
    }
    if (aProcInfo) {
        togo = [aProcInfo];
    } else {
        togo = gpii.tests.processes.mockProcessesList;
    }
    return togo;
};

/**
 * "Start" firefox if not alreday running.  Simulated by adding the mock firefox
 * process to the list of processes member of the given proceesesBridge, if not
 * already present in the list.
 *
 * @param {Component} processesBridge - An instance of processesBridge component.
 */
gpii.tests.processes.startFireFox = function (processesBridge) {
    var procInfo = processesBridge.findProcessByPid(processesBridge.mockFirefox.pid);
    // Start only if not running.
    if (procInfo === null) {
        processesBridge.getProcessList().push(processesBridge.mockFirefox);
    }
};

/**
 * "Stop" firefox if not alreday running.  Simulated by removing the mock
 * firefox process from the list of processes member of the given
 * proceesesBridge, if present in the list.
 *
 * @param {Component} processesBridge - An instance of processesBridge component.
 */
gpii.tests.processes.stopFireFox = function (processesBridge) {
    var procInfo = processesBridge.findProcessByPid(processesBridge.mockFirefox.pid);
    // Stop only if running.
    if (procInfo !== null) {
        var index = processesBridge.getProcessList().indexOf(procInfo);
        processesBridge.getProcessList().splice(index, 1);
    }
};

gpii.tests.processes.runTests = function () {
    var processesBridge = gpii.tests.processes.mock();
    jqUnit.module("Processes Bridge");
    jqUnit.test(
        "Test getProcessList()/findProcessByPid() with specified node process",
        function () {
            var procInfos = processesBridge.getProcessList();
            jqUnit.assertNotEquals(
                "Listing all processes", 0, procInfos.length
            );
            // Check for the presence of "node".
            var nodeProc = processesBridge.findProcessByPid(processesBridge.mockNode.pid, procInfos);
            jqUnit.assertNotNull("Searching for 'node' process", nodeProc);
        }
    );

    jqUnit.test(
        "Test findProcessByPid() with non-running process id",
        function () {
            jqUnit.assertNull(
            "Search negative process id value", processesBridge.findProcessByPid(-1)
            );
        }
    );

    jqUnit.test(
        "Test findProcessByPid() against mock node process object.",
        function () {
            var nodeProcInfo = processesBridge.findProcessByPid(processesBridge.mockNode.pid);

            jqUnit.assertEquals("Node process 'name'",
                processesBridge.mockNode.command, nodeProcInfo.command);

            jqUnit.assertEquals("Node process 'pid'",
                processesBridge.mockNode.pid, nodeProcInfo.pid);

            jqUnit.assertEquals("Node process 'uid'",
                processesBridge.mockNode.uid, nodeProcInfo.uid);

            jqUnit.assertEquals("Node process 'gid'",
                processesBridge.mockNode.gid, nodeProcInfo.gid);

            jqUnit.assertEquals("Node process 'argv' length'",
                processesBridge.mockNode.argv.length, nodeProcInfo.argv.length);

            jqUnit.assertEquals("Node process status",
                "Running", processesBridge.mockNode.state);

            jqUnit.assertEquals("Node process fullPath",
                processesBridge.mockNode.fullPath, nodeProcInfo.fullPath);

            jqUnit.assertDeepEq("Node process argv",
                processesBridge.mockNode.argv, nodeProcInfo.argv);
        }
    );

    jqUnit.test(
        "Test getProcessPath() with non-running process id",
        function () {
            jqUnit.assertNull(
            "Path of negative process id value", processesBridge.getProcessPath(-1)
            );
        }
    );

    jqUnit.test(
        "Test getProcessPath() against mock node process object.",
        function () {
            var fullPath = processesBridge.getProcessPath(processesBridge.mockNode.pid);

            jqUnit.assertEquals("Node process fullPath",
                processesBridge.mockNode.fullPath, fullPath);
        }
    );

    jqUnit.test(
        "Test findProcessesByCmd()/findFirstProcessByCmd()",
        function () {
            // Test without the processes array optional argument.
            var procInfos = processesBridge.findProcessesByCommand("node");
            jqUnit.assertNotEquals(
                "Getting all 'node' processes (no 'procArray' option)",
                0,
                procInfos.length
            );
            procInfos.forEach(function (aProcInfo) {
                jqUnit.assertEquals(
                    "Node commmand name (no 'procArray' option)",
                    "node",
                    aProcInfo.command
                );
            });
            var procInfo = processesBridge.findFirstProcessByCommand("node");
            jqUnit.assertNotNull(
                "Looking for first 'node' processes", procInfo);
            jqUnit.assertEquals("Node commmand name", "node", procInfo.command);

            // unicorns are mythical in the mock processes list.
            procInfos = processesBridge.findProcessesByCommand("unicorn");
            jqUnit.assertEquals(
                "Looking for non-existent 'unicorn' processes (no 'procArray' option)",
                0,
                procInfos.length
            );
            procInfo = processesBridge.findFirstProcessByCommand("unicorn");
            jqUnit.assertNull(
                "Looking for non-existent 'unicorn' process", procInfo);

            // Test with the optional processes array argument.
            var procArray = gpii.tests.processes.mockProcessesList;
            procInfos = processesBridge.findProcessesByCommand("node", procArray);
            jqUnit.assertNotEquals(
                "Getting all 'node' processes (using 'procArray' option)",
                0,
                procInfos.length
            );
            procInfos.forEach(function (aProcInfo) {
                jqUnit.assertEquals(
                    "Node commmand name (using 'procArray' option)",
                    "node",
                    aProcInfo.command
                );
            });

            // unicorns are mythical in the mock processes list.
            procInfos = processesBridge.findProcessesByCommand("unicorn", procArray);
            jqUnit.assertEquals(
                "Looking for non-existent 'unicorn' processes (using 'procArray' option)",
                0,
                procInfos.length
            );
        }
    );

    jqUnit.test(
        "Test initProcInfoNotRunning()",
        function () {
            var notRunning = processesBridge.initProcInfoNotRunning("grep");
            jqUnit.assertEquals("Command name", notRunning.command, "grep");
            jqUnit.assertEquals("Negative process id", notRunning.pid, -1);
            jqUnit.assertEquals(
                "'NoSuchProcess' state", notRunning.state, "NoSuchProcess"
            );
            jqUnit.assertNull(
                "Search negative process id value",
                processesBridge.findProcessByPid(notRunning.pid)
            );
        }
    );

    jqUnit.test(
        "Test isRunning() with mock node process, and nonexistent process",
        function () {
            var procInfo = processesBridge.findProcessByPid(processesBridge.mockNode.pid);
            jqUnit.assertNotNull("Searching for 'node' process", procInfo);
            jqUnit.assertTrue(
                "Check node is running",
                processesBridge.isRunning(procInfo.state)
            );
            procInfo = processesBridge.initProcInfoNotRunning("grep");
            jqUnit.assertFalse(
                "Check nonexistent process running",
                processesBridge.isRunning(procInfo.state)
            );
        }
    );

    jqUnit.test(
        "Test updateProcInfo() against non-changing process",
        function () {
            var procInfo = processesBridge.findProcessByPid(processesBridge.mockNode.pid);
            jqUnit.assertNotNull("Looking for 'node' processes", procInfo);
            var newProcInfo = processesBridge.updateProcInfo(procInfo);
            jqUnit.assertDeepEq(
                "Check change in process info", procInfo, newProcInfo
            );
        }
    );

    jqUnit.test(
        "Test updateProcInfo() against changing process",
        function () {
            // "Start" firefox by adding to the process list.
            gpii.tests.processes.startFireFox(processesBridge);
            var fireFoxInfo = processesBridge.findProcessByPid(processesBridge.mockFirefox.pid);
            jqUnit.assertNotNull("Search 'firefox' process", fireFoxInfo);

            // "Kill" firefox by removing it from the process list.
            gpii.tests.processes.stopFireFox(processesBridge);
            var newFireFoxInfo = processesBridge.updateProcInfo(fireFoxInfo);
            jqUnit.assertNotEquals(
                "Update process state", newFireFoxInfo.state, fireFoxInfo.state
            );
        }
    );

    jqUnit.test(
        "Test updateProcInfo() against non-existent process",
        function () {
            var procInfo = processesBridge.initProcInfoNotRunning("unicorn");
            var updatedProcInfo = processesBridge.updateProcInfo(procInfo);
            jqUnit.assertDeepEq(
                "Updated non-existent process (still non-existent)",
                procInfo, updatedProcInfo
            );
        }
    );

    jqUnit.test(
        "Test findSolutionsByCommands()",
        function () {
            // Node is running. Add a running firefox. No such command as T6y7u8i9.
            gpii.tests.processes.startFireFox(processesBridge);
            var solutions = ["node", "firefox", "T6y7u8i9"];
            var procInfos = processesBridge.findSolutionsByCommands(solutions);
            jqUnit.assertTrue("Node and Firefox processes", procInfos.length >= 2);
            procInfos.forEach(function (item) {
                var isNode = item.command === "node";
                var isFirefox = item.command === "firefox";
                jqUnit.assertTrue("Process name 'node' or 'firefox'", isNode || isFirefox);
            });
        }
    );

    jqUnit.test(
        "Test findSolutionsByPids()",
        function () {
            // Node is running. Add a running Firefox process.  Use -1 as the
            // pid for a non-existent process.
            gpii.tests.processes.startFireFox(processesBridge);
            var pids = [processesBridge.mockNode.pid, processesBridge.mockFirefox.pid, -1];
            var procInfos = processesBridge.findSolutionsByPids(pids);
            jqUnit.assertEquals("Node and Firefox processes", 2, procInfos.length);
            procInfos.forEach(function (item) {
                var isNode = item.pid === processesBridge.mockNode.pid;
                var isFirefox = item.pid === processesBridge.mockFirefox.pid;
                jqUnit.assertTrue("Process pid 'node' or 'firefox'", isNode || isFirefox);
            });
        }
    );

    // TODO: consider making base grade getProcessList() fluid.notImplemented.
    jqUnit.test(
        "Test base grade getProcessList()",
        function () {
            var empty = gpii.processes.getProcessList();
            jqUnit.assertEquals("Base grade getProcessList() empty", 0, empty.length);
        }
    );
};
