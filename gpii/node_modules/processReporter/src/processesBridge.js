/*!
GPII Process Reporter processes bridge -- gpii.processes.

Copyright 2014 Inclusive Design Research Centre, OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

/*global require */

"use strict";

var fluid = require("infusion");
var gpii = fluid.registerNamespace("gpii");

gpii.processes = fluid.registerNamespace("gpii.processes");

fluid.defaults("gpii.processes", {
    gradeNames: ["gpii.processes.native", "fluid.component"],
    events: {
        onRunStateChange: null,
        onStateChange: null
    },
    invokers: {
        findSolutionsByCommands: {
            funcName: "gpii.processes.findSolutionsByCommands",
            args: ["{arguments}.0"]   // array of command names
        },
        findSolutionsByPids: {
            funcName: "gpii.processes.findSolutionsByPids",
            args: ["{arguments}.0"]   // array of pids (process ids)
        },
        findProcessByPid: {
            funcName: "gpii.processes.findProcessByPid",
            args: ["{arguments}.0", "{arguments}.1"] // pid, procArray (optional)
        },
        findProcessesByCommand: {
            funcName: "gpii.processes.findProcessesByCommand",
            args: ["{arguments}.0", "{arguments}.1"]
            // command, procArray (optional)
        },
        findFirstProcessByCommand: {
            funcName: "gpii.processes.findFirstProcessByCommand",
            args: ["{arguments}.0", "{arguments}.1"]
            // command, procArray (optional)
        },
        hasStateChanged: {
            funcName: "gpii.processes.hasStateChanged",
            args: ["{arguments}.0"]   // process info structure
        },
        isRunning: {
            funcName: "gpii.processes.isRunning",
            args: ["{arguments}.0"]   // state (string)
        },
        hasSwitchRunState: {
            funcName: "gpii.processes.hasSwitchedRunState",
            args: ["{arguments}.0"]   // monitor info structure
        },
        updateProcInfo: {
            funcName: "gpii.processes.updateProcInfo",
            args: ["{arguments}.0"]   // process info structure
        },
        initProcInfoNotRunning: {
            funcName: "gpii.processes.initProcInfoNotRunning",
            args: ["{arguments}.0"]   // command name (string)
        },
        initMonitor: {
            funcName: "gpii.processes.initMonitor",
            args: ["{arguments}.0"]   // process info structure
        },
        monitorStateChange: {
            funcName: "gpii.processes.monitorStateChange",
            args: ["{that}", "{arguments}.0"] // monitor info structure
        },
        monitorRunStateChanged: {
            funcName: "gpii.processes.monitorRunStateChanged",
            args: ["{that}", "{arguments}.0"] // monitor info structure
        },
        trackRunState: {
            funcName: "gpii.processes.trackRunState",
            args: ["{that}", "{arguments}.0", "{arguments}.1"]
            // process info, handler
        },
        stopTrackingRunState: {
            funcName: "gpii.processes.stopTrackingRunState",
            args: ["{that}", "{arguments}.0", "{arguments}.1"]
            // handler, intervalID
        },
        // Tracking *any* state change.
        trackState: {
            funcName: "gpii.processes.trackState",
            args: ["{that}", "{arguments}.0", "{arguments}.1"]
            // process info, handler
        },
        stopTrackingState: {
            funcName: "gpii.processes.stopTrackingState",
            args: ["{that}", "{arguments}.0", "{arguments}.1"]
            // handler, intervalID
        }
    }
});

// Return an list of process information structures corresponding to the
// names of each of the passed in commands.
gpii.processes.findSolutionsByCommands = function (commandNames) {
    if (!!commandNames) {
        return fluid.accumulate(commandNames, function (aCommand, matches) {
            var procInfos = gpii.processes.findProcessesByCommand(aCommand);
            matches = matches.concat(procInfos);
            return matches;
        }, []);
    }
    else {
        return [];
    }
};

// Return an list of process information structures corresponding to the
// pids pass in.
gpii.processes.findSolutionsByPids = function (pids) {
    if (!!pids) {
        return fluid.accumulate(pids, function (aPid, matches) {
            var found = gpii.processes.findProcessByPid(aPid);
            if (found !== null) {
                matches.push(found);
            }
            return matches;
        }, []);
    }
    else {
        return [];
    }
};

// Return THE process info object that matches the given process id.
// Note that it can return "null" meaning there is no such process.
gpii.processes.findProcessByPid = function (pid, procArray) {
    if (!procArray) {
        procArray = gpii.processes["native"].getProcessList();
    }
    return fluid.find(procArray, function (procInfo) {
        if (procInfo.pid === pid) {
            return procInfo;
        }
    }, null);
};

// Return an array of process information objects that match the given
// command name string.  Note that it can return an empty array, meaning
// there is no such process.
gpii.processes.findProcessesByCommand = function (commandName, procArray) {
    if (!procArray) {
        procArray = gpii.processes["native"].getProcessList();
    }
    return fluid.accumulate(procArray, function (aProcInfo, matchingProcs) {
        if (aProcInfo.command === commandName) {
            matchingProcs.push(aProcInfo);
        }
        return matchingProcs;
    }, []);
};

// Return the first process of an array of processes all with the same
// command name string.  If there are no matching processes, return null.
gpii.processes.findFirstProcessByCommand =
function (commandName, procArray) {
    var commands =
        gpii.processes.findProcessesByCommand(commandName, procArray);
    if (commands.length > 0) {
        return commands[0];
    }
    else {
        return null;
    }
};

// Determine if the state of the given process has changed.  Record the
// new process information in the monitor.  Return boolean.
gpii.processes.hasStateChanged = function (monitor) {
    if (!monitor || !monitor.procInfo) {
        return false;    // nothing sought === nothing changed.
    }
    monitor.newProcInfo =
    gpii.processes.updateProcInfo(monitor.procInfo);
    return (monitor.procInfo.state !== monitor.newProcInfo.state);
};

// Utility function to conflate process state values into "Running"
// (= true) vs. "Not Running" (= false).  Returns boolean.
gpii.processes.isRunning = function (state) {
    var result;
    switch (state) {
    case "Running":
    case "Uninterruptible":
    case "Sleeping":
    case "Stopped":
        result = true;
        break;

    default:
    case "Zombie":
    case "NoSuchProcess":
        result = false;
        break;
    }
    return result;
};

// Determine if the state of the given process has changed from
// "not running" to "running" OR from "running" to "not running".
// Return boolean.
gpii.processes.hasSwitchedRunState = function (monitor) {
    if (!monitor || !monitor.procInfo) {
        // nothing sought === nothing changed.
        return false;
    }
    monitor.newProcInfo =
        gpii.processes.updateProcInfo(monitor.procInfo);
    var wasRunning = gpii.processes.isRunning(monitor.procInfo.state);
    var isRunning =
        gpii.processes.isRunning(monitor.newProcInfo.state);
    return (isRunning !== wasRunning);
};

// Renew the information on a process, or create a new "NoSuchProcces".
// Returns a new procInfo structure.
gpii.processes.updateProcInfo = function (procInfo) {
    var newProcInfo = null;
    if (procInfo.state === "NoSuchProcess") {
        newProcInfo =
            gpii.processes.findFirstProcessByCommand(procInfo.command);
    }
    else {
        newProcInfo = gpii.processes.findProcessByPid(procInfo.pid);
    }
    if (newProcInfo === null) {
        newProcInfo =
            gpii.processes.initProcInfoNotRunning(procInfo.command);
    }
    return newProcInfo;
};

// Create information on a non-running process, to use to detect when the
// process starts.
gpii.processes.initProcInfoNotRunning = function (command) {
    var process = {};
    process.command = command;
    process.pid = -1;
    process.ppid = -1;
    process.uid = -1;
    process.gid = -1;
    process.fullPath = "";
    process.argv = "";
    process.state = "NoSuchProcess";
    return process;
};

// Create a monitor object for passing to a function that periodically
// checks for chanages in the state of a process.
gpii.processes.initMonitor = function (procInfo) {
    var monitor = {};
    monitor.intervalID = -1;
    monitor.procInfo = procInfo;
    monitor.newProcInfo = null;
    return monitor;
};

// Callback to pass to, e.g., setInterval() to periodically check the state
// of a process.
gpii.processes.monitorStateChange = function (that, monitor) {
    if (gpii.processes.hasStateChanged(monitor)) {
        var oldProcInfo = monitor.procInfo;
        if (monitor.newProcInfo === null) {
            monitor.procInfo = gpii.processes.initProcInfoNotRunning(monitor.procInfo.command);
        }
        else {
            monitor.procInfo = monitor.newProcInfo;
        }
        that.events.onStateChange.fire(oldProcInfo, monitor.newProcInfo);
    }
};

// Callback to pass to setInterval() to periodically check when the state
// changes from "running" to "not running" and vice versa.
gpii.processes.monitorRunStateChanged = function (that, monitor) {
    if (gpii.processes.hasSwitchedRunState(monitor)) {
        if (monitor.newProcInfo === null) {
            monitor.procInfo = gpii.processes.initProcInfoNotRunning(monitor.procInfo.command);
        }
        else {
            monitor.procInfo = monitor.newProcInfo;
        }
        that.events.onRunStateChange.fire(monitor.procInfo);
    }
};

// ==============
// Event handling
// ==============

// Provide a way for the outside world to pass in a handler for the
// "onRunStateChange" event, and to cancel.
gpii.processes.trackRunState = function (that, procInfo, handler) {
    var monitor = gpii.processes.initMonitor(procInfo);
    that.events.onRunStateChange.addListener(handler);
    monitor.intervalID = setInterval(function () {
        gpii.processes.monitorRunStateChanged(that, monitor);
    });
    return monitor.intervalID;
};

gpii.processes.stopTrackingRunState = function (that, handler, intervalID) {
    that.events.onRunStateChange.removeListener(handler);
    clearInterval(intervalID);
};

// Provide a way for the outside world to pass in a handler for the
// "onStateChange" event, and to cancel.
gpii.processes.trackState = function (that, procInfo, handler) {
    var monitor = gpii.processes.initMonitor(procInfo);
    that.events.onStateChange.addListener(handler);
    monitor.intervalID = setInterval(function () {
        gpii.processes.monitorStateChange(that, monitor);
    });
    return monitor.intervalID;
};

gpii.processes.stopTrackingState = function (that, handler, intervalID) {
    that.events.onStateChange.removeListener(handler);
    clearInterval(intervalID);
};
