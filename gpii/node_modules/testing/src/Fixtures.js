/*

    Common test fixtures (sequence elements, sequence grades, case holders, and test environments).

    Copyright 2019 Raising the Floor International

    Licensed under the New BSD license. You may not use this file except in
    compliance with this License.

    You may obtain a copy of the License at
    https://github.com/gpii/universal/LICENSE.txt

*/
"use strict";
var fluid = require("infusion");
var gpii = fluid.registerNamespace("gpii");

require("gpii-couchdb-test-harness");
gpii.test.couchdb.loadTestingSupport();

fluid.defaults("gpii.test.startServerSequence", {
    gradeNames: "fluid.test.sequenceElement",
    sequence: [
        { // This sequence point is required because of a QUnit bug - it defers the start of sequence by 13ms "to avoid any current callbacks" in its words
            func: "{testEnvironment}.events.constructServer.fire"
        },
        {
            event: "{testEnvironment}.events.onServerReady",
            listener: "fluid.identity"
        }
    ]
});

fluid.defaults("gpii.test.stopServerSequence", {
    gradeNames: "fluid.test.sequenceElement",
    sequence: [
        {
            func: "{testCaseHolder}.configuration.server.stop"
        },
        {
            event: "{testCaseHolder}.configuration.server.events.onStopped",
            listener: "fluid.identity"
        }
    ]
});

fluid.defaults("gpii.test.standardServerSequenceGrade", {
    gradeNames: ["fluid.test.sequence"],
    sequenceElements: {
        startServer: {
            gradeNames: "gpii.test.startServerSequence",
            priority: "before:sequence"
        },
        stopServer: {
            gradeNames: "gpii.test.stopServerSequence",
            priority: "after:sequence"
        }
    }
});

fluid.defaults("gpii.test.testCaseHolder", {
    gradeNames: ["fluid.test.testCaseHolder"],
    secret: "GPII tests secret",
    members: {
        // The "orig" member of this area will be written by gpii.test.snapshotSettings, and read back by gpii.test.checkRestoredConfiguration
        settingsStore: {}
    },
    mergePolicy: {
        "settingsHandlers": "noexpand",
        "initialState": "noexpand"
    },
    events: {
        onSnapshotComplete: null,
        onInitialStateSet: null,
        onInitialStateConfirmed: null,
        onCheckConfigurationComplete: null,
        onCheckRestoredConfigurationComplete: null,
        onCheckRestoredInitialStateComplete: null
    },
    distributeOptions: {
        "testCaseHolder.variableResolver": {
            record: {
                funcName: "gpii.test.common.receiveVariableResolver",
                args: ["{testCaseHolder}", "{arguments}.0"]
            },
            target: "{that lifecycleManager variableResolver}.options.listeners.onCreate"
        },
        "testCaseHolder.port": {
            record: "{configuration}.options.mainServerPort",
            target: "{that kettle.test.request}.options.port"
        },
        "cookieJar.secret": {
            source: "{that}.options.secret",
            target: "{that > cookieJar}.options.secret"
        },
        "server.secret": {
            source: "{that}.options.secret",
            target: "{that server}.options.secret"
        }
    },
    components: {
        configuration: {
            type: "gpii.test.configuration"
        },
        cookieJar: {
            type: "kettle.test.cookieJar"
        },
        // The following configuration should be valid:
        // variableResolver: "{tests}.configuration.server.flowManager.lifecycleManager.variableResolver" but clearly stresses
        // ginger resolution in the framework too much.
        // In fact, a proper solution would allow us to directly write:
        // variableResolver: "{that lifecycleManager variableResolver}" without the listener hack above - this requires FLUID-5556
        loginRequest: {
            type: "gpii.test.common.loginRequestComponent"
        },
        logoutRequest: {
            type: "gpii.test.common.logoutRequestComponent"
        }
    }
});

fluid.defaults("gpii.test.serverEnvironment", {
    gradeNames: ["fluid.test.testEnvironment"],
    events: {
        onServerReady: null,
        constructServer: null
    },
    components: {
        tests: {
            type: "gpii.test.testCaseHolder"
        }
    }
});

// TODO: If we don't end up needing to modify this, consider collapsing it and simply using kettle.test.configuration directly.
fluid.defaults("gpii.test.configuration", {
    gradeNames: ["fluid.component", "{testEnvironment}.options.configurationName"],
    components: {
        server: {
            createOnEvent: "{testEnvironment}.events.constructServer",
            options: {
                gradeNames: "kettle.test.server",
                listeners: {
                    onListen: "{testEnvironment}.events.onServerReady"
                }
            }
        }
    }
});

fluid.defaults("gpii.test.startCouchSequence", {
    gradeNames: ["fluid.test.sequenceElement"],
    sequence: [{
        task:        "{harness}.startup",
        resolve:     "fluid.log",
        resolveArgs: ["Harness startup successful."]
    }]
});

fluid.defaults("gpii.test.stopCouchSequence", {
    gradeNames: ["fluid.test.sequenceElement"],
    sequence: [{
        task:        "{harness}.shutdown",
        resolve:     "fluid.log",
        resolveArgs: ["Harness shutdown successful."]
    }]
});

fluid.defaults("gpii.test.couchSequenceGrade", {
    gradeNames: ["gpii.test.standardServerSequenceGrade"],
    sequenceElements: {
        startCouch: {
            gradeNames: "gpii.test.startCouchSequence",
            priority: "after:startServer"
        },
        stopCouch: {
            gradeNames: "gpii.test.stopCouchSequence",
            priority: "before:stopServer"
        }
    }
});

fluid.defaults("gpii.test.couchEnvironment", {
    gradeNames: ["gpii.test.couchdb.environment.base", "gpii.test.serverEnvironment"],
    databases: {
        gpii: {
            data: [
                "%gpii-universal/tests/data/dbData/clientCredentials.json",
                "%gpii-universal/tests/data/dbData/gpiiAppInstallationClients.json",
                "%gpii-universal/tests/data/dbData/gpiiKeys.json",
                "%gpii-universal/build/tests/dbData/gpiiKeys.json",
                "%gpii-universal/build/tests/dbData/prefsSafes.json",
                "%gpii-universal/build/dbData/user/gpiiKeys.json",
                "%gpii-universal/build/dbData/user/prefsSafes.json",
                "%gpii-universal/testData/dbData/views.json"
            ]
        }
    }
});

fluid.defaults("gpii.test.initialStateSequence", {
    gradeNames: ["fluid.test.sequenceElement"],
    sequence: [
        { func: "fluid.log", args: ["Executing initial state sequence."]},
        {
            func: "gpii.test.expandSettings",
            args: [ "{tests}", "initialState" ]
        },
        {
            func: "gpii.test.setInitialSettingsState",
            args: [ "{tests}.initialState", "{nameResolver}", "{testCaseHolder}.events.onInitialStateSet.fire"]
        },
        {
            event: "{testCaseHolder}.events.onInitialStateSet",
            listener: "fluid.identity"
        },
        {
            func: "gpii.test.checkConfiguration",
            args: ["{tests}.initialState", "{nameResolver}", "{testCaseHolder}.events.onInitialStateConfirmed.fire", "Confirming initial state"]
        },
        {
            event: "{testCaseHolder}.events.onInitialStateConfirmed",
            listener: "fluid.identity"
        }
    ]
});

fluid.defaults("gpii.test.snapshotSequence", {
    gradeNames: ["fluid.test.sequenceElement"],
    sequence: [
        { func: "fluid.log", args: ["Executing snapshot sequence."]},
        {
            func: "gpii.test.expandSettings",
            args: [ "{tests}", "settingsHandlers" ]
        },
        {
            func: "gpii.test.snapshotSettings",
            args: ["{tests}.settingsHandlers", "{tests}.settingsStore", "{nameResolver}", "{testCaseHolder}.events.onSnapshotComplete.fire"]
        },
        {
            event: "{testCaseHolder}.events.onSnapshotComplete",
            listener: "fluid.identity"
        }
    ]
});

fluid.defaults("gpii.test.loginSequence", {
    gradeNames: ["fluid.test.sequenceElement"],
    sequence: [
        { func: "fluid.log", args: ["Executing login sequence."]},
        {
            func: "{loginRequest}.send"
        },
        {
            event: "{loginRequest}.events.onComplete",
            listener: "gpii.test.loginRequestListen"
        },
        {
            func: "gpii.test.checkConfiguration",
            args: ["{tests}.settingsHandlers", "{nameResolver}", "{testCaseHolder}.events.onCheckConfigurationComplete.fire"]
        },
        {
            event: "{testCaseHolder}.events.onCheckConfigurationComplete",
            listener: "fluid.identity"
        }
    ]
});

fluid.defaults("gpii.test.logoutSequence", {
    gradeNames: ["fluid.test.sequenceElement"],
    sequence: [
        { func: "fluid.log", args: ["Executing logout sequence."]},
        {
            func: "{logoutRequest}.send"
        },
        {
            event: "{logoutRequest}.events.onComplete",
            listener: "gpii.test.logoutRequestListen"
        }
    ]
});

fluid.defaults("gpii.test.checkSequence", {
    gradeNames: ["fluid.test.sequenceElement"],
    sequence: [
        { func: "fluid.log", args: ["Executing check sequence."]},
        {
            func: "gpii.test.checkRestoredConfiguration",
            args: ["{tests}.settingsHandlers", "{tests}.settingsStore", "{nameResolver}", "{testCaseHolder}.events.onCheckRestoredConfigurationComplete.fire"]
        },
        {
            event: "{testCaseHolder}.events.onCheckRestoredConfigurationComplete",
            listener: "fluid.identity"
        },
        { // anything in the initial state should also be restored upon logout
            func: "gpii.test.checkRestoredInitialState",
            args: [ "{tests}.initialState", "{nameResolver}", "{testCaseHolder}.events.onCheckRestoredInitialStateComplete.fire"]
        },
        {
            event: "{testCaseHolder}.events.onCheckRestoredInitialStateComplete",
            listener: "fluid.identity"
        }
    ]
});

/*

    A sequence grade that executes a test login once the server and database are available, and that logs out once the
    tests are complete.

 */
fluid.defaults("gpii.test.snapshotSequenceGrade", {
    gradeNames: ["gpii.test.couchSequenceGrade"],
    sequenceElements: {
        snapshot: {
            gradeNames: "gpii.test.snapshotSequence",
            priority: "after:startServer"
        },
        login: {
            gradeNames: "gpii.test.loginSequence",
            priority: "after:snapshot"
        },
        logout: {
            gradeNames: "gpii.test.logoutSequence",
            priority: "before:stopServer"
        },
        check: {
            gradeNames: "gpii.test.checkSequence",
            priority: "after:logout"
        }
    }
});

/*

    A sequence grade that logs in, as above, but also checks the initial state before running the tests.

 */
fluid.defaults("gpii.test.initialStateSequenceGrade", {
    gradeNames: ["gpii.test.snapshotSequenceGrade"],
    sequenceElements: {
        initialStateSequence: {
            gradeNames: "gpii.test.initialStateSequence",
            priority: "before:snapshot"
        }
    }
});
