/**
 * GPII Testing (full lifecycle of FlowManager)
 *
 * Copyright 2013 Raising the Floor International
 * Copyright 2013 OCAD University
 * Copyright 2014 Lucendo Development Ltd.
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * You may obtain a copy of the License at
 * https://github.com/gpii/universal/LICENSE.txt
 *
 */

"use strict";

var fluid = require("infusion"),
    jqUnit = fluid.require("jqUnit"),
    path = require("path"),
    kettle = fluid.registerNamespace("kettle"),
    gpii = fluid.registerNamespace("gpii");


fluid.defaults("gpii.test.common.exec", {
    gradeNames: ["autoInit", "fluid.eventedComponent"],
    events: {
        onExecExit: null
    },
    invokers: {
//        exec:
    }
});

/*
* Sets the settings given in the json paramater. The content of the json passed
* is the values to set in a format similar to the content of "initialState"
*/
gpii.test.getSettings = function (payload, nameResolver) {
    var ret = {};
    fluid.each(payload, function (handlerBlock, handlerID) {
        var resolvedName = nameResolver ? nameResolver.resolveName(handlerID, "settingsHandler") : handlerID;
        ret[handlerID] = fluid.invokeGlobalFunction(resolvedName + ".get", [handlerBlock]);
    });
    return ret;
};

gpii.test.removeOptionsBlocks = function (payload) {
    var togo = fluid.copy(payload);
    return fluid.transform(togo, function (settingHandler) {
        return fluid.transform(settingHandler, function (solutionBlocks) {
            return fluid.transform(solutionBlocks, function (solutionBlock) {
                return {settings: solutionBlock.settings};
            });
        });
    });
};

gpii.test.snapshotSettings = function (settingsHandlers, settingsStore, nameResolver) {
    settingsStore.orig = gpii.test.getSettings(settingsHandlers, nameResolver);
};

gpii.test.loginRequestListen = function (data) {
    jqUnit.assertNotEquals("Successful login message returned " + data, -1,
        data.indexOf("was successfully logged in."));
};

gpii.test.checkConfiguration = function (settingsHandlers, nameResolver) {
    var config = gpii.test.getSettings(settingsHandlers, nameResolver);
    var noOptions = gpii.test.removeOptionsBlocks(settingsHandlers);
    jqUnit.assertDeepEq("Checking that settings are set", noOptions, config);
};

gpii.test.onExecExit = function (result, processSpec) {
    jqUnit.assertTrue("Checking the process with command: " + processSpec, result);
};

gpii.test.logoutRequestListen = function (data) {
    jqUnit.assertNotEquals("Successful logout message returned " + data, -1,
        data.indexOf("was successfully logged out."));
};

gpii.test.checkRestoredConfiguration = function (settingsHandlers, settingsStore, nameResolver) {
    var currentSettings = gpii.test.getSettings(settingsHandlers, nameResolver);
    jqUnit.assertDeepEq("Checking that settings are properly reset",
        settingsStore.orig, currentSettings);
};

fluid.defaults("gpii.test.common.testCaseHolder", {
    gradeNames: ["kettle.test.testCaseHolder", "autoInit"],
    members: {
        settingsStore: {}
    },
    components: {
        logoutRequest: {
            type: "kettle.test.request.http",
            options: {
                requestOptions: {
                    path: "/user/%token/logout",
                    port: 8081
                },
                termMap: {
                    token: "{tests}.options.token"
                }
            }
        },
        loginRequest: {
            type: "kettle.test.request.http",
            options: {
                requestOptions: {
                    path: "/user/%token/login",
                    port: 8081
                },
                termMap: {
                    token: "{tests}.options.token"
                }
            }
        }
    }
});

gpii.test.buildSingleTestFixture = function (testDef, rootGrades) {
    var processes = testDef.processes || [];
    testDef.gradeNames = fluid.makeArray(testDef.gradeNames).concat(fluid.makeArray(rootGrades));

    testDef.expect = 4 + processes.length * 2;
    testDef.sequence = fluid.makeArray(testDef.sequence);

    testDef.sequence.unshift({
        func: "gpii.test.snapshotSettings",
        args: ["{tests}.options.settingsHandlers", "{tests}.settingsStore", "{nameResolver}"]
    }, {
        func: "{loginRequest}.send"
    }, {
        event: "{loginRequest}.events.onComplete",
        listener: "gpii.test.loginRequestListen"
    }, {
        func: "gpii.test.checkConfiguration",
        args: ["{tests}.options.settingsHandlers", "{nameResolver}"]
    });

    // For each process, run the command, then check that we get the expected output
    fluid.each(processes, function (process, pindex) {
        testDef.sequence.push({
            func: "{exec}.exec",
            args: [
                fluid.model.composeSegments("{tests}.options.processes", pindex),
                fluid.model.composeSegments("{tests}.options.processes", pindex, "expectConfigured")
            ]
        }, {
            event: "{exec}.events.onExecExit",
            listener: "gpii.test.onExecExit"
        });
    });

    testDef.sequence.push({
        func: "{logoutRequest}.send"
    }, {
        event: "{logoutRequest}.events.onComplete",
        listener: "gpii.test.logoutRequestListen"
    });

    // Check that the processes are in the expected state after logout
    fluid.each(processes, function (process, pindex) {
        testDef.sequence.push({
            func: "{exec}.exec",
            args: [
                fluid.model.composeSegments("{tests}.options.processes", pindex),
                fluid.model.composeSegments("{tests}.options.processes", pindex, "expectRestored")
            ]
        }, {
            event: "{exec}.events.onExecExit",
            listener: "gpii.test.onExecExit"
        });
    });

    testDef.sequence.push({
        func: "gpii.test.checkRestoredConfiguration",
        args: ["{tests}.options.settingsHandlers", "{tests}.settingsStore", "{nameResolver}"]
    });

    return testDef;
};


// Convert a record as returned by a "portable test" into a full testDefs structure as accepted by gpii.test.buildTests
gpii.test.recordToTestDefs = function (record, baseDir) {
    var testDefs = fluid.copy(fluid.getGlobalValue(record.testDefs));
    fluid.each(testDefs, function (testDef) {
        testDef.config = {
            configName: record.configName,
            configPath: path.resolve(baseDir, record.configPath)
        };
    });
    return testDefs;
};

gpii.test.runTests = function (record, baseDirName, rootGrades) {
    var testDefs = gpii.test.recordToTestDefs(record, baseDirName);
    var testDefs2 = gpii.test.buildTests(testDefs, rootGrades);
    return kettle.test.bootstrapServer(testDefs2);
};

gpii.test.bootstrap = function (record, foreignModule, foreignRequire, foreignDirName) {
    if (foreignRequire.main === foreignModule) { // the file was executed directly from the command line - run integration tests immediately
        return gpii.test.runTests(record, foreignDirName, ["gpii.test.integration.testCaseHolder"]);
    } else { // otherwise just return its record for processing
        return record;
    }
};

gpii.test.buildTests = function (testDefs, rootGrades) {
    return fluid.transform(fluid.copy(testDefs), function (testDef) {
        return gpii.test.buildSingleTestFixture(testDef, rootGrades);
    });
};
