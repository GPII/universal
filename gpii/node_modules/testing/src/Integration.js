/**
 * GPII Integration Testing
 *
 * Copyright 2013 Raising the Floor International
 * Copyright 2013 OCAD University
 * Copyright 2014 Lucendo Development Ltd.
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * You may obtain a copy of the License at
 * https://github.com/gpii/universal/LICENSE.txt
 *
 */

"use strict";

var fluid = fluid || require("infusion"),
    gpii = fluid.registerNamespace("gpii");

// Maintains a mock model of currently executing processes
fluid.defaults("gpii.test.integration.exec", {
    gradeNames: ["gpii.test.common.exec", "autoInit"],
    members: {
        processModel: [] // list of process objects
    },
    invokers: {
        exec: {
            funcName: "gpii.test.integration.exec.exec",
            args: ["{that}", "{arguments}.0", "{arguments}.1"]
        }
    }
});

gpii.test.integration.exec.exec = function (that, processSpec /*, expected */) {
    // TODO: actually determine that the required process was started using the mock model
    that.events.onExecExit.fire(true, processSpec);
};
    
fluid.defaults("gpii.test.integration.testCaseHolder", {
    gradeNames: ["gpii.test.common.testCaseHolder", "autoInit"],
    distributeOptions: [{
        record: {
            funcName: null,
            func: "{gpii.test.integration.testCaseHolder}.nameResolver.resolveName"
        },
        target: "{that lifecycleManager > nameResolver}.options.invokers.resolveName"
    }, {
        record: {
            funcName: null,
            func: "{gpii.test.integration.testCaseHolder}.mockPlatformReporter.reportPlatform"
        },
        target: "{that deviceReporter platformReporter}.options.invokers.reportPlatform"
    }],
    components: {
        exec: {
            type: "gpii.test.integration.exec"
        },
        mockSettingsHandlers: {
            type: "gpii.test.integration.mockSettingsHandlerRegistry.universal"
        },
        nameResolver: {
            type: "fluid.littleComponent",
            options: {
                invokers: {
                    resolveName: {
                        funcName: "gpii.test.integration.resolveName",
                        args: ["{mockSettingsHandlers}", "{arguments}.0", "{arguments}.1"]
                    }
                }
            }
        }
    }
});

fluid.defaults("gpii.test.integration.testCaseHolder.windows", {
    gradeNames: ["gpii.test.integration.testCaseHolder", "autoInit"],
    components: {
        mockSettingsHandlers: {
            type: "gpii.test.integration.mockSettingsHandlerRegistry.windows"
        },
        mockPlatformReporter: {
            type: "gpii.test.integration.mockPlatformReporter",
            options: {
                platform: {
                    id: "win32",
                    version: "6.1.7601"
                }
            }
        }
    }
});


fluid.defaults("gpii.test.integration.testCaseHolder.linux", {
    gradeNames: ["gpii.test.integration.testCaseHolder", "autoInit"],
    components: {
        mockSettingsHandlers: {
            type: "gpii.test.integration.mockSettingsHandlerRegistry.linux"
        },
        mockPlatformReporter: {
            type: "gpii.test.integration.mockPlatformReporter",
            options: {
                platform: {
                    id: "linux",
                    version: "2.6.26"
                }
            }
        }
    }
});

fluid.defaults("gpii.test.integration.testCaseHolder.android", {
    gradeNames: ["gpii.test.integration.testCaseHolder", "autoInit"],
    components: {
        mockSettingsHandlers: {
            type: "gpii.test.integration.mockSettingsHandlerRegistry.android"
        },
        mockPlatformReporter: {
            type: "gpii.test.integration.mockPlatformReporter",
            options: {
                platform: {
                    id: "android",
                    version: "3.0.31"
                }
            }
        }
    }
});

fluid.defaults("gpii.test.integration.mockPlatformReporter", {
    gradeNames: ["fluid.littleComponent", "autoInit"],
    invokers: {
        reportPlatform: {
            funcName: "fluid.identity",
            args: "{that}.options.platform"
        }
    }
});


gpii.test.integration.mockExecHandler = function (command, args) {
    // TODO: we should record the executing process in a process model - ideally we should have a more reliable model of extracting what it is
    fluid.log("Mock exec handler for command ", command, " args ", args);
};

fluid.defaults("gpii.test.integration.mockExecHandler", {
    gradeNames: "fluid.function",
    argumentMap: {
        command: 0,
        args: 1
    }
});

gpii.test.integration.resolveName = function (settingsHandlerRegistry, name, category) {
    if (category === "settingsHandler") {
        return settingsHandlerRegistry.resolveName(name);
    } else {
        return "gpii.test.integration.mockExecHandler";
    }
};

// cf. much less sophisticated mock in LifecycleManagerTest.js
fluid.defaults("gpii.test.integration.mockSettingsHandler", {
    gradeNames: ["fluid.littleComponent", "autoInit"],
    members: {
        settingsStore: {}
    },
    async: false,
    // must be configured for each settingsHandler instance to resolve to a path within
    // the options structure which determines a unique key for the particular payload
    // can also resolve to a function which returns such a key given the options
    optionsPathKey: null,
    invokers: {
        set: {
            funcName: "gpii.test.integration.mockSettingsHandler.set",
            args: ["{that}", "{arguments}.0"]
        },
        setImpl: {
            funcName: "gpii.test.integration.mockSettingsHandler.setImpl",
            args: ["{that}", "{arguments}.0"]
        },
        get: {
            funcName: "gpii.test.integration.mockSettingsHandler.get",
            args: ["{that}", "{arguments}.0"]
        },
        getImpl: {
            funcName: "gpii.test.integration.mockSettingsHandler.getImpl",
            args: ["{that}", "{arguments}.0"]
        }
    }
});

gpii.test.integration.resolveHandlerKey = function (that, payload) {
    var pathKey = that.options.optionsPathKey;
    if (typeof(pathKey) === "string") {
        return fluid.get(payload.options, pathKey);
    } else if (typeof(pathKey) === "function") {
        return pathKey(payload.options);
    }
};

gpii.test.integration.mockSettingsHandler.applySettings = function (store, settings) {
    fluid.each(settings, function (value, key) {
        if (value === undefined) {
            delete store[key];
        } else {
            store[key] = value;
        }
    });
};

gpii.test.integration.mockSettingsHandler.makeSetReturn = function (oldStore, settings) {
    return fluid.transform(settings, function (value, key) {
        return {
            oldValue: oldStore[key],
            value: value
        };
    });
};

gpii.test.integration.mockSettingsHandler.setImpl = function (that, payload) {
    var setSettings = function () {
        var key = gpii.test.integration.resolveHandlerKey(that, payload);
        var oldStore = fluid.copy(that.settingsStore[key]) || {};
        var store = (that.settingsStore[key] = that.settingsStore[key] || {});
        var applySettings = function () {
            gpii.test.integration.mockSettingsHandler.applySettings(store, payload.settings);
        };
        if (that.options.delaying) {
            // behave, for example, like the real SPI settings handler - claim to apply settings but don't actually do it till later 
            gpii.invokeLater(applySettings, 5000);
        } else {
            applySettings();
        }
        return gpii.test.integration.mockSettingsHandler.makeSetReturn(oldStore, payload.settings);
    }, togo;
    if (that.options.async) {
        togo = fluid.promise();
        gpii.invokeLater(function () {
            var response = setSettings();
            togo.resolve(response);
        }, 100);
    } else {
        togo = setSettings();
    }
    return togo;
};

gpii.test.integration.mockSettingsHandler.set = function (that, payload) {
    return gpii.settingsHandlers.invokeSettingsHandler(that.setImpl, payload);
};

gpii.test.integration.mockSettingsHandler.getImpl = function (that, payload) {
    var key = gpii.test.integration.resolveHandlerKey(that, payload);
    var store = that.settingsStore[key] || {};
    var togo = fluid.transform(payload.settings, function (value, key) {
        return store[key];
    });
    return togo;
};

gpii.test.integration.mockSettingsHandler.get = function (that, payload) {
    return gpii.settingsHandlers.invokeSettingsHandler(that.getImpl, payload);
};

// The platform-specific registry of mock settings handlers

gpii.test.integration.registrySettingsHandlerKey = function (options) {
    return options.hKey + "|" + options.path;
};

fluid.defaults("gpii.test.integration.mockSettingsHandlerRegistry", {
    gradeNames: ["fluid.eventedComponent", "autoInit"],
    rootPath: "gpii.test.integration.mockSettingsHandlers", // the global names for mocks will be deposited in here
    members: {
        settingsHandlers: {}
    },
    invokers: {
        resolveName: {
            funcName: "gpii.test.integration.mockSettingsHandlerRegistry.resolveName",
            args: ["{that}", "{arguments}.0"]
        }
    },
    listeners: {
        onCreate: "gpii.test.integration.mockSettingsHandlerRegistry.populate"
    }
});

gpii.test.integration.mockSettingsHandlers = {};

gpii.test.integration.mockSettingsHandlerRegistry.populate = function (that) {
    fluid.each(that.options.settingsHandlers, function (options, key) {
        var mock = gpii.test.integration.mockSettingsHandler(options);
        that.settingsHandlers[key] = mock;
        // Mount the mock handler at a global path
        var setPath = that.options.rootPath + "." + key + ".set";
        fluid.setGlobalValue(setPath, mock.set);
        fluid.setGlobalValue(that.options.rootPath + "." + key + ".get", mock.get);
    });
};

gpii.test.integration.mockSettingsHandlerRegistry.resolveName = function (that, name) {
    var mock = that.settingsHandlers[name];
    if (!mock) {
        var registered = fluid.keys(that.settingsHandlers).join(", ");
        fluid.fail("Error in settings handler mock configuration - handler " + name +
            " is not registered - registered handlers are " + registered);
    } else {
        return that.options.rootPath + "." + name;
    }
};

fluid.defaults("gpii.test.integration.mockSettingsHandlerRegistry.universal", {
    gradeNames: ["gpii.test.integration.mockSettingsHandlerRegistry", "autoInit"],
    settingsHandlers: {
        "gpii.settingsHandlers.INISettingsHandler": {
            optionsPathKey: "filename"
        },
        "gpii.settingsHandlers.XMLSettingsHandler": {
            optionsPathKey: "filename"
        },
        "gpii.settingsHandlers.JSONSettingsHandler": {
            optionsPathKey: "filename"
        }
    }
});

fluid.defaults("gpii.test.integration.mockSettingsHandlerRegistry.windows", {
    gradeNames: ["gpii.test.integration.mockSettingsHandlerRegistry.universal", "autoInit"],
    settingsHandlers: {
        "gpii.windows.registrySettingsHandler": {
            optionsPathKey: gpii.test.integration.registrySettingsHandlerKey
        },
        "gpii.windows.spiSettingsHandler": {
            delaying: true,
            optionsPathKey: "setAction"
        }
    }
});

fluid.defaults("gpii.test.integration.mockSettingsHandlerRegistry.linux", {
    gradeNames: ["gpii.test.integration.mockSettingsHandlerRegistry.universal", "autoInit"],
    settingsHandlers: {
        "gpii.gsettings": {
            optionsPathKey: "schema"
        },
        "gpii.orca": {
            async: true,
            optionsPathKey: "user"
        },
        "gpii.alsa": {
            optionsPathKey: "NONE"
        }
    }
});

fluid.defaults("gpii.test.integration.mockSettingsHandlerRegistry.android", {
    gradeNames: ["gpii.test.integration.mockSettingsHandlerRegistry.universal", "autoInit"],
    settingsHandlers: {
        "gpii.androidSettings": {
            optionsPathKey: "settingType"
        },
        "gpii.androidAudioManager.volume": {
            optionsPathKey: "NONE"
        },
        "gpii.androidPersistentConfiguration": {
            optionsPathKey: "NONE"
        }
    }
});
