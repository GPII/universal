/**
GPII Integration Testing

Copyright 2013 Raising the Floor International
Copyright 2013 OCAD University
Copyright 2014 Lucendo Development Ltd.

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

The research leading to these results has received funding from the European Union's
Seventh Framework Programme (FP7/2007-2013) under grant agreement no. 289016.

You may obtain a copy of the License at
https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

"use strict";

var fluid = fluid || require("infusion"),
    gpii = fluid.registerNamespace("gpii");

// Maintains a mock model of currently executing processes
fluid.defaults("gpii.test.integration.exec", {
    gradeNames: ["gpii.test.common.exec", "autoInit"],
    members: {
        processModel: [] // list of process objects
    },
    invokers: {
        exec: {
            funcName: "gpii.test.integration.exec.exec",
            args: ["{that}", "{arguments}.0", "{arguments}.1"]
        }
    }
});

gpii.test.integration.exec.exec = function (that, processSpec /*, expected */) {
    // TODO: actually determine that the required process was started using the mock model
    that.events.onExecExit.fire(true, processSpec);
};

fluid.defaults("gpii.test.integration.testCaseHolder", {
    gradeNames: ["gpii.test.common.testCaseHolder", "autoInit"],
    distributeOptions: [{
        record: {
            funcName: null,
            func: "{gpii.test.integration.testCaseHolder}.nameResolver.resolveName"
        },
        target: "{that lifecycleManager > nameResolver}.options.invokers.resolveName"
    }, {
        record: {
            funcName: null,
            func: "{gpii.test.integration.testCaseHolder}.mockPlatformReporter.reportPlatform"
        },
        target: "{that deviceReporter platformReporter}.options.invokers.reportPlatform"
    }],
    components: {
        exec: {
            type: "gpii.test.integration.exec"
        },
        mockSettingsHandlers: {
            type: "gpii.test.integration.mockSettingsHandlerRegistry.universal"
        },
        nameResolver: {
            type: "fluid.littleComponent",
            options: {
                invokers: {
                    resolveName: {
                        funcName: "gpii.test.integration.resolveName",
                        args: ["{mockSettingsHandlers}", "{arguments}.0", "{arguments}.1"]
                    }
                }
            }
        }
    }
});

fluid.defaults("gpii.test.integration.testCaseHolder.windows", {
    gradeNames: ["gpii.test.integration.testCaseHolder", "autoInit"],
    components: {
        mockSettingsHandlers: {
            type: "gpii.test.integration.mockSettingsHandlerRegistry.windows"
        },
        mockPlatformReporter: {
            type: "gpii.test.integration.mockPlatformReporter",
            options: {
                platform: {
                    id: "win32",
                    version: "6.1.7601"
                }
            }
        }
    }
});


fluid.defaults("gpii.test.integration.testCaseHolder.linux", {
    gradeNames: ["gpii.test.integration.testCaseHolder", "autoInit"],
    components: {
        mockSettingsHandlers: {
            type: "gpii.test.integration.mockSettingsHandlerRegistry.linux"
        },
        mockPlatformReporter: {
            type: "gpii.test.integration.mockPlatformReporter",
            options: {
                platform: {
                    id: "linux",
                    version: "2.6.26"
                }
            }
        }
    }
});

fluid.defaults("gpii.test.integration.testCaseHolder.android", {
    gradeNames: ["gpii.test.integration.testCaseHolder", "autoInit"],
    components: {
        mockSettingsHandlers: {
            type: "gpii.test.integration.mockSettingsHandlerRegistry.android"
        },
        mockPlatformReporter: {
            type: "gpii.test.integration.mockPlatformReporter",
            options: {
                platform: {
                    id: "android",
                    version: "3.0.31"
                }
            }
        }
    }
});

fluid.defaults("gpii.test.integration.mockPlatformReporter", {
    gradeNames: ["fluid.littleComponent", "autoInit"],
    invokers: {
        reportPlatform: {
            funcName: "fluid.identity",
            args: "{that}.options.platform"
        }
    }
});


gpii.test.integration.mockExecHandler = function (command, args) {
    // TODO: we should record the executing process in a process model - ideally we should have a more reliable model of extracting what it is
    fluid.log("Mock exec handler for command ", command, " args ", args);
};

fluid.defaults("gpii.test.integration.mockExecHandler", {
    gradeNames: "fluid.function",
    argumentMap: {
        command: 0,
        args: 1
    }
});

gpii.test.integration.resolveName = function (settingsHandlerRegistry, name, category) {
    if (category === "settingsHandler") {
        return settingsHandlerRegistry.resolveName(name);
    } else {
        return "gpii.test.integration.mockExecHandler";
    }
};

// cf. much less sophisticated mock in LifecycleManagerTest.js
fluid.defaults("gpii.test.integration.mockSettingsHandler", {
    gradeNames: ["fluid.littleComponent", "autoInit"],
    members: {
        settingsStore: {}
    },
    async: false,
    // must be configured for each settingsHandler instance to resolve to a path within
    // the options structure which determines a unique key for the particular payload
    // can also resolve to a function which returns such a key given the options
    optionsPathKey: null,
    invokers: {
        set: {
            funcName: "gpii.test.integration.mockSettingsHandler.set",
            args: ["{that}", "{arguments}.0"]
        },
        setImpl: {
            funcName: "gpii.test.integration.mockSettingsHandler.setImpl",
            args: ["{that}", "{arguments}.0"]
        },
        get: {
            funcName: "gpii.test.integration.mockSettingsHandler.get",
            args: ["{that}", "{arguments}.0"]
        },
        getImpl: {
            funcName: "gpii.test.integration.mockSettingsHandler.getImpl",
            args: ["{that}", "{arguments}.0"]
        }
    }
});

gpii.test.integration.resolveHandlerKey = function (that, payload) {
    var pathKey = that.options.optionsPathKey;
    if (typeof(pathKey) === "string") {
        return fluid.get(payload.options, pathKey);
    } else if (typeof(pathKey) === "function") {
        return pathKey(payload.options);
    }
};

gpii.test.integration.mockSettingsHandler.applySettings = function (store, settings) {
    fluid.each(settings, function (value, key) {
        if (value === undefined) {
            delete store[key];
        } else {
            store[key] = value;
        }
    });
};

gpii.test.integration.mockSettingsHandler.makeSetReturn = function (oldStore, settings) {
    return fluid.transform(settings, function (value, key) {
        return {
            oldValue: oldStore[key],
            value: value
        };
    });
};

gpii.test.integration.mockSettingsHandler.setImpl = function (that, payload) {
    var setSettings = function () {
        var key = gpii.test.integration.resolveHandlerKey(that, payload);
        var oldStore = fluid.copy(that.settingsStore[key]) || {};
        var store = (that.settingsStore[key] = that.settingsStore[key] || {});
        var applySettings = function () {
            gpii.test.integration.mockSettingsHandler.applySettings(store, payload.settings);
        };
        if (that.options.delaying) {
            // behave, for example, like the real SPI settings handler - claim to apply settings but don't actually do it till later
            gpii.invokeLater(applySettings, 5000);
        } else {
            applySettings();
        }
        return gpii.test.integration.mockSettingsHandler.makeSetReturn(oldStore, payload.settings);
    }, togo;
    if (that.options.async) {
        togo = fluid.promise();
        gpii.invokeLater(function () {
            var response = setSettings();
            togo.resolve(response);
        }, 100);
    } else {
        togo = setSettings();
    }
    return togo;
};

gpii.test.integration.mockSettingsHandler.set = function (that, payload) {
    return gpii.settingsHandlers.invokeSettingsHandler(that.setImpl, payload);
};

gpii.test.integration.mockSettingsHandler.getImpl = function (that, payload) {
    var key = gpii.test.integration.resolveHandlerKey(that, payload);
    var store = that.settingsStore[key] || {};
    var togo = fluid.transform(payload.settings, function (value, key) {
        return store[key];
    });
    return togo;
};

gpii.test.integration.mockSettingsHandler.get = function (that, payload) {
    return gpii.settingsHandlers.invokeSettingsHandler(that.getImpl, payload);
};

// The platform-specific registry of mock settings handlers

gpii.test.integration.registrySettingsHandlerKey = function (options) {
    return options.hKey + "|" + options.path;
};

fluid.defaults("gpii.test.integration.mockSettingsHandlerRegistry", {
    gradeNames: ["fluid.eventedComponent", "autoInit"],
    rootPath: "gpii.test.integration.mockSettingsHandlers", // the global names for mocks will be deposited in here
    members: {
        settingsHandlers: {}
    },
    invokers: {
        resolveName: {
            funcName: "gpii.test.integration.mockSettingsHandlerRegistry.resolveName",
            args: ["{that}", "{arguments}.0"]
        }
    },
    listeners: {
        onCreate: "gpii.test.integration.mockSettingsHandlerRegistry.populate"
    }
});

gpii.test.integration.mockSettingsHandlers = {};

gpii.test.integration.mockSettingsHandlerRegistry.populate = function (that) {
    fluid.each(that.options.settingsHandlers, function (options, key) {
        var mock = gpii.test.integration.mockSettingsHandler(options);
        that.settingsHandlers[key] = mock;
        // Mount the mock handler at a global path
        var setPath = that.options.rootPath + "." + key + ".set";
        fluid.setGlobalValue(setPath, mock.set);
        fluid.setGlobalValue(that.options.rootPath + "." + key + ".get", mock.get);
    });
};

gpii.test.integration.mockSettingsHandlerRegistry.resolveName = function (that, name) {
    var mock = that.settingsHandlers[name];
    if (!mock) {
        var registered = fluid.keys(that.settingsHandlers).join(", ");
        fluid.fail("Error in settings handler mock configuration - handler " + name +
            " is not registered - registered handlers are " + registered);
    } else {
        return that.options.rootPath + "." + name;
    }
};

fluid.defaults("gpii.test.integration.mockSettingsHandlerRegistry.universal", {
    gradeNames: ["gpii.test.integration.mockSettingsHandlerRegistry", "autoInit"],
    settingsHandlers: {
        "gpii.settingsHandlers.INISettingsHandler": {
            optionsPathKey: "filename"
        },
        "gpii.settingsHandlers.XMLSettingsHandler": {
            optionsPathKey: "filename"
        },
        "gpii.settingsHandlers.JSONSettingsHandler": {
            optionsPathKey: "filename"
        }
    }
});

fluid.defaults("gpii.test.integration.mockSettingsHandlerRegistry.windows", {
    gradeNames: ["gpii.test.integration.mockSettingsHandlerRegistry.universal", "autoInit"],
    settingsHandlers: {
        "gpii.windows.registrySettingsHandler": {
            optionsPathKey: gpii.test.integration.registrySettingsHandlerKey
        },
        "gpii.windows.spiSettingsHandler": {
            delaying: true,
            optionsPathKey: "setAction"
        }
    }
});

fluid.defaults("gpii.test.integration.mockSettingsHandlerRegistry.linux", {
    gradeNames: ["gpii.test.integration.mockSettingsHandlerRegistry.universal", "autoInit"],
    settingsHandlers: {
        "gpii.gsettings": {
            optionsPathKey: "schema"
        },
        "gpii.orca": {
            async: true,
            optionsPathKey: "user"
        },
        "gpii.alsa": {
            optionsPathKey: "NONE"
        }
    }
});

fluid.defaults("gpii.test.integration.mockSettingsHandlerRegistry.android", {
    gradeNames: ["gpii.test.integration.mockSettingsHandlerRegistry.universal", "autoInit"],
    settingsHandlers: {
        "gpii.androidSettings": {
            optionsPathKey: "settingType"
        },
        "gpii.androidAudioManager.volume": {
            optionsPathKey: "NONE"
        },
        "gpii.androidPersistentConfiguration": {
            optionsPathKey: "NONE"
        }
    }
});
