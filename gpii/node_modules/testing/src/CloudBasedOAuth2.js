/*!
GPII Cloud-based Flow Manager with OAuth2 Test Infrastructure

Copyright 2012 OCAD University
Copyright 2012 Antranig Basman
Copyright 2013 Raising the Floor
Copyright 2014 Lucendo Development Ltd.

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

"use strict";

var fluid = require("infusion"),
    querystring = require("querystring"),
    urlModule = require("url"),
    gpii = fluid.registerNamespace("gpii"),
    jqUnit = fluid.registerNamespace("jqUnit"),
    kettle = fluid.registerNamespace("kettle"),
    path = require("path");

fluid.registerNamespace("gpii.test.cloudBased.oauth2");

/** Parses a URL using the node.js url.parse algorithm, and assembles it into a JSON
 * structure holding keys:
 *     "" : holding the concatenation of "protocol", "host" and "pathname" portions as specified in url.parse
 *  others: holding the keys and values for any query parameters, as parsed by the querystring algorithm
 * This structure is then checked against the "expected" structure using the jqUnit.assertLeftHand algorithm
 * which checks that every element specified in "expected" is present but ignores any extra elements
 * @param message {String} A message to be supplied for this assertion
 * @param expected {Object/String} A object map of the required contents of the URL as described above, or if a String
 * value, tested with exact string equality
 * @param url {String} The url to be tested by this assertion
 * @return {Object/String} according to the type of `expected`, either the full assembled parsed URL structure or the original URL
 */
gpii.test.assertURL = function (message, expected, url) {
    if (typeof(expected) === "string") {
        jqUnit.assertEquals(message, expected, url);
        return url;
    } else {
        var parsed = urlModule.parse(url, true);
        var assembled = fluid.extend({
            "": parsed.protocol + "//" + parsed.host + parsed.pathname
        }, parsed.query);
        jqUnit.assertLeftHand(message, expected, assembled);
        return assembled;
    }
};

gpii.test.verifyRedirectResponse = function (request, location) {
    var response = request.nativeResponse;
    jqUnit.assertEquals("Should have received a 302 redirect", 302, response.statusCode);
    return gpii.test.assertURL("Should have been redirected to " + location, location, response.headers.location);
};

gpii.test.stringifyFormBody = function (formBody) {
    var encoded = fluid.transform(formBody, function (element) {
        return typeof(element) === "string" ? element : JSON.stringify(element);
    });
    return querystring.stringify(encoded);
};

// On startup of the datastore, overwrite its content so that the stored GPII user token
// and authDecisions agree with the data in the current test fixture
gpii.test.cloudBased.oauth2.populateDataStore = function (testCaseHolder, doneEvent) {

    // TODO: This should be supplied via an IoC-resolved argument after the FLUID-4892 rewrite of Infusion.
    var db = testCaseHolder.pouchHarness.express.expressPouch.databaseInstances.auth;

    var promisesSequence = [];

    // userToken
    if (!testCaseHolder.options.isAnonymousToken) {
        // Unless the test case is for an anonymous token, set the
        // gpiiToken of the first user in the dataStore to the test
        // case userToken. Otherwise, if the test case is for a
        // anonymous token, leave the gpiiToken of users in the
        // dataStore unchanged. For a test case with an anonymous
        // token, we want no users in the dataStore to have a
        // gpiiToken of testCaseHolder.options.userToken.

        promisesSequence.push(db.get("user-1").then(function (user) {
            return db.put({
                _id: user._id,
                _rev: user._rev,
                type: user.type,
                name: user.name,
                password: user.password,
                defaultGpiiToken: testCaseHolder.options.userToken
            });
        }).then(function () {
            return db.put({
                _id: "gpiiToken-100",
                type: "gpiiToken",
                gpiiToken: testCaseHolder.options.userToken,
                userId: "user-1"
            });
        }));
    }

    // authDecisions
    var postAuthDecisionPromises = fluid.transform(testCaseHolder.options.authDecisions, function (authDecision) {
        return db.post(fluid.extend({}, authDecision, { type: "authDecision" }));
    });
    promisesSequence.push.apply(promisesSequence, postAuthDecisionPromises);

    // Fire the doneEvent at the end to signal that we are finished
    promisesSequence.push(function () {
        doneEvent.fire();
    });

    fluid.promise.sequence(promisesSequence);
};

gpii.test.cloudBased.oauth2.verifyLoginRedirect = function (request, cookieJar) {
    gpii.test.verifyRedirectResponse(request, "/login");
    jqUnit.assertValue("Should have stored a cookie received from server", cookieJar.cookie);
};

gpii.test.cloudBased.oauth2.verifyAuthorizeRedirect = function (loginRequest, authorizeRequest) {
    gpii.test.verifyRedirectResponse(loginRequest, authorizeRequest.nativeRequest.path);
    var response = loginRequest.nativeResponse;
    jqUnit.assertTrue("Should have been redirected to an /authorize URL", response.headers.location.indexOf("/authorize") === 0);
};

gpii.test.cloudBased.oauth2.sendAuthorizeRequest2 = function (authorizeRequest2, loginRequest) {
    authorizeRequest2.send(null, {
        path: loginRequest.nativeResponse.headers.location
    });
};

gpii.test.verifyHTMLResponse = function (body, request) {
    var response = request.nativeResponse;
    jqUnit.assertEquals("Should have received a 200 response", 200, response.statusCode);
    jqUnit.assertTrue("Should have received an HTML response type", response.headers["content-type"].indexOf("text/html") === 0);
    jqUnit.assertTrue("Should have received HTML content as body", body.indexOf("<html>") !== -1);
};

gpii.test.verifyJSONResponse = function (body, request) {
    var response = request.nativeResponse;
    jqUnit.assertEquals("Should have received a 200 response", 200, response.statusCode);
    jqUnit.assertTrue("Should have received an JSON response type", response.headers["content-type"].indexOf("application/json") === 0);
    return JSON.parse(body);
};

gpii.test.verifyStatusCodeResponse = function (body, request, statusCode) {
    var response = request.nativeResponse;
    jqUnit.assertEquals("Should have received a " + statusCode + " response", statusCode, response.statusCode);
};

gpii.test.verifyBodyContents = function (body, expectedParts) {
    fluid.each(expectedParts, function (part) {
        jqUnit.assertTrue("Body should have contained \"" + part + "\"", body.indexOf(part) !== -1);
    });
};

// The current decision UI renders the transaction ID as part of a JSON block supplied
// to an init block within the markup (code is within AuthServer.js line 344, template
// is in authorize.handlebars) - this function needs to track the particular scheme used
// within this UI
gpii.test.cloudBased.oauth2.extractTransactionID = function (body) {
    return body.match(/transactionID:\s*"(.*)"/);
};

gpii.test.cloudBased.oauth2.verifyAuthorizeResponse = function (body, authorizeRequest) {
    gpii.test.verifyHTMLResponse(body, authorizeRequest);
    var transactions = gpii.test.cloudBased.oauth2.extractTransactionID(body);
    jqUnit.assertEquals("Should have matched 1 transaction ID", 2, transactions.length);
    authorizeRequest.transactionID = transactions[1]; // entry 0 represents entire match
};

gpii.test.cloudBased.oauth2.sendLoginRequest = function (loginRequest, options) {
    var formBody = {username: options.username, password: options.password};

    formBody = gpii.test.cloudBased.oauth2.filter(formBody, options, "loginRequestForm");

    loginRequest.send(gpii.test.stringifyFormBody(formBody));
};


gpii.test.cloudBased.oauth2.sendDecisionRequest = function (decisionRequest, authorizeRequest, options) {
    var formBody = {
        transaction_id: authorizeRequest.transactionID,
        accept: true,
        selectedPreferences: fluid.copy(options.selectedPreferences)
    };

    formBody = gpii.test.cloudBased.oauth2.filter(formBody, options, "decisionRequestForm");
    decisionRequest.formBody = formBody;

    decisionRequest.send(gpii.test.stringifyFormBody(formBody));
};

gpii.test.cloudBased.oauth2.verifyDecisionResponse = function (decisionRequest, clientURL, clientState) {
    var redirect = gpii.test.verifyRedirectResponse(decisionRequest, {
        "": clientURL,
        state: clientState
    });
    jqUnit.assertValue("Should have received authorization code as query parameter", redirect.code);
    decisionRequest.authorizationCode = redirect.code;
};

gpii.test.cloudBased.oauth2.sendRequest = function (request, options, formBody, filterName) {
    formBody = gpii.test.cloudBased.oauth2.filter(formBody, options, filterName);
    request.send(gpii.test.stringifyFormBody(formBody));
};

gpii.test.cloudBased.oauth2.sendAccessTokenRequestInAuthCode = function (accessTokenRequest, decisionRequest, options) {
    var formBody = {
        grant_type: "authorization_code",
        code: decisionRequest.authorizationCode,
        redirect_uri: options.redirect_uri,
        client_id: options.client_id,
        client_secret: options.client_secret
    };

    gpii.test.cloudBased.oauth2.sendRequest(accessTokenRequest, options, formBody, "accessTokenForm");
};

gpii.test.cloudBased.oauth2.sendAccessTokenRequestInClientCredentials = function (accessTokenRequest, options) {
    var formBody = {
        grant_type: "client_credentials",
        scope: options.scope,
        client_id: options.client_id,
        client_secret: options.client_secret
    };

    gpii.test.cloudBased.oauth2.sendRequest(accessTokenRequest, options, formBody, "accessTokenForm");
};

gpii.test.cloudBased.oauth2.verifyAccessTokenInResponse = function (body, accessTokenRequest) {
    var response = gpii.test.verifyJSONResponse(body, accessTokenRequest);
    var token = response.access_token;
    fluid.log("oauth2.verifyAccessTokenInResponse Got access token ", token);
    jqUnit.assertValue("Should have received an access token", token);
    accessTokenRequest.accessToken = token;
};

gpii.test.cloudBased.oauth2.verifyAuthorizedServicesResponse = function (authorizedServicesRequest, response, clientId) {
    var payload = JSON.parse(response);
    fluid.log("oauth2.verifyAuthorizedServicesResponse got authorized services payload " + JSON.stringify(payload, null, 2) + ": looking for clientId " + clientId);
    var authorizedServices = payload.authorizedServices;
    var record = fluid.find_if(authorizedServices, function (client) {
        return client.oauth2ClientId === clientId;
    });
    fluid.log("oauth2.verifyAuthorizedServicesResponse got authorized service record " + JSON.stringify(record, null, 2));
    jqUnit.assertValue("Found a record returned from authorized services whose client id matches the one under test", record);
    authorizedServicesRequest.authorizedService = record;
};

gpii.test.cloudBased.oauth2.sendAuthorizationRequest = function (authorizationsRequest, authorizationId, suffix, payload) {
    var path = "/authorizations/" + authorizationId + (suffix ? suffix : "");
    authorizationsRequest.send(payload, {
        path: path
    });
};

gpii.test.cloudBased.oauth2.verifyGetAuthorization = function (data, selectedPreferences) {
    var authorization = JSON.parse(data);
    jqUnit.assertDeepEq("Expected stored selectedPreferences to equal those set",
        selectedPreferences, authorization);
};

gpii.test.cloudBased.oauth2.sendSecuredSettingsRequest = function (securedSettingsRequest, accessTokenRequest) {
    securedSettingsRequest.send(null, {
        headers: {
            Authorization: "Bearer " + accessTokenRequest.accessToken
        }
    });
};

gpii.test.cloudBased.oauth2.verifySecuredSettingsResponse = function (body, securedSettingsRequest, expected) {
    var response = gpii.test.verifyJSONResponse(body, securedSettingsRequest);
    fluid.log("oauth2.verifySecuredSettingsResponse got settings " + JSON.stringify(response, null, 2));
    jqUnit.assertDeepEq("Expected settings returned from flowManager", expected, response);
};

gpii.test.cloudBased.oauth2.verifyPrivacySettingsRedirect = function (loginRequest, privacySettingsRequest) {
    gpii.test.verifyRedirectResponse(loginRequest, privacySettingsRequest.nativeRequest.path);
    var response = loginRequest.nativeResponse;
    jqUnit.assertTrue("Should have been redirected to /privacy-settings", response.headers.location.indexOf("/privacy-settings") === 0);
};

gpii.test.cloudBased.oauth2.sendPrivacySettingsRequest2 = function (privacySettingsRequest2, loginRequest) {
    privacySettingsRequest2.send(null, {
        path: loginRequest.nativeResponse.headers.location
    });
};

gpii.test.cloudBased.oauth2.verifyPrivacySettingsResponse = function (body, privacySettingsRequest, expectedParts) {
    gpii.test.verifyHTMLResponse(body, privacySettingsRequest);
    gpii.test.verifyBodyContents(body, expectedParts);
};

gpii.test.cloudBased.oauth2.sendAddPrefsRequest = function (securedAddPrefsRequest, prefsData, secured, accessToken, view) {
    view = view || "flat";
    secured = secured || true;

    var options = {
        path: "/add-preferences?view=" + view
    };

    var securedHeader = {
        headers: {
            Authorization: "Bearer " + accessToken,
            "Content-Type": "application/json"
        }
    };

    var securedOptions = fluid.extend({}, options, securedHeader);

    options = secured ? securedOptions : options;

    securedAddPrefsRequest.send(prefsData, options);
};

gpii.test.cloudBased.oauth2.verifyAddPrefsResponse = function (body, addPrefsRequest, expectedPrefs, prefsDir) {
    var response = gpii.test.verifyJSONResponse(body, addPrefsRequest);
    jqUnit.assertValue("Should have received a user token", response.userToken);
    jqUnit.assertDeepEq("The received saved preferences data should be expect", expectedPrefs, response.preferences);
    addPrefsRequest.userToken = response.userToken;

    var filePath = path.resolve(prefsDir, response.userToken) + ".json";
    gpii.tests.cloud.oauth2.addPrefs.filesToDelete.push(filePath);
};

gpii.test.cloudBased.oauth2.sendGetPrefsRequest = function (getPrefsRequest, addPrefsRequest, view) {
    view = view || "flat";
    var options = {
        path: "/preferences/" + addPrefsRequest.userToken + "?view=" + view
    };

    getPrefsRequest.send(null, options);
};

gpii.test.cloudBased.oauth2.verifyGetPrefsResponse = function (body, getPrefsResponse, expectedPrefs) {
    var response = gpii.test.verifyJSONResponse(body, getPrefsResponse);
    jqUnit.assertDeepEq("The received saved preferences data should be expect", expectedPrefs, response);
};

gpii.test.cloudBased.verifyPayloadMatchMakerOutput = function (body, expectedSettings) {
    var payload = JSON.parse(body);
    var lifecycleInstructions = fluid.get(payload, [ "matchMakerOutput", "inferredConfiguration", "gpii-default", "lifecycleInstructions" ]);
    // remove all irrelevant chunks of the payload (i.e. keep only structure into settings blocks)
    var filteredInstructions = fluid.copy(lifecycleInstructions);
    filteredInstructions = fluid.transform(filteredInstructions, function (solutionEntry) {
        return {
            settingsHandlers: fluid.transform(solutionEntry.settingsHandlers, function (settingsHandlerBlock) {
                return {
                    settings: settingsHandlerBlock.settings
                };
            })
        };
    });

    jqUnit.assertDeepEq("Verifying settings from matchmaker output", expectedSettings, filteredInstructions);
};

gpii.test.cloudBased.oauth2.verifyDataStoreAuthorization = function (dataStore, expectedAuthDecision, verificationDoneEvent) {
    var findAuthDecisionPromise = dataStore.findAuthDecision(expectedAuthDecision.gpiiToken,
                                                             expectedAuthDecision.clientId,
                                                             expectedAuthDecision.redirectUri);
    findAuthDecisionPromise.then(function (foundAuthDecision) {
        jqUnit.assertValue("The dataStore contains a matching authDecision", foundAuthDecision);
        jqUnit.assertValue("id has a value", foundAuthDecision.id);
        jqUnit.assertValue("accessToken has a value", foundAuthDecision.accessToken);
        jqUnit.assertDeepEq("authDecision contents are as expected",
                            fluid.extend({}, { id: foundAuthDecision.id, accessToken: foundAuthDecision.accessToken }, expectedAuthDecision),
                            foundAuthDecision);
        verificationDoneEvent.fire();
    });
};

fluid.defaults("gpii.test.cloudBased.oauth2.testCaseHolder", {
    gradeNames: ["kettle.test.testCaseHolder", "gpii.test.pouch.pouchTestCaseHolder"],
    selectedPreferences: {
        "": true
    },
    events: {
        onDataPopulated: null,
        onFixturesConstructed: {
            events: {
                onDataPopulated: "onDataPopulated"
            }
        }
    },
    listeners: {
        "onPouchHarnessReady.populateData": {
            funcName: "gpii.test.cloudBased.oauth2.populateDataStore",
            args: ["{testCaseHolder}", "{testCaseHolder}.events.onDataPopulated"]
        }
    },
    components: {
        authorizeRequest: {
            type: "kettle.test.request.httpCookie",
            options: {
                path: "/authorize?response_type=code&client_id=%client_id&redirect_uri=%redirect_uri&state=%state",
                port: 8081,
                termMap: {
                    client_id: "{testCaseHolder}.options.client_id",
                    redirect_uri: "{testCaseHolder}.options.redirect_uri",
                    state: "{testCaseHolder}.options.state"
                }
            }
        },
        loginRequest: {
            type: "kettle.test.request.httpCookie",
            options: {
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded"
                },
                path: "/login",
                port: 8081,
                method: "POST"
            }
        },
        authorizeRequest2: {
            type: "kettle.test.request.httpCookie",
            options: {
                // path: - supplied dynamically based on returned redirect from previous request
                port: 8081
            }
        },
        decisionRequest: {
            type: "kettle.test.request.httpCookie",
            options: {
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded"
                },
                path: "/authorize_decision",
                port: 8081,
                method: "POST"
            }
        },
        accessTokenRequest: {
            type: "kettle.test.request.http",
            options: {
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded"
                },
                path: "/access_token",
                port: 8081,
                method: "POST"
            }
        },
        getAuthorizedServicesRequest: {
            type: "kettle.test.request.httpCookie",
            options: {
                path: "/authorized-services"
            }
        },
        getAuthorizationRequest: {
            type: "kettle.test.request.httpCookie",
            options: {
                // path: "/authorizations/%authorizationId/preferences", // currently cannot be dynamically templated
                port: 8081,
                method: "GET"
            }
        },
        securedSettingsRequest: {
            type: "kettle.test.request.http",
            options: {
                path: "/settings",
                port: 8081,
                method: "GET"
            }
        },
        addPrefsRequest: {
            type: "kettle.test.request.http",
            options: {
                // path: "/add-preferences?view=%view",  // Cannot dynamically config path
                port: 8081,
                method: "POST"
            }
        },
        getPrefsRequest: {
            type: "kettle.test.request.http",
            options: {
                // path: "/preferences?view=%view",  // Cannot dynamically config path
                port: 8081,
                method: "GET"
            }
        },
        getPrefsRequest2: {
            type: "kettle.test.request.http",
            options: {
                // path: "/preferences?view=%view",  // Cannot dynamically config path
                port: 8081,
                method: "GET"
            }
        }
    }
});

// TODO: Find a scheme for identifying these elements by name rather than by
// number following implementation of FLUID-5506 and FLUID-5903

gpii.test.cloudBased.oauth2.mainSequence = [
    { // 0
        func: "{authorizeRequest}.send"
    }, {  // 1
        event: "{authorizeRequest}.events.onComplete",
        listener: "gpii.test.cloudBased.oauth2.verifyLoginRedirect",
        args: ["{authorizeRequest}", "{cookieJar}"]
    }, {  // 2 - 2 variants here for omitting each form field
        funcName: "gpii.test.cloudBased.oauth2.sendLoginRequest",
        args: ["{loginRequest}", "{testCaseHolder}.options"]
    }, {  // 3
        event: "{loginRequest}.events.onComplete",
        listener: "gpii.test.cloudBased.oauth2.verifyAuthorizeRedirect",
        args: ["{loginRequest}", "{authorizeRequest}"]
    }, {  // 4
        funcName: "gpii.test.cloudBased.oauth2.sendAuthorizeRequest2",
        args: ["{authorizeRequest2}", "{loginRequest}"]
    }, {  // 5
        event: "{authorizeRequest2}.events.onComplete",
        listener: "gpii.test.cloudBased.oauth2.verifyAuthorizeResponse",
        args: ["{arguments}.0", "{authorizeRequest2}"]
    }, {  // 6 - 2 variants here for omitting each form field - plus variants for selectedPreferences
        funcName: "gpii.test.cloudBased.oauth2.sendDecisionRequest",
        args: ["{decisionRequest}", "{authorizeRequest2}", "{testCaseHolder}.options"]
    }, {  // 7
        event: "{decisionRequest}.events.onComplete",
        listener: "gpii.test.cloudBased.oauth2.verifyDecisionResponse",
        args: ["{decisionRequest}", "{testCaseHolder}.options.redirect_uri",
            "{testCaseHolder}.options.state"]
    }, {  // 8 - 5 variants here for omitting each form field
        funcName: "gpii.test.cloudBased.oauth2.sendAccessTokenRequestInAuthCode",
        args: ["{accessTokenRequest}", "{decisionRequest}", "{testCaseHolder}.options"]
    }, {  // 9
        event: "{accessTokenRequest}.events.onComplete",
        listener: "gpii.test.cloudBased.oauth2.verifyAccessTokenInResponse",
        args: ["{arguments}.0", "{accessTokenRequest}"]
    }, { // 10
        func: "{getAuthorizedServicesRequest}.send"
    }, { // 11
        event: "{getAuthorizedServicesRequest}.events.onComplete",
        listener: "gpii.test.cloudBased.oauth2.verifyAuthorizedServicesResponse",
        args: ["{getAuthorizedServicesRequest}", "{arguments}.0", "{testCaseHolder}.options.client_id"]
    }, { // 12
        funcName: "gpii.test.cloudBased.oauth2.sendAuthorizationRequest",
        args: ["{getAuthorizationRequest}", "{getAuthorizedServicesRequest}.authorizedService.authDecisionId",
            "/preferences"]
    }, { // 13
        event: "{getAuthorizationRequest}.events.onComplete",
        listener: "gpii.test.cloudBased.oauth2.verifyGetAuthorization",
        args: ["{arguments}.0", "{decisionRequest}.formBody.selectedPreferences"]
    }, { // 14
        funcName: "gpii.test.cloudBased.oauth2.sendSecuredSettingsRequest",
        args: ["{securedSettingsRequest}", "{accessTokenRequest}"]
    }, { // 15
        event: "{securedSettingsRequest}.events.onComplete",
        listener: "gpii.test.cloudBased.oauth2.verifySecuredSettingsResponse",
        args: ["{arguments}.0", "{securedSettingsRequest}", "{testCaseHolder}.options.expected"]
    }];

gpii.test.cloudBased.oauth2.buildTestFixtureCommon = function (testDef, commonRec, baseDir) {
    testDef = fluid.extend(true, {}, testDef, commonRec);

    testDef.sequence = fluid.makeArray(testDef.sequence);
    testDef.gradeNames = fluid.makeArray(testDef.gradeNames);
    testDef.gradeNames.push("gpii.test.cloudBased.oauth2.testCaseHolder");
    testDef.config = gpii.test.cloudBased.gpiiConfig(baseDir);
    return testDef;
};

gpii.test.cloudBased.oauth2.buildMainSequenceFixture = function (testDef, commonRec, baseDir) {
    testDef = gpii.test.cloudBased.oauth2.buildTestFixtureCommon(testDef, commonRec, baseDir);
    testDef.expect = 21;
    testDef.sequence = fluid.makeArray(gpii.test.cloudBased.oauth2.mainSequence);
    return testDef;
};

// returns subarray including only elements between start and end (non-inclusive)
gpii.test.elementsBetween = function (origArray, start, end) {
    var array = fluid.makeArray(origArray);
    start = start || 0;
    if (!end && end !== 0) {
        end = array.length;
    }
    array.length = end;
    array.splice(0, start);
    return array;
};

// insert the supplied elements into the array at position index (DESTRUCTIVE)
gpii.test.insertIntoArray = function (origArray, index, elements) {
    var spliceArgs = [index || 0, 0].concat(elements);
    origArray.splice.apply(origArray, spliceArgs);
};

gpii.test.cloudBased.oauth2.buildDisruptedFixture = function (testDef, commonRec, disruption, baseDir) {
    var options = fluid.defaults(disruption.gradeName);
    testDef = gpii.test.cloudBased.oauth2.buildTestFixtureCommon(testDef, commonRec, baseDir);
    if (options.expect) {
        testDef.expect = options.expect;
    }
    if (disruption.expected) {
        testDef.expected = disruption.expected;
    }
    if (disruption.name) {
        testDef.name += " - " + disruption.name;
    }
    testDef.gradeNames = testDef.gradeNames.concat(fluid.makeArray(options.testCaseGradeNames));
    var sequence = gpii.test.elementsBetween(fluid.getGlobalValue(options.sequenceName),
        options.startAt, options.truncateAt);
    if (options.finalRecord) {
        sequence.push(options.finalRecord);
    }
    if (options.insertRecords) { // TODO: replace all this special-case manipulation with FLUID-3504 when it is implemented
        gpii.test.insertIntoArray(sequence, options.insertAt, options.insertRecords);
    }

    testDef.sequence = gpii.test.pouch.addConstructFixturesToSequence(sequence);
    testDef.expectedStatusCode = disruption.expectedStatusCode || options.expectedStatusCode;
    fluid.log("oauth2.buildDisruptedFixture issuing sequence" + JSON.stringify(sequence, null, 2));
    var changes = fluid.makeArray(options.changes).concat(fluid.makeArray(disruption.changes));
    fluid.set(testDef, [options.recordName, "changes"], changes);
    return testDef;
};

fluid.defaults("gpii.test.disruption", {
    gradeNames: ["fluid.component"]
});

fluid.defaults("gpii.test.disruption.mainSequence", {
    gradeNames: ["gpii.test.disruption"],
    sequenceName: "gpii.test.cloudBased.oauth2.mainSequence"
});

gpii.test.cloudBased.oauth2.filter = function (model, options, filterName) {
    var changes = fluid.get(options, [filterName, "changes"]);
    fluid.log("cloudBased.oauth2.filter fetched changes " + JSON.stringify(changes, null, 2) + " for filter name " + filterName);
    return changes ? gpii.test.cloudBased.oauth2.filterModel(model, changes) : model;
};

gpii.test.cloudBased.oauth2.filterModel = function (model, changes) {
    var holder = {
        model: fluid.copy(model)
    };
    var applier = fluid.makeHolderChangeApplier(holder);
    fluid.fireChanges(applier, changes);
    fluid.log("cloudBased.oauth2.filterModel returning filtered model ", JSON.stringify(holder.model, null, 2));
    return holder.model;
};

gpii.test.cloudBased.oauth2.bootstrap = function (testDefs, commonRec, baseDir) {
    return kettle.test.bootstrapServer(testDefs, function (testDef) {
        return gpii.test.cloudBased.oauth2.buildMainSequenceFixture(testDef, commonRec, baseDir);
    });
};

gpii.test.cloudBased.oauth2.bootstrapDisruptedTest = function (testDefs, commonRec,
    disruptions, baseDir) {
    testDefs = fluid.makeArray(testDefs);
    return fluid.transform(disruptions, function (disruption) {
        return kettle.test.bootstrapServer(testDefs, function (testDef) {
            return gpii.test.cloudBased.oauth2.buildDisruptedFixture(testDef, commonRec, disruption, baseDir);
        });
    });
};
