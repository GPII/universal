/**
GPII Mock Definitions for all platform-specific components

Copyright 2017 Raising the Floor - International
Copyright 2013 OCAD University
Copyright 2014 Lucendo Development Ltd.

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

The research leading to these results has received funding from the European Union's
Seventh Framework Programme (FP7/2007-2013) under grant agreement no. 289016.

You may obtain a copy of the License at
https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

"use strict";

var fluid = fluid || require("infusion"),
    gpii = fluid.registerNamespace("gpii");

fluid.defaults("gpii.test.common.exec", {
    gradeNames: ["fluid.component"],
    events: {
        onExecExit: null
    },
    invokers: {
//        exec:
    }
});

// Maintains a mock model of currently executing processes
fluid.defaults("gpii.test.integration.exec", {
    gradeNames: ["gpii.test.common.exec"],
    members: {
        processModel: [] // list of process objects
    },
    invokers: {
        exec: {
            funcName: "gpii.test.integration.exec.exec",
            args: ["{that}", "{arguments}.0", "{arguments}.1"]
        }
    }
});

gpii.test.integration.exec.exec = function (that, processSpec /*, expected */) {
    // TODO: actually determine that the required process was started using the mock model
    that.events.onExecExit.fire(true, processSpec);
};

fluid.defaults("gpii.test.integration.mockHolder", {
    gradeNames: "fluid.component",
    // TODO: Namespace these distributions so they can be overridden
    distributeOptions: [{
        record: {
            funcName: null,
            func: "{gpii.test.integration.mockHolder}.nameResolver.resolveName"
        },
        target: "{that lifecycleManager > nameResolver}.options.invokers.resolveName"
    }, {
        record: { // TODO: appears that this distribution has always been broken
            funcName: null,
            func: "{gpii.test.integration.deviceReporterAware}.resolveName"
        },
        target: "{that deviceReporter > nameResolver}.options.invokers.resolveName"
    }, {
        record: {
            funcName: null,
            func: "{gpii.test.integration.mockHolder}.mockPlatformReporter.reportPlatform"
        },
        target: "{that deviceReporter platformReporter}.options.invokers.reportPlatform"
    }, {
        target: "{that lifecycleManager > variableResolver}.options.components.resolverConfig.type",
        record: "gpii.test.integration.standardResolverConfig"
    }],
    components: {
        exec: {
            type: "gpii.test.integration.exec"
        },
        mockSettingsHandlers: {
            type: "gpii.test.integration.mockSettingsHandlerRegistry.universal"
        },
        mockDeviceReporters: {
            type: "gpii.test.integration.deviceReporterAware"
        },
        nameResolver: {
            type: "fluid.component",
            options: {
                invokers: {
                    resolveName: {
                        funcName: "gpii.test.integration.resolveName",
                        args: ["{mockSettingsHandlers}", "{mockDeviceReporters}", "{arguments}.0", "{arguments}.1"]
                    }
                }
            }
        }
    }
});

fluid.defaults("gpii.test.integration.standardResolverConfig", {
    gradeNames: "fluid.component",
    resolvers: {
        environment: "gpii.test.integration.environmentResolver"
    }
});


// Return the environment variable name unmodified
gpii.test.integration.environmentResolver = fluid.identity;

fluid.defaults("gpii.test.integration.mockHolder.windows", {
    gradeNames: ["gpii.test.integration.mockHolder"],
    components: {
        mockSettingsHandlers: {
            type: "gpii.test.integration.mockSettingsHandlerRegistry.windows"
        },
        mockPlatformReporter: {
            type: "gpii.test.integration.mockPlatformReporter",
            options: {
                platform: {
                    id: "win32",
                    version: "6.1.7601"
                }
            }
        }
    }
});


fluid.defaults("gpii.test.integration.mockHolder.linux", {
    gradeNames: ["gpii.test.integration.mockHolder"],
    components: {
        mockSettingsHandlers: {
            type: "gpii.test.integration.mockSettingsHandlerRegistry.linux"
        },
        mockPlatformReporter: {
            type: "gpii.test.integration.mockPlatformReporter",
            options: {
                platform: {
                    id: "linux",
                    version: "2.6.26"
                }
            }
        }
    }
});

fluid.defaults("gpii.test.integration.mockHolder.android", {
    gradeNames: ["gpii.test.integration.mockHolder"],
    components: {
        mockSettingsHandlers: {
            type: "gpii.test.integration.mockSettingsHandlerRegistry.android"
        },
        mockPlatformReporter: {
            type: "gpii.test.integration.mockPlatformReporter",
            options: {
                platform: {
                    id: "android",
                    version: "3.0.31"
                }
            }
        }
    }
});

fluid.defaults("gpii.test.integration.mockPlatformReporter", {
    gradeNames: ["fluid.component"],
    invokers: {
        reportPlatform: {
            funcName: "fluid.identity",
            args: "{that}.options.platform"
        }
    }
});


gpii.test.integration.mockExecHandler = function (command, args) {
    // TODO: we should record the executing process in a process model - ideally we should have a more reliable model of extracting what it is
    fluid.log("Mock exec handler for command ", command, " args ", args);
};

fluid.defaults("gpii.test.integration.mockExecHandler", {
    gradeNames: "fluid.function",
    argumentMap: {
        command: 0,
        args: 1
    }
});

gpii.test.integration.resolveName = function (settingsHandlerRegistry, deviceReporterAware, name, category) {
    if (category === "settingsHandler") {
        return settingsHandlerRegistry.resolveName(name);
    } else if (category === "deviceReporter") {
        return deviceReporterAware.resolveName(name);
    } else {
        return "gpii.test.integration.mockExecHandler";
    }
};

// cf. much less sophisticated mock in LifecycleManagerTest.js
fluid.defaults("gpii.test.integration.mockSettingsHandler", {
    gradeNames: ["fluid.component"],
    members: {
        settingsStore: {}
    },
    async: false,
    // must be configured for each settingsHandler instance to resolve to a path within
    // the options structure which determines a unique key for the particular payload
    // can also resolve to a function which returns such a key given the options
    optionsPathKey: null,
    invokers: {
        set: {
            funcName: "gpii.test.integration.mockSettingsHandler.set",
            args: ["{that}", "{arguments}.0"]
        },
        setImpl: {
            funcName: "gpii.test.integration.mockSettingsHandler.setImpl",
            args: ["{that}", "{arguments}.0", "{arguments}.1"]
                             // set payload, solutionId
        },
        get: {
            funcName: "gpii.test.integration.mockSettingsHandler.get",
            args: ["{that}", "{arguments}.0"]
        },
        getImpl: {
            funcName: "gpii.test.integration.mockSettingsHandler.getImpl",
            args: ["{that}", "{arguments}.0", "{arguments}.1"]
                             // get payload, solutionId
        }
    }
});

gpii.test.integration.resolveHandlerKey = function (that, payload, solutionId) {
    var pathKey = that.options.optionsPathKey;
    if (typeof(pathKey) === "string") {
        return fluid.get(payload.options, pathKey);
    } else if (typeof(pathKey) === "function") {
        return pathKey(payload.options, solutionId);
    }
};

gpii.test.integration.mockSettingsHandler.applySettings = function (store, settings) {
    fluid.each(settings, function (value, key) {
        if (value === undefined) {
            delete store[key];
        } else {
            store[key] = value;
        }
    });
};

gpii.test.integration.mockSettingsHandler.makeSetReturn = function (oldStore, settings) {
    return fluid.transform(settings, function (value, key) {
        return {
            oldValue: oldStore[key],
            value: value
        };
    });
};

gpii.test.integration.mockSettingsHandler.returnAsyncResponse = function (value, isAsync) {
    if (isAsync) {
        var togo = fluid.promise();
        gpii.invokeLater(function () {
            togo.resolve(value);
        }, 100);
        return togo;
    } else {
        return value;
    }
};

gpii.test.integration.mockSettingsHandler.setImpl = function (that, payload, solutionId) {
    var setSettings = function () {
        var key = gpii.test.integration.resolveHandlerKey(that, payload, solutionId);
        var oldStore = fluid.copy(that.settingsStore[key]) || {};
        var store = (that.settingsStore[key] = that.settingsStore[key] || {});
        gpii.test.integration.mockSettingsHandler.applySettings(store, payload.settings);

        return gpii.test.integration.mockSettingsHandler.makeSetReturn(oldStore, payload.settings);
    };
    var togo = gpii.test.integration.mockSettingsHandler.returnAsyncResponse(setSettings(), that.options.async);
    return togo;
};

gpii.test.integration.mockSettingsHandler.set = function (that, payload) {
    return gpii.settingsHandlers.invokeSettingsHandler(that.setImpl, payload);
};

gpii.test.integration.mockSettingsHandler.getImpl = function (that, payload, solutionId) {
    var key = gpii.test.integration.resolveHandlerKey(that, payload, solutionId);
    var store = that.settingsStore[key] || {};
    var response = fluid.transform(payload.settings, function (value, key) {
        return store[key];
    });
    var togo = gpii.test.integration.mockSettingsHandler.returnAsyncResponse(response, that.options.asyncGet);
    return togo;
};

gpii.test.integration.mockSettingsHandler.get = function (that, payload) {
    return gpii.settingsHandlers.invokeSettingsHandler(that.getImpl, payload);
};

// The platform-specific registry of mock settings handlers

gpii.test.integration.registrySettingsHandlerKey = function (options) {
    return options.hKey + "|" + options.path;
};

gpii.test.integration.flexibleHandlerKey = function (options, solutionId) {
    return solutionId + ".flexibleHandler";
};

gpii.test.integration.gsettingsLaunchKey = function (options) {
    return options.schema + "|" + options.key;
};

fluid.defaults("gpii.test.integration.mockSettingsHandlerRegistry", {
    gradeNames: ["fluid.component"],
    rootPath: "gpii.test.integration.mockSettingsHandlers", // the global names for mocks will be deposited in here
    members: {
        settingsHandlers: {}
    },
    invokers: {
        resolveName: {
            funcName: "gpii.test.integration.mockSettingsHandlerRegistry.resolveName",
            args: ["{that}", "{arguments}.0"]
        }
    },
    listeners: {
        "onCreate.populate": "gpii.test.integration.mockSettingsHandlerRegistry.populate"
    }
});

gpii.test.integration.mockSettingsHandlers = {};

gpii.test.integration.mockSettingsHandlerRegistry.populateOne = function (that, mock, key) {
    that.settingsHandlers[key] = mock;
    // Mount the mock handler at a global path
    var setPath = that.options.rootPath + "." + key + ".set";
    fluid.setGlobalValue(setPath, mock.set);
    fluid.setGlobalValue(that.options.rootPath + "." + key + ".get", mock.get);
};

gpii.test.integration.mockSettingsHandlerRegistry.populate = function (that) {
    fluid.each(that.options.settingsHandlers, function (options, key) {
        var mock = options.noMock ?
            fluid.getGlobalValue(key) : gpii.test.integration.mockSettingsHandler(options);
        gpii.test.integration.mockSettingsHandlerRegistry.populateOne(that, mock, key);
    });
};

gpii.test.integration.mockSettingsHandlerRegistry.resolveName = function (that, name) {
    var mock = that.settingsHandlers[name];
    if (!mock) {
        var registered = fluid.keys(that.settingsHandlers).join(", ");
        fluid.fail("Error in settings handler mock configuration - handler " + name +
            " is not registered - registered handlers are " + registered);
    } else {
        return that.options.rootPath + "." + name;
    }
};

fluid.defaults("gpii.test.integration.mockSettingsHandlerRegistry.universal", {
    gradeNames: ["gpii.test.integration.mockSettingsHandlerRegistry"],
    settingsHandlers: {
        "gpii.settingsHandlers.INISettingsHandler": {
            optionsPathKey: "filename"
        },
        "gpii.settingsHandlers.XMLHandler": {
            optionsPathKey: "filename"
        },
        "gpii.settingsHandlers.JSONSettingsHandler": {
            optionsPathKey: "filename"
        },
        "gpii.launchHandlers.flexibleHandler": {
            optionsPathKey: gpii.test.integration.flexibleHandlerKey
        },
        "gpii.settingsHandlers.webSockets" : {},
        "gpii.settingsHandlers.noSettings": {},
        "gpii.settingsHandlers.exploding": {
            noMock: true
        }
    }
});

fluid.defaults("gpii.test.integration.mockSettingsHandlerRegistry.windows", {
    gradeNames: ["gpii.test.integration.mockSettingsHandlerRegistry.universal"],
    settingsHandlers: {
        "gpii.windows.registrySettingsHandler": {
            optionsPathKey: gpii.test.integration.registrySettingsHandlerKey
        },
        "gpii.windows.spiSettingsHandler": {
            // delaying: true,
            optionsPathKey: "setAction"
        },
        "gpii.windows.displaySettingsHandler": {},
        "gpii.windows.enableRegisteredAT": {
            optionsPathKey: "registryName"
        },
        "gpii.windows.systemSettingsHandler": {},
        "gpii.windows.wmiSettingsHandler": {},
        "gpii.windows.nativeSettingsHandler": {
            optionsPathKey: "functionName"
        }
    }
});

fluid.defaults("gpii.test.integration.mockSettingsHandlerRegistry.linux", {
    gradeNames: ["gpii.test.integration.mockSettingsHandlerRegistry.universal"],
    settingsHandlers: {
        "gpii.gsettings": {
            optionsPathKey: "schema"
        },
        "gpii.orca": {
            async: true,
            asyncGet: true,
            optionsPathKey: "user"
        },
        "gpii.alsa": {
            optionsPathKey: "NONE"
        },
        "gpii.xrandr": {
            optionsPathKey: "NONE"
        },
        "gpii.gsettings.launch": {
            optionsPathKey: gpii.test.integration.gsettingsLaunchKey
        }
    }
});

fluid.defaults("gpii.test.integration.mockSettingsHandlerRegistry.android", {
    gradeNames: ["gpii.test.integration.mockSettingsHandlerRegistry.universal"],
    settingsHandlers: {
        "gpii.androidSettings": {
            optionsPathKey: "settingType"
        },
        "gpii.androidAudioManager.volume": {
            optionsPathKey: "NONE"
        },
        "gpii.androidPersistentConfiguration": {
            optionsPathKey: "NONE"
        }
    }
});

fluid.defaults("gpii.test.integration.deviceReporterAware", {
    gradeNames: ["fluid.component"],
    rootPath: "gpii.test.integration.deviceReporterAware.mockDeviceReporters",
    members: {
        mockDeviceReporters: {},
        deviceReporters: {}
    },
    invokers: {
        resolveName: {
            funcName: "gpii.test.integration.deviceReporterAware.resolveName",
            args: ["{that}", "{arguments}.0"]
        }
    },
    listeners: {
        onCreate: "gpii.test.integration.deviceReporterAware.populate"
    }
});

gpii.test.integration.deviceReporterAware.mockDeviceReporters = {};

gpii.test.integration.deviceReporterAware.mockDeviceReporters.findNameInList = function (expectInstalled, name) {
    return expectInstalled.some(function (el) { return el === name; });
};

gpii.test.integration.deviceReporterAware.mockDeviceReporters.registryKeyExists = function (expectInstalled, hKey, path, subPath) {
    return expectInstalled.some(function (el) {
        return el.hKey === hKey && el.path === path && el.subPath === subPath;
    });
};

gpii.test.integration.deviceReporterAware.populate = function (that) {
    fluid.each(that.options.deviceReporters, function (options, key) {
        var mock = that.options.mockDeviceReporters[key];

        if (!mock) {
            var registered = fluid.keys(that.options.mockDeviceReporters).join(", ");
            fluid.fail("Error in dynamic device reporter mock configuration - handler " + key +
                " is not registered - registered handlers are " + registered);
        }

        var expectInstalled = [];
        fluid.each(that.options.deviceReporters[key].expectInstalled, function (item) {
            expectInstalled.push(item);
        });

        fluid.defaults(that.options.rootPath + "." + key, mock.defaults);

        var mockedFunction = gpii.test.integration.deviceReporterAware.mockDeviceReporters[mock.mockFunc].bind(undefined, expectInstalled);
        fluid.setGlobalValue(that.options.rootPath + "." + key, mockedFunction);
    });
};

gpii.test.integration.deviceReporterAware.resolveName = function (that, name) {
    var resolvedName;

    if (name === "gpii.deviceReporter.alwaysInstalled") {
        resolvedName = name;
    } else {
        resolvedName = that.options.rootPath + "." + name;
    }

    return resolvedName;
};

fluid.defaults("gpii.test.integration.deviceReporterAware.linux", {
    gradeNames: ["gpii.test.integration.deviceReporterAware"],
    mockDeviceReporters: {
        "gpii.packageKit.find": {
            mockFunc: "findNameInList",
            defaults: {
                gradeNames: "fluid.function",
                argumentMap: {
                    name: 0
                }
            }
        }
    }
});

fluid.defaults("gpii.test.integration.deviceReporterAware.windows", {
    gradeNames: "gpii.test.integration.deviceReporterAware",
    mockDeviceReporters: {
        "gpii.deviceReporter.registryKeyExists": {
            mockFunc: "registryKeyExists",
            defaults: {
                gradeNames: "fluid.function",
                argumentMap: {
                    hKey: 0,
                    path: 1,
                    subPath: 2
                }
            }
        }
    }
});
