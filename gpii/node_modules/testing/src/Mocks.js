/**
GPII Mock Definitions for all platform-specific components

Copyright 2017 Raising the Floor - International
Copyright 2013 OCAD University
Copyright 2014 Lucendo Development Ltd.

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

The research leading to these results has received funding from the European Union's
Seventh Framework Programme (FP7/2007-2013) under grant agreement no. 289016.

You may obtain a copy of the License at
https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

"use strict";

var fluid = fluid || require("infusion"),
    gpii = fluid.registerNamespace("gpii");

fluid.defaults("gpii.test.common.exec", {
    gradeNames: ["fluid.component"],
    events: {
        onExecExit: null
    },
    invokers: {
//        exec:
    }
});

// Maintains a mock model of currently executing processes
fluid.defaults("gpii.test.integration.exec", {
    gradeNames: ["gpii.test.common.exec"],
    members: {
        processModel: [] // list of process objects
    },
    invokers: {
        exec: {
            funcName: "gpii.test.integration.exec.exec",
            args: ["{that}", "{arguments}.0", "{arguments}.1"]
        }
    }
});

gpii.test.integration.exec.exec = function (that, processSpec /*, expected */) {
    // TODO: actually determine that the required process was started using the mock model
    that.events.onExecExit.fire(true, processSpec);
};

fluid.defaults("gpii.test.integration.mockHolder", {
    gradeNames: "fluid.component",
    // TODO: Namespace these distributions so they can be overridden
    distributeOptions: [{
        record: {
            funcName: null,
            func: "{gpii.test.integration.mockHolder}.nameResolver.resolveName"
        },
        target: "{that lifecycleManager > nameResolver}.options.invokers.resolveName"
    }, {
        source: "{that}.options.deviceReporters",
        target: "{that gpii.test.integration.mockDeviceReporters}.options.deviceReporters"
    }, {
        record: { // Note, contrary to the previous comment at this site, this distribution is essential
            funcName: null,
            func: "{gpii.test.integration.mockDeviceReporters}.resolveName"
        },
        target: "{that deviceReporter > nameResolver}.options.invokers.resolveName"
    }, {
        record: {
            funcName: null,
            func: "{gpii.test.integration.mockHolder}.mockPlatformReporter.reportPlatform"
        },
        target: "{that deviceReporter platformReporter}.options.invokers.reportPlatform"
    }, {
        target: "{that lifecycleManager > variableResolver}.options.components.resolverConfig.type",
        record: "gpii.test.integration.standardResolverConfig"
    }],
    components: {
        exec: {
            type: "gpii.test.integration.exec"
        },
        mockSettingsHandlers: {
            type: "gpii.test.integration.mockSettingsHandlerRegistry.universal"
        },
        mockActionHandlers: {
            type: "gpii.test.integration.mockActionHandlers"
        },
        mockDeviceReporters: {
            type: "gpii.test.integration.mockDeviceReporters"
        },
        nameResolver: {
            type: "fluid.component",
            options: {
                invokers: {
                    resolveName: {
                        funcName: "gpii.test.integration.resolveName",
                        args: ["{mockSettingsHandlers}", "{mockDeviceReporters}", "{mockActionHandlers}", "{arguments}.0", "{arguments}.1"]
                    }
                }
            }
        }
    }
});

fluid.defaults("gpii.test.integration.standardResolverConfig", {
    gradeNames: "fluid.component",
    resolvers: {
        environment: "gpii.test.integration.environmentResolver"
    }
});


// Return the environment variable name unmodified
gpii.test.integration.environmentResolver = fluid.identity;

fluid.defaults("gpii.test.integration.mockHolder.windows", {
    gradeNames: ["gpii.test.integration.mockHolder"],
    components: {
        mockSettingsHandlers: {
            type: "gpii.test.integration.mockSettingsHandlerRegistry.windows"
        },
        mockPlatformReporter: {
            type: "gpii.test.integration.mockPlatformReporter",
            options: {
                platform: {
                    id: "win32",
                    version: "6.1.7601"
                }
            }
        },
        mockActionsHandlers: {
            type: "gpii.test.integration.mockActionHandlers.windows"
        },
        mockDeviceReporters: {
            type: "gpii.test.integration.mockDeviceReporters.windows"
        }
    }
});


fluid.defaults("gpii.test.integration.mockHolder.linux", {
    gradeNames: ["gpii.test.integration.mockHolder"],
    components: {
        mockSettingsHandlers: {
            type: "gpii.test.integration.mockSettingsHandlerRegistry.linux"
        },
        mockPlatformReporter: {
            type: "gpii.test.integration.mockPlatformReporter",
            options: {
                platform: {
                    id: "linux",
                    version: "2.6.26"
                }
            }
        },
        mockActionsHandlers: {
            type: "gpii.test.integration.mockActionHandlers"
        },
        mockDeviceReporters: {
            type: "gpii.test.integration.mockDeviceReporters.linux"
        }
    }
});

fluid.defaults("gpii.test.integration.mockHolder.android", {
    gradeNames: ["gpii.test.integration.mockHolder"],
    components: {
        mockSettingsHandlers: {
            type: "gpii.test.integration.mockSettingsHandlerRegistry.android"
        },
        mockPlatformReporter: {
            type: "gpii.test.integration.mockPlatformReporter",
            options: {
                platform: {
                    id: "android",
                    version: "3.0.31"
                }
            }
        }
    }
});

fluid.defaults("gpii.test.integration.mockPlatformReporter", {
    gradeNames: ["fluid.component"],
    invokers: {
        reportPlatform: {
            funcName: "fluid.identity",
            args: "{that}.options.platform"
        }
    }
});


gpii.test.integration.mockExecHandler = function (command, args) {
    // TODO: we should record the executing process in a process model - ideally we should have a more reliable model of extracting what it is
    fluid.log("Mock exec handler for command ", command, " args ", args);
};

fluid.defaults("gpii.test.integration.mockExecHandler", {
    gradeNames: "fluid.function",
    argumentMap: {
        command: 0,
        args: 1
    }
});

gpii.test.integration.resolveName = function (settingsHandlerRegistry, mockDeviceReporters, mockActionHandlers, name, category) {
    if (category === "settingsHandler") {
        return settingsHandlerRegistry.resolveName(name);
    } else if (category === "deviceReporter") {
        return mockDeviceReporters.resolveName(name);
    } else if (category === "action") {
        return mockActionHandlers.resolveName(name);
    } else {
        return "gpii.test.integration.mockExecHandler";
    }
};

// cf. much less sophisticated mock in LifecycleManagerTest.js
fluid.defaults("gpii.test.integration.mockSettingsHandler", {
    gradeNames: ["fluid.component"],
    members: {
        settingsStore: {}
    },
    async: false,
    // must be configured for each settingsHandler instance to resolve to a path within
    // the options structure which determines a unique key for the particular payload
    // can also resolve to a function which returns such a key given the options
    optionsPathKey: null,
    invokers: {
        set: {
            funcName: "gpii.test.integration.mockSettingsHandler.set",
            args: ["{that}", "{arguments}.0"]
        },
        setImpl: {
            funcName: "gpii.test.integration.mockSettingsHandler.setImpl",
            args: ["{that}", "{arguments}.0", "{arguments}.1"]
                             // set payload, solutionId
        },
        get: {
            funcName: "gpii.test.integration.mockSettingsHandler.get",
            args: ["{that}", "{arguments}.0"]
        },
        getImpl: {
            funcName: "gpii.test.integration.mockSettingsHandler.getImpl",
            args: ["{that}", "{arguments}.0", "{arguments}.1"]
                             // get payload, solutionId
        }
    }
});

gpii.test.integration.resolveHandlerKey = function (that, payload, solutionId) {
    var pathKey = that.options.optionsPathKey;
    if (typeof(pathKey) === "string") {
        return fluid.get(payload.options, pathKey);
    } else if (typeof(pathKey) === "function") {
        return pathKey(payload.options, solutionId);
    }
};

gpii.test.integration.mockSettingsHandler.applySettings = function (store, settings) {
    fluid.each(settings, function (value, key) {
        if (value === undefined) {
            delete store[key];
        } else {
            store[key] = value;
        }
    });
};

gpii.test.integration.mockSettingsHandler.makeSetReturn = function (oldStore, settings) {
    return fluid.transform(settings, function (value, key) {
        return {
            oldValue: oldStore[key],
            value: value
        };
    });
};

gpii.test.integration.mockSettingsHandler.returnAsyncResponse = function (value, isAsync) {
    if (isAsync) {
        var togo = fluid.promise();
        gpii.invokeLater(function () {
            togo.resolve(value);
        }, 100);
        return togo;
    } else {
        return value;
    }
};

gpii.test.integration.mockSettingsHandler.setImpl = function (that, payload, solutionId) {
    var setSettings = function () {
        var key = gpii.test.integration.resolveHandlerKey(that, payload, solutionId);
        var oldStore = fluid.copy(that.settingsStore[key]) || {};
        var store = (that.settingsStore[key] = that.settingsStore[key] || {});
        gpii.test.integration.mockSettingsHandler.applySettings(store, payload.settings);

        return gpii.test.integration.mockSettingsHandler.makeSetReturn(oldStore, payload.settings);
    };
    var togo = gpii.test.integration.mockSettingsHandler.returnAsyncResponse(setSettings(), that.options.async);
    return togo;
};

gpii.test.integration.mockSettingsHandler.set = function (that, payload) {
    return gpii.settingsHandlers.invokeSettingsHandler(that.setImpl, payload);
};

gpii.test.integration.mockSettingsHandler.getImpl = function (that, payload, solutionId) {
    var key = gpii.test.integration.resolveHandlerKey(that, payload, solutionId);
    var store = that.settingsStore[key] || {};
    var response = fluid.transform(payload.settings, function (value, key) {
        return store[key];
    });
    var togo = gpii.test.integration.mockSettingsHandler.returnAsyncResponse(response, that.options.asyncGet);
    return togo;
};

gpii.test.integration.mockSettingsHandler.get = function (that, payload) {
    return gpii.settingsHandlers.invokeSettingsHandler(that.getImpl, payload);
};

// The platform-specific registry of mock settings handlers

gpii.test.integration.registrySettingsHandlerKey = function (options) {
    return options.hKey + "|" + options.path;
};

gpii.test.integration.JAWSSettingsHandlerKey = function (options) {
    return options.filename + "|" + options.foldername;
};

gpii.test.integration.flexibleHandlerKey = function (options, solutionId) {
    return solutionId + ".flexibleHandler";
};

gpii.test.integration.gsettingsLaunchKey = function (options) {
    return options.schema + "|" + options.key;
};

fluid.defaults("gpii.test.integration.mockSettingsHandlerRegistry", {
    gradeNames: ["fluid.component"],
    rootPath: "gpii.test.integration.mockSettingsHandlers", // the global names for mocks will be deposited in here
    members: {
        settingsHandlers: {}
    },
    invokers: {
        resolveName: {
            funcName: "gpii.test.integration.mockSettingsHandlerRegistry.resolveName",
            args: ["{that}", "{arguments}.0"]
        }
    },
    listeners: {
        "onCreate.populate": "gpii.test.integration.mockSettingsHandlerRegistry.populate",
        "onDestroy.depopulate": "gpii.test.integration.mockSettingsHandlerRegistry.depopulate"
    }
});

gpii.test.integration.mockSettingsHandlers = {};

gpii.test.integration.mockSettingsHandlerRegistry.populateOne = function (that, mock, key) {
    that.settingsHandlers[key] = mock;
    // Mount the mock handler at a global path
    var setPath = that.options.rootPath + "." + key + ".set";
    fluid.setGlobalValue(setPath, mock.set);
    fluid.setGlobalValue(that.options.rootPath + "." + key + ".get", mock.get);
};

gpii.test.integration.mockSettingsHandlerRegistry.depopulate = function (that) {
    fluid.each(that.settingsHandlers, function (settingsHandler) {
        if (fluid.isComponent(settingsHandler)) {
            settingsHandler.destroy();
        }
    });
    fluid.setGlobalValue(that.options.rootPath, {});
};

gpii.test.integration.mockSettingsHandlerRegistry.populate = function (that) {
    fluid.each(that.options.settingsHandlers, function (options, key) {
        var mock = options.noMock ?
            fluid.getGlobalValue(key) : gpii.test.integration.mockSettingsHandler(options);
        gpii.test.integration.mockSettingsHandlerRegistry.populateOne(that, mock, key);
    });
};

gpii.test.integration.mockSettingsHandlerRegistry.resolveName = function (that, name) {
    var mock = that.settingsHandlers[name];
    if (!mock) {
        var registered = fluid.keys(that.settingsHandlers).join(", ");
        fluid.fail("Error in settings handler mock configuration - handler " + name +
            " is not registered - registered handlers are " + registered);
    } else {
        return that.options.rootPath + "." + name;
    }
};

fluid.defaults("gpii.test.integration.mockSettingsHandlerRegistry.universal", {
    gradeNames: ["gpii.test.integration.mockSettingsHandlerRegistry"],
    settingsHandlers: {
        "gpii.settingsHandlers.INISettingsHandler": {
            optionsPathKey: "filename"
        },
        "gpii.settingsHandlers.JAWSSettingsHandler": {
            optionsPathKey: gpii.test.integration.JAWSSettingsHandlerKey
        },
        "gpii.settingsHandlers.XMLHandler": {
            optionsPathKey: "filename"
        },
        "gpii.settingsHandlers.JSONSettingsHandler": {
            optionsPathKey: "filename"
        },
        "gpii.launchHandlers.flexibleHandler": {
            optionsPathKey: gpii.test.integration.flexibleHandlerKey
        },
        "gpii.settingsHandlers.webSockets" : {},
        "gpii.settingsHandlers.noSettings": {},
        "gpii.settingsHandlers.exploding": {
            noMock: true
        }
    }
});

fluid.defaults("gpii.test.integration.mockSettingsHandlerRegistry.windows", {
    gradeNames: ["gpii.test.integration.mockSettingsHandlerRegistry.universal"],
    settingsHandlers: {
        "gpii.windows.registrySettingsHandler": {
            optionsPathKey: gpii.test.integration.registrySettingsHandlerKey
        },
        "gpii.windows.spiSettingsHandler": {
            // delaying: true,
            optionsPathKey: "setAction"
        },
        "gpii.windows.displaySettingsHandler": {},
        "gpii.windows.enableRegisteredAT": {
            optionsPathKey: "registryName"
        },
        "gpii.windows.systemSettingsHandler": {},
        "gpii.windows.wmiSettingsHandler": {},
        "gpii.windows.nativeSettingsHandler": {
            optionsPathKey: "functionName"
        }
    }
});

fluid.defaults("gpii.test.integration.mockSettingsHandlerRegistry.linux", {
    gradeNames: ["gpii.test.integration.mockSettingsHandlerRegistry.universal"],
    settingsHandlers: {
        "gpii.gsettings": {
            optionsPathKey: "schema"
        },
        "gpii.orca": {
            async: true,
            asyncGet: true,
            optionsPathKey: "user"
        },
        "gpii.alsa": {
            optionsPathKey: "NONE"
        },
        "gpii.xrandr": {
            optionsPathKey: "NONE"
        },
        "gpii.gsettings.launch": {
            optionsPathKey: gpii.test.integration.gsettingsLaunchKey
        }
    }
});

fluid.defaults("gpii.test.integration.mockSettingsHandlerRegistry.android", {
    gradeNames: ["gpii.test.integration.mockSettingsHandlerRegistry.universal"],
    settingsHandlers: {
        "gpii.androidSettings": {
            optionsPathKey: "settingType"
        },
        "gpii.androidAudioManager.volume": {
            optionsPathKey: "NONE"
        },
        "gpii.androidPersistentConfiguration": {
            optionsPathKey: "NONE"
        }
    }
});

fluid.defaults("gpii.test.integration.mockDeviceReporters", {
    gradeNames: ["fluid.component"],
    rootPath: "gpii.test.integration.mockDeviceReporterRegistry",
    invokers: {
        resolveName: {
            funcName: "gpii.test.integration.mockDeviceReporters.resolveName",
            args: ["{that}", "{arguments}.0"]
        }
    },
    listeners: {
        "onCreate.populate": "gpii.test.integration.mockDeviceReporters.populate",
        "onDestroy.depopulate": "gpii.test.integration.mockDeviceReporters.depopulate"
    }
});

fluid.registerNamespace("gpii.test.integration.mockDeviceReporterImpls");

gpii.test.integration.mockDeviceReporterImpls.findNameInList = function (expectInstalled, name) {
    return expectInstalled.some(function (el) { return el === name; });
};

gpii.test.integration.mockDeviceReporterImpls.registryKeyExists = function (expectInstalled, hKey, path, subPath) {
    return expectInstalled.some(function (el) {
        return el.hKey === hKey && el.path === path && el.subPath === subPath;
    });
};

gpii.test.integration.mockDeviceReporterImpls.wmiSettingSupported = function (expectInstalled, namespace, query) {
    return expectInstalled.some(function (el) {
        return el.namespace === namespace && el.query === query;
    });
};

gpii.test.integration.mockDeviceReporters.populate = function (that) {
    var backMocks = fluid.transform(that.options.mockDeviceReporters, function () {
        return {
            expectInstalled: []
        };
    });
    var devReporters = fluid.extend(backMocks, that.options.deviceReporters);
    fluid.each(devReporters, function (options, key) {
        var mock = that.options.mockDeviceReporters[key];
        if (!mock) {
            var registered = fluid.keys(that.options.mockDeviceReporters).join(", ");
            fluid.fail("Error in dynamic device reporter mock configuration - handler " + key +
                " is not registered - registered handlers are " + registered);
        }

        fluid.defaults(that.options.rootPath + "." + key, mock.defaults);
        var mockFunc = fluid.getGlobalValue(mock.mockFunc);

        var mockedFunction = mockFunc.bind(undefined, options.expectInstalled);
        fluid.setGlobalValue(that.options.rootPath + "." + key, mockedFunction);
    });
};

gpii.test.integration.mockDeviceReporters.depopulate = function (that) {
    // mock deviceReporters are not components and so do not need destruction
    fluid.setGlobalValue(that.options.rootPath, {});
};

gpii.test.integration.mockDeviceReporters.resolveName = function (that, name) {
    var resolvedName;

    if (name === "gpii.deviceReporter.alwaysInstalled") {
        resolvedName = name;
    } else {
        resolvedName = that.options.rootPath + "." + name;
    }

    return resolvedName;
};

fluid.defaults("gpii.test.integration.mockDeviceReporters.linux", {
    gradeNames: ["gpii.test.integration.mockDeviceReporters"],
    mockDeviceReporters: {
        "gpii.packageKit.find": {
            mockFunc: "gpii.test.integration.mockDeviceReporterImpls.findNameInList",
            defaults: {
                gradeNames: "fluid.function",
                argumentMap: {
                    name: 0
                }
            }
        }
    }
});

fluid.defaults("gpii.test.integration.mockDeviceReporters.windows", {
    gradeNames: "gpii.test.integration.mockDeviceReporters",
    mockDeviceReporters: {
        "gpii.deviceReporter.registryKeyExists": {
            mockFunc: "gpii.test.integration.mockDeviceReporterImpls.registryKeyExists",
            defaults: {
                gradeNames: "fluid.function",
                argumentMap: {
                    hKey: 0,
                    path: 1,
                    subPath: 2
                }
            }
        },
        "gpii.deviceReporter.wmiSettingSupported": {
            mockFunc: "gpii.test.integration.mockDeviceReporterImpls.wmiSettingSupported",
            defaults: {
                gradeNames: "fluid.function",
                argumentMap: {
                    namespace: 0,
                    query: 1
                }
            }
        }
    }
});

fluid.defaults("gpii.test.integration.mockActionHandlers", {
    gradeNames: ["fluid.component"],
    rootPath: "gpii.test.integration.mockActionsHandlerRegistry",
    invokers: {
        resolveName: {
            funcName: "gpii.test.integration.mockActionHandlers.resolveName",
            args: ["{that}", "{arguments}.0"]
        }
    },
    listeners: {
        "onCreate.populate": "gpii.test.integration.mockActionHandlers.populate",
        "onDestroy.depopulate": "gpii.test.integration.mockActionHandlers.depopulate"
    }
});


gpii.test.integration.mockActionHandlers.populate = function (that) {
    fluid.each(that.options.mockActionHandlers, function (actionHandler, key) {
        var mountName = that.options.rootPath + "." + key;
        fluid.defaults(mountName, actionHandler.defaults);

        var mockedFunction = fluid.getGlobalValue(actionHandler.mockFunc);
        if (!mockedFunction) {
            fluid.fail("Error populating mock action handler for ", actionHandler, ": mock function " + actionHandler.mockFunc
            + " could not be located");
        }
        fluid.setGlobalValue(mountName, mockedFunction);
    });
};

gpii.test.integration.mockActionHandlers.depopulate = function (that) {
    // mock actionHandlers are not components and so do not need destruction
    fluid.setGlobalValue(that.options.rootPath, {});
};

gpii.test.integration.mockActionHandlers.resolveName = function (that, name) {
    var resolvedName = that.options.rootPath + "." + name;
    return resolvedName;
};

fluid.defaults("gpii.test.integration.mockActionHandlers.windows", {
    gradeNames: "gpii.test.integration.mockActionHandlers",
    mockActionHandlers: {
        "gpii.windows.spiSettingsHandler.setHighContrastTheme": {
            mockFunc: "fluid.identity",
            defaults: {
                gradeNames: "fluid.function",
                argumentMap: {
                    newTheme: 0,
                    currentTheme: 1,
                    saveAs: 2
                }
            }
        },
        "gpii.windows.spiSettingsHandler.applyCustomTheme": {
            mockFunc: "fluid.identity",
            defaults: {
                gradeNames: "fluid.function",
                argumentMap: {
                    themeFile: 0,
                    allThemes: 1
                }
            }
        },
        "gpii.windows.updateLanguage": {
            mockFunc: "fluid.identity",
            defaults: {
                gradeNames: "fluid.function",
                argumentMap: {
                    currentLanguage: 0
                }
            }
        }
    }
});
