/*!
GPII Cloud-based Flow Manager with OAuth2 Test Infrastructure

Copyright 2012 OCAD University
Copyright 2012 Antranig Basman
Copyright 2013 Raising the Floor
Copyright 2014 Lucendo Development Ltd.
Copyright 2015-2018 OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

"use strict";

var fluid = require("infusion"),
    querystring = require("querystring"),
    gpii = fluid.registerNamespace("gpii"),
    jqUnit = fluid.registerNamespace("jqUnit");

fluid.registerNamespace("gpii.test.cloudBased.oauth2");

// Cache for storing access tokens
gpii.test.cloudBased.oauth2.accessTokenCache = [];
gpii.test.cloudBased.oauth2.addAccessTokenToCache = function (aToken) {
    gpii.test.cloudBased.oauth2.accessTokenCache.push(aToken);
};
gpii.test.cloudBased.oauth2.clearAccessTokenCache = function () {
    gpii.test.cloudBased.oauth2.accessTokenCache.length = 0;
};

gpii.test.stringifyFormBody = function (formBody) {
    var encoded = fluid.transform(formBody, function (element) {
        return typeof(element) === "string" ? element : JSON.stringify(element);
    });
    return querystring.stringify(encoded);
};

gpii.test.verifyJSONResponse = function (body, request) {
    var response = request.nativeResponse;
    jqUnit.assertEquals("Should have received a 200 response", 200, response.statusCode);
    jqUnit.assertTrue("Should have received an JSON response type", response.headers["content-type"].indexOf("application/json") === 0);
    return JSON.parse(body);
};

gpii.test.verifyStatusCodeResponse = function (body, request, statusCode) {
    var response = request.nativeResponse;
    jqUnit.assertEquals("Should have received a " + statusCode + " response", statusCode, response.statusCode);
};

gpii.test.cloudBased.oauth2.sendRequest = function (request, options, formBody, filterName) {
    formBody = gpii.test.cloudBased.oauth2.filter(formBody, options, filterName);
    request.send(gpii.test.stringifyFormBody(formBody));
};

gpii.test.cloudBased.oauth2.verifyFieldInResponse = function (response, request, funcName, fieldName) {
    var fieldValue = fluid.get(response, fieldName);
    fluid.log(funcName + " Got " + fieldName + ": ", fieldValue);
    jqUnit.assertValue("Should have received " + fieldName, fieldValue);
    fluid.set(request, fieldName, fieldValue);
};

gpii.test.cloudBased.oauth2.sendResourceOwnerGpiiKeyAccessTokenRequest = function (accessTokenRequest, options) {
    var formBody = {
        grant_type: "password",
        client_id: options.client_id,
        client_secret: options.client_secret,
        username: options.username,
        password: options.password
    };
    gpii.test.cloudBased.oauth2.sendRequest(accessTokenRequest, options, formBody, "accessTokenForm");
};

gpii.test.cloudBased.oauth2.verifyResourceOwnerGpiiKeyAccessTokenInResponse = function (body, accessTokenRequest) {
    var response = gpii.test.verifyJSONResponse(body, accessTokenRequest);
    gpii.test.cloudBased.oauth2.verifyFieldInResponse(response, accessTokenRequest, "oauth2.verifyResourceOwnerGpiiKeyAccessTokenInResponse", "access_token");
    gpii.test.cloudBased.oauth2.verifyFieldInResponse(response, accessTokenRequest, "oauth2.verifyResourceOwnerGpiiKeyAccessTokenInResponse", "expiresIn");
    if (accessTokenRequest.access_token) {
        gpii.test.cloudBased.oauth2.addAccessTokenToCache(accessTokenRequest.access_token);
        fluid.log("Cached access token ", accessTokenRequest.access_token);
    }
    return response;
};

gpii.test.cloudBased.oauth2.sendRequestWithAccessToken = function (request, accessToken, data) {
    var securedHeader = {
        headers: {
            Authorization: "Bearer " + accessToken
        }
    };

    request.send(data ? data : null, securedHeader);
};

fluid.defaults("gpii.test.cloudBased.oauth2.testCaseHolder", {
    gradeNames: ["kettle.test.testCaseHolder"],
    selectedPreferences: {
        "": true
    },
    components: {
        accessTokenRequest: {
            type: "kettle.test.request.http",
            options: {
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded"
                },
                path: "/access_token",
                port: 8081,
                method: "POST"
            }
        }
    }
});

gpii.test.cloudBased.oauth2.buildTestFixtureCommon = function (testDef, commonRec, config, testCaseGrade) {
    testDef = fluid.extend(true, {}, testDef, commonRec);

    testDef.sequence = fluid.makeArray(testDef.sequence);
    testDef.gradeNames = fluid.makeArray(testDef.gradeNames);
    testDef.gradeNames.push("gpii.test.cloudBased.oauth2.testCaseHolder");
    if (testCaseGrade) {
        testDef.gradeNames.push(testCaseGrade);
    }
    testDef.config = config;
    return testDef;
};

gpii.test.cloudBased.oauth2.buildDisruptedFixture = function (testDef, commonRec, disruption, config, testCaseGrade) {
    var options = fluid.defaults(disruption.sequenceGrade);
    testDef = gpii.test.cloudBased.oauth2.buildTestFixtureCommon(testDef, commonRec, config, testCaseGrade);
    if (options.expect) {
        testDef.expect = options.expect;
    }
    if (disruption.expected) {
        testDef.expected = disruption.expected;
    }
    if (disruption.name) {
        testDef.name += " - " + disruption.name;
    }
    testDef.gradeNames = testDef.gradeNames.concat(fluid.makeArray(options.testCaseGradeNames));

    testDef.expectedStatusCode = disruption.expectedStatusCode || options.expectedStatusCode;

    var changes = fluid.makeArray(options.changes).concat(fluid.makeArray(disruption.changes));
    fluid.set(testDef, [options.recordName, "changes"], changes);
    return testDef;
};

// Marker grade for "disruptions", whose unique variations are superimposed on a "common" test definition.
fluid.defaults("gpii.test.disruption", {
    gradeNames: ["fluid.component"]
});

gpii.test.cloudBased.oauth2.filter = function (model, options, filterName) {
    var changes = fluid.get(options, [filterName, "changes"]);
    fluid.log("cloudBased.oauth2.filter fetched changes " + JSON.stringify(changes, null, 2) + " for filter name " + filterName);
    return changes ? gpii.test.cloudBased.oauth2.filterModel(model, changes) : model;
};

gpii.test.cloudBased.oauth2.filterModel = function (model, changes) {
    var holder = {
        model: fluid.copy(model)
    };
    var applier = fluid.makeHolderChangeApplier(holder);
    fluid.fireChanges(applier, changes);
    fluid.log("cloudBased.oauth2.filterModel returning filtered model ", JSON.stringify(holder.model, null, 2));
    return holder.model;
};

gpii.test.cloudBased.oauth2.runDisruptedTests = function (testDefsToDisrupt, config, testEnvironment, testCaseGrade) {
    fluid.each(testDefsToDisrupt, function (testDefToDisrupt) {
        fluid.each(testDefToDisrupt.disruptions, function (disruption) {
            var disruptedTestDef = gpii.test.cloudBased.oauth2.buildDisruptedFixture(testDefToDisrupt.testDef, {}, disruption, config, testCaseGrade);

            gpii.test.runTestDefs([disruptedTestDef], function (testDef) {
                var gradedTestDef = gpii.test.testDefToEnvironment(testDef, testEnvironment, disruption.sequenceGrade);
                return gradedTestDef;
            });
        });
    });
};
