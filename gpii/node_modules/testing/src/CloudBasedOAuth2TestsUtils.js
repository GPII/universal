/*!
GPII Cloud-based Flow Manager with OAuth2 Test Infrastructure

Copyright 2012 OCAD University
Copyright 2012 Antranig Basman
Copyright 2013 Raising the Floor
Copyright 2014 Lucendo Development Ltd.
Copyright 2015-2017 OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

"use strict";

var fluid = require("infusion"),
    querystring = require("querystring"),
    gpii = fluid.registerNamespace("gpii"),
    jqUnit = fluid.registerNamespace("jqUnit"),
    kettle = fluid.registerNamespace("kettle");

fluid.registerNamespace("gpii.test.cloudBased.oauth2");

gpii.test.stringifyFormBody = function (formBody) {
    var encoded = fluid.transform(formBody, function (element) {
        return typeof(element) === "string" ? element : JSON.stringify(element);
    });
    return querystring.stringify(encoded);
};

// On startup of the datastore, populate the data store with to-be-tested GPII user token
gpii.test.cloudBased.oauth2.populateDataStore = function (testCaseHolder, doneEvent) {

    // TODO: This should be supplied via an IoC-resolved argument after the FLUID-4892 rewrite of Infusion.
    var db = testCaseHolder.pouchHarness.express.expressPouch.databaseInstances.auth;

    var promisesSequence = [];

    promisesSequence.push(db.put({
        _id: "gpiiToken-100",
        type: "gpiiToken",
        gpiiToken: testCaseHolder.options.userToken
    }));

    // Fire the doneEvent at the end to signal that we are finished
    promisesSequence.push(function () {
        doneEvent.fire();
    });

    fluid.promise.sequence(promisesSequence);
};

gpii.test.verifyJSONResponse = function (body, request) {
    var response = request.nativeResponse;
    jqUnit.assertEquals("Should have received a 200 response", 200, response.statusCode);
    jqUnit.assertTrue("Should have received an JSON response type", response.headers["content-type"].indexOf("application/json") === 0);
    return JSON.parse(body);
};

gpii.test.verifyStatusCodeResponse = function (body, request, statusCode) {
    var response = request.nativeResponse;
    jqUnit.assertEquals("Should have received a " + statusCode + " response", statusCode, response.statusCode);
};

gpii.test.cloudBased.oauth2.sendRequest = function (request, options, formBody, filterName) {
    formBody = gpii.test.cloudBased.oauth2.filter(formBody, options, filterName);
    request.send(gpii.test.stringifyFormBody(formBody));
};

gpii.test.cloudBased.oauth2.verifyFieldInResponse = function (response, request, funcName, fieldName) {
    var fieldValue = fluid.get(response, fieldName);
    fluid.log(funcName + " Got " + fieldName + ": ", fieldValue);
    jqUnit.assertValue("Should have received " + fieldName, fieldValue);
    fluid.set(request, fieldName, fieldValue);
};

gpii.test.cloudBased.oauth2.sendResourceOwnerGpiiTokenAccessTokenRequest = function (accessTokenRequest, options) {
    var formBody = {
        grant_type: "password",
        client_id: options.client_id,
        client_secret: options.client_secret,
        username: options.username,
        password: options.password
    };

    gpii.test.cloudBased.oauth2.sendRequest(accessTokenRequest, options, formBody, "accessTokenForm");
};

gpii.test.cloudBased.oauth2.verifyResourceOwnerGpiiTokenAccessTokenInResponse = function (body, accessTokenRequest) {
    var response = gpii.test.verifyJSONResponse(body, accessTokenRequest);
    gpii.test.cloudBased.oauth2.verifyFieldInResponse(response, accessTokenRequest, "oauth2.verifyResourceOwnerGpiiTokenAccessTokenInResponse", "access_token");
    gpii.test.cloudBased.oauth2.verifyFieldInResponse(response, accessTokenRequest, "oauth2.verifyResourceOwnerGpiiTokenAccessTokenInResponse", "expiresIn");
};

gpii.test.cloudBased.oauth2.sendRequestWithAccessToken = function (request, accessToken, data) {
    var securedHeader = {
        headers: {
            Authorization: "Bearer " + accessToken
        }
    };

    request.send(data ? data : null, securedHeader);
};

fluid.defaults("gpii.test.cloudBased.oauth2.testCaseHolder", {
    gradeNames: ["kettle.test.testCaseHolder", "gpii.test.pouch.pouchTestCaseHolder"],
    selectedPreferences: {
        "": true
    },
    events: {
        onDataPopulated: null,
        onFixturesConstructed: {
            events: {
                onDataPopulated: "onDataPopulated"
            }
        }
    },
    listeners: {
        "onPouchHarnessReady.populateData": {
            funcName: "gpii.test.cloudBased.oauth2.populateDataStore",
            args: ["{testCaseHolder}", "{testCaseHolder}.events.onDataPopulated"]
        }
    },
    components: {
        accessTokenRequest: {
            type: "kettle.test.request.http",
            options: {
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded"
                },
                path: "/access_token",
                port: 8081,
                method: "POST"
            }
        }
    }
});

gpii.test.cloudBased.oauth2.buildTestFixtureCommon = function (testDef, commonRec, baseDir) {
    testDef = fluid.extend(true, {}, testDef, commonRec);

    testDef.sequence = fluid.makeArray(testDef.sequence);
    testDef.gradeNames = fluid.makeArray(testDef.gradeNames);
    testDef.gradeNames.push("gpii.test.cloudBased.oauth2.testCaseHolder");
    testDef.config = gpii.test.cloudBased.gpiiConfig(baseDir);
    return testDef;
};

// returns subarray including only elements between start and end (non-inclusive)
gpii.test.elementsBetween = function (origArray, start, end) {
    var array = fluid.makeArray(origArray);
    start = start || 0;
    if (!end && end !== 0) {
        end = array.length;
    }
    array.length = end;
    array.splice(0, start);
    return array;
};

// insert the supplied elements into the array at position index (DESTRUCTIVE)
gpii.test.insertIntoArray = function (origArray, index, elements) {
    var spliceArgs = [index || 0, 0].concat(elements);
    origArray.splice.apply(origArray, spliceArgs);
};

gpii.test.cloudBased.oauth2.buildDisruptedFixture = function (testDef, commonRec, disruption, baseDir) {
    var options = fluid.defaults(disruption.gradeName);
    testDef = gpii.test.cloudBased.oauth2.buildTestFixtureCommon(testDef, commonRec, baseDir);
    if (options.expect) {
        testDef.expect = options.expect;
    }
    if (disruption.expected) {
        testDef.expected = disruption.expected;
    }
    if (disruption.name) {
        testDef.name += " - " + disruption.name;
    }
    testDef.gradeNames = testDef.gradeNames.concat(fluid.makeArray(options.testCaseGradeNames));
    var sequence = gpii.test.elementsBetween(fluid.getGlobalValue(options.sequenceName),
        options.startAt, options.truncateAt);
    if (options.finalRecord) {
        sequence.push(options.finalRecord);
    }
    if (options.insertRecords) { // TODO: replace all this special-case manipulation with FLUID-3504 when it is implemented
        gpii.test.insertIntoArray(sequence, options.insertAt, options.insertRecords);
    }

    testDef.sequence = gpii.test.pouch.addConstructFixturesToSequence(sequence);
    testDef.expectedStatusCode = disruption.expectedStatusCode || options.expectedStatusCode;
    fluid.log("oauth2.buildDisruptedFixture issuing sequence" + JSON.stringify(sequence, null, 2));
    var changes = fluid.makeArray(options.changes).concat(fluid.makeArray(disruption.changes));
    fluid.set(testDef, [options.recordName, "changes"], changes);
    return testDef;
};

fluid.defaults("gpii.test.disruption", {
    gradeNames: ["fluid.component"]
});

gpii.test.cloudBased.oauth2.filter = function (model, options, filterName) {
    var changes = fluid.get(options, [filterName, "changes"]);
    fluid.log("cloudBased.oauth2.filter fetched changes " + JSON.stringify(changes, null, 2) + " for filter name " + filterName);
    return changes ? gpii.test.cloudBased.oauth2.filterModel(model, changes) : model;
};

gpii.test.cloudBased.oauth2.filterModel = function (model, changes) {
    var holder = {
        model: fluid.copy(model)
    };
    var applier = fluid.makeHolderChangeApplier(holder);
    fluid.fireChanges(applier, changes);
    fluid.log("cloudBased.oauth2.filterModel returning filtered model ", JSON.stringify(holder.model, null, 2));
    return holder.model;
};

gpii.test.cloudBased.oauth2.bootstrapDisruptedTest = function (testDefs, commonRec,
    disruptions, baseDir) {
    testDefs = fluid.makeArray(testDefs);
    return fluid.transform(disruptions, function (disruption) {
        return kettle.test.bootstrapServer(testDefs, function (testDef) {
            return gpii.test.cloudBased.oauth2.buildDisruptedFixture(testDef, commonRec, disruption, baseDir);
        });
    });
};
