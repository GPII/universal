/*!
GPII Ontology Server

Copyright 2012 OCAD University
Copyright 2014 Raising The Floor - International

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt

The ontologyHandler component is responsible for all the functionality related to ontologization,
etc., of preferences sets. It is not implmented as a kettle server and hence does _not_ expose any
URLs - this aspect is taken care of in the preferences server component.
*/

/*global require, __dirname */
(function () {

    "use strict";

    var fluid = require("infusion"),
        path = require("path"),
        gpii = fluid.registerNamespace("gpii"),
        $ = fluid.registerNamespace("jQuery"),
        fs = require("fs");

    fluid.require("kettle", require);

    fluid.defaults("gpii.ontologyHandler", {
        gradeNames: ["fluid.littleComponent", "autoInit"],
        invokers: {
            prefsToOntology: {
                funcName: "gpii.ontologyHandler.prefsToOntology",
                args: [ "{that}", "{arguments}.0", "{arguments}.1", "{arguments}.2" ]
            },
            rawPrefsToOntology: {
                funcName: "gpii.ontologyHandler.rawPrefsToOntology",
                args: [ "{that}", "{arguments}.0", "{arguments}.1" ]
            },
            addPrefsToRawPrefs: {
                funcName: "gpii.ontologyHandler.addPrefsToRawPrefs",
                args: [ "{that}", "{arguments}.0", "{arguments}.1", "{arguments}.2" ]
            }
        },
        ontologySourceListDir: "%root/../../../testData/ontologies", //directory with ontologies
        ontologyTransformSpecs: "", //will hold the actual ontology transformation definitions after read
        root: path.join(__dirname, "..")
    });

    gpii.ontologyHandler.finalInit = function (that) {
        //Read the list of available ontologyTransformations
        var ontologyDir = fluid.stringTemplate(that.options.ontologySourceListDir, { root: that.options.root });
        var ontologyTransformsList = fs.readdirSync(ontologyDir);
        //Load all the ontologies:
        gpii.ontologyHandler.loadOntologyTransformSpecs(that, ontologyDir, ontologyTransformsList);

    };

    /*
     * Reads the files (or URLs) that contains the ontology transformation specs and stores it in
     * the ontologyTransformSpecs propery of the gpii.ontologyHandler object
     *
     * @that (Object) - the gpii.ontologyHandler object. Should at minimum contain ontologySourceURL
     *     and ontologyTransformSpecs properties
     * @ontologyTransformList (Array) - A list of available ontology transformations
     */
    gpii.ontologyHandler.loadOntologyTransformSpecs = function (that, ontologyDir, ontologyTransformsList) {
        var transformSpecs = {};
        fluid.each(ontologyTransformsList, function (filename) {
            //read file content
            var transformSpec = fs.readFileSync(ontologyDir + "/" + filename, "utf8");

            //remove ".json" part of filename to use as key
            filename = filename.substring(0, filename.length-5);
            transformSpecs[filename] = JSON.parse(transformSpec);
        });
        that.options.ontologyTransformSpecs = transformSpecs;
    };


    /*
     * Function to take a raw preferences set and transform it into a desired ontology (incl. doing
     * the required transformations for each of the ). This function does not have any side-effects
     *
     * @that (Object) - A gpii.ontologyHandler object
     * @rawPrefs (Object) - the raw preferences as can be found on the raw preferences server - NOT
     *     expected keyed by 'preferences'
     * @toView (String) - the ontology for which to translate the raw NP set to
     *
     * @return Preferences in the ontology given in 'toView' parameter. This includes the preferences
     *     resulting from transforming all compatible preferences from different ontologies
     */
    gpii.ontologyHandler.rawPrefsToOntology = function (that, rawPrefs, toView) {
        var togo = {};
        //from each ontology in the raw prefs, check if we can transform into desired ontology,
        //do so if possible and merge with prefs set.
        fluid.each(rawPrefs, function (fromPrefs, fromView) {
            if (fromView === toView) {
                $.extend(true, togo, fromPrefs);
                return;
            }
            var transformSpec = gpii.ontologyHandler.getTransformSpec(
                    that.options.ontologyTransformSpecs, fromView, toView);
            if (transformSpec !== undefined) {
                var transformed = fluid.model.transformWithRules(fromPrefs, transformSpec);
                fluid.log("translated from " + fromPrefs + " to " + transformed + ", result: " +
                    JSON.stringify(transformed, 2, null));
                $.extend(true, togo, transformed);
            }
        });
        return togo;
    };

    /*
     * If the desired transformation spec from the requested ontology to the requested ontology
     * can be produced, return it. Else return undefined.
     *
     * @transformSpecs - Object with all the available transformationSpecs. It should be keyed by:
     *     "<from>-<to>" values (where <from> and <to> are replaced by the keys of ontologies) and
     *     value should be the actual transformationSpec
     * @from - the key of the ontology to transform from
     * @to - the key of the ontology to transform to
     *
     * @return - Transformation spec for translating the from ontology defined by param 'from' to
     *     ontology defined by param 'from'
     */
    gpii.ontologyHandler.getTransformSpec = function (transformSpecs, from, to) {
        var fromTo = from + "-" + to;
        if (transformSpecs[fromTo] !== undefined) {
            return transformSpecs[fromTo];
        }

        var toFrom = to + "-" + from;
        return (transformSpecs[toFrom] === undefined) ? undefined :
            fluid.model.transform.invertConfiguration(transformSpecs[toFrom]);
    };

    /*
     * Takes a set of preferences in some ontology X and transforms they into some ontology Y. Note
     * that the preferences given should NOT be keyed by an ontology ID.
     *
     * @that (Object) - A gpii.ontologyHandler object
     * @prefs (Object) - The preferences set to be translated into a different ontology. The NP set
     *     passed should be in the ontology specified by the 'fromView' parameter and NOT keyed by
     *     an ontology ID.
     * @fromView (String) - the ontology in which the NP set given in the 'prefs' parameter is formatted
     * @toView (String) - the ontology to which the NP set should be transformed.
     *
     * @return - the NP transformed into the ontology requested via the 'toView' parameter. If no
     *     valid transformation to that ontology was found, an empty NP set is returned
     */
    gpii.ontologyHandler.prefsToOntology = function (that, prefs, fromView, toView) {
        if (fromView === toView) {
            return prefs;
        }
        var transformSpec = gpii.ontologyHandler.getTransformSpec(
                    that.options.ontologyTransformSpecs, fromView, toView);
        if (transformSpec === undefined) {
            return {};
        }

        var transformed = fluid.model.transformWithRules(prefs, transformSpec);
        fluid.log("translated from " + prefs + " to " + transformed + ", result: " +
            JSON.stringify(transformed, 2, null));
        return transformed;
    };

    /*
     * Takes a preferences set X in a particular ontology and removes all settings in the various
     * ontologies of the raw preferences set (Y) that are duplicates of the settings in the X
     * preferences set. The result is a raw preferences set that contains the preferences of X in
     * it's ontology, and no duplicates of settings of the X settings in the other ontologies. Note
     * that the preferneces given will overwrite the entire entry of that ontology in the raw
     * preferences set provided (ie. it wont get merged with any settings already existing in that
     * ontology)
     *
     * In other words: if any of the preferences that are being added are present in another
     * ontology, that entry should be removed from the other ontology, to avoid duplication of the
     * same term in different ontologies.
     *
     * @that (Object) - A gpii.ontologyHandler object
     * @prefs (Object) A preferences set in some ontology
     * @prefsView (String) the format of the preferences set given in the 'prefs' parameter
     * @rawPrefs (Object) the raw preferences set to be modified
     *
     * @return (Object) a raw preferences set that contains the settings of 'prefs' in the ontology
     *     'prefsView', and has no settings in any of the other ontologies that can be transformed
     *     (or created/inferred) from the settings of 'prefs'
     */
    gpii.ontologyHandler.addPrefsToRawPrefs = function (that, prefs, prefsView, rawPrefs) {
        var togo = fluid.copy(rawPrefs);

        //on an update, the consumer is responsible for sending _ALL_ relevant preferences in an
        // ontology, so we can safely replace the existing preferences in that ontology
        togo[prefsView] = prefs;

        //for each of the remaining ontologies in the raw preferences, check if there are any
        //preferences that are duplicate and remove them if that is the case:
        fluid.each(togo, function (existingPrefs, existingView) {
            if (existingView === prefsView) {
                return;
            }
            //TODO - GPII-848: The preference merging needs to be improved once the user has the
            //ability to specifically 'unset' settings in the PCP/PMT - ie. decide that they do not
            //want eg. font-size defined anymore.

            //transform settings from the new preferences set (prefsView) into into the ontology
            //were current looking at (ie. 'existingView')
            var transformed = gpii.ontologyHandler.prefsToOntology(that, prefs, prefsView, existingView);
            //remove all the transformed preferences from that prefs set
            var filteredPrefs = gpii.ontologyHandler.utils.filterPrefs(existingPrefs, transformed);
            if (filteredPrefs === undefined) { //no more preferences left in this ontology
                delete togo[existingView];
                return;
            }
            togo[existingView] = filteredPrefs;
        });
        return togo;
    };

      // TODO: This is a synchronous skeleton of the algorithm below, exposed for purposes of testing in MatchMaker's InverseCapabilitiesTests.js
    gpii.ontologyHandler.doSuppliedTransform = function (preferences, transform) {
        fluid.log("applying transform ", transform);
        var transformed = fluid.model.transformWithRules(preferences, transform);
        return transformed;
    };
})();