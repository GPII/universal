/*!
GPII Ontology Server

Copyright 2012 OCAD University
Copyright 2014 Raising The Floor - International

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt

The ontologyHandler component is responsible for all the functionality related to ontologization,
etc., of preferences sets. It is not implmented as a kettle server and hence does _not_ expose any
URLs - this aspect is taken care of in the preferences framework component.
*/

/*global require, __dirname */
(function () {

    "use strict";

    var fluid = require("infusion"),
        path = require("path"),
        gpii = fluid.registerNamespace("gpii"),
        when = fluid.require("when", require),
        $ = fluid.registerNamespace("jQuery"),
        callbacks = fluid.require("when/callbacks", require),
        fs = require("fs");

    fluid.require("kettle", require);

    fluid.defaults("gpii.ontologyHandler", {
        gradeNames: ["fluid.littleComponent", "autoInit"],
        invokers: {
            prefsToOntology: {
                funcName: "gpii.ontologyHandler.prefsToOntology",
                args: [ "{that}", "{arguments}.0", "{arguments}.1", "{arguments}.2" ]
            },
            rawPrefsToOntology: {
                funcName: "gpii.ontologyHandler.rawPrefsToOntology",
                args: [ "{that}", "{arguments}.0", "{arguments}.1" ]
            },
            addPrefsToRawPrefs: {
                funcName: "gpii.ontologyHandler.addPrefsToRawPrefs",
                args: [ "{that}", "{arguments}.0", "{arguments}.1", "{arguments}.2" ]
            }
        },
        ontologySourceListDir: "%root/../../../testData/ontologies", //directory with ontologies
        ontologyTransformSpecs: "", //will hold the actual ontology transformation definitions after read
        root: path.join(__dirname, "..")
    });

    gpii.ontologyHandler.finalInit = function (that) {
        //Read the list of available ontologyTransformations
        var ontologyDir = fluid.stringTemplate(that.options.ontologySourceListDir, { root: that.options.root });
        var ontologyTransformsList = fs.readdirSync(ontologyDir);
        //Load all the ontologies:
        gpii.ontologyHandler.loadOntologyTransformSpecs(that, ontologyDir, ontologyTransformsList);

    };

    /*
     * Reads the files (or URLs) that contains the ontology transformation specs and stores it in
     * the ontologyTransformSpecs propery of the gpii.ontologyHandler object
     *
     * @that (Object) - the gpii.ontologyHandler object. Should at minimum contain ontologySourceURL
     *     and ontologyTransformSpecs properties
     * @ontologyTransformList (Array) - A list of available ontology transformations
     */
    gpii.ontologyHandler.loadOntologyTransformSpecs = function (that, ontologyDir, ontologyTransformsList) {
        var promises = [];
        var promise;
        var transformSpecs = {};
        fluid.each(ontologyTransformsList, function (filename) {
            //read file content
            var transformSpec = fs.readFileSync(ontologyDir + "/" + filename);

            //remove ".json" part of filename to use as key
            filename = filename.substring(0, filename.length-5);
            transformSpecs[filename] = JSON.parse(transformSpec);
        });
        that.options.ontologyTransformSpecs = transformSpecs;
    };


    /*
     * Function to take a raw preferences set and transform it into a desired ontology (incl. doing
     * the required transformations for each of the ). This function does not have any side-effects
     *
     * @that (Object) - A gpii.ontologyHandler object
     * @rawPrefs (Object) - the raw preferences as can be found on the raw preferences server - NOT
     *     expected keyed by 'preferences'
     * @toView (String) - the ontology for which to translate the raw NP set to
     *
     * @return Preferences in the ontology given in 'toView' parameter. This includes the preferences
     *     resulting from transforming all compatible preferences from different ontologies
     */
    gpii.ontologyHandler.rawPrefsToOntology = function (that, rawPrefs, toView) {
        var togo = {};
        //from each ontology in the raw prefs, check if we can transform into desired ontology,
        //do so if possible and merge with prefs set.
        fluid.each(rawPrefs, function (fromPrefs, fromView) {
            if (fromView === toView) {
                $.extend(togo, fromPrefs, true);
                return;
            }
            var transformSpec = gpii.ontologyHandler.getTransformSpec(
                    that.options.ontologyTransformSpecs, fromView, toView);
            if (transformSpec !== undefined) {
                var transformed = fluid.model.transformWithRules(fromPrefs, transformSpec);
                fluid.log("translated from " + fromPrefs + " to " + transformed + ", result: "
                    + JSON.stringify(transformed, 2, null));
                $.extend(togo, transformed, true);
            }
        });
        return togo;
    };

    /*
     * If the desired transformation spec from the requested ontology to the requested ontology
     * can be produced, return it. Else return undefined.
     *
     * @transformSpecs - Object with all the available transformationSpecs. It should be keyed by:
     *     "<from>-<to>" values (where <from> and <to> are replaced by the keys of ontologies) and
     *     value should be the actual transformationSpec
     * @from - the key of the ontology to transform from
     * @to - the key of the ontology to transform to
     *
     * @return - Transformation spec for translating the from ontology defined by param 'from' to 
     *     ontology defined by param 'from'
     */
    gpii.ontologyHandler.getTransformSpec = function (transformSpecs, from, to) {
        var fromTo = from + "-" + to;
        if (transformSpecs[fromTo] !== undefined) {
            return transformSpecs[fromTo];
        }

        var toFrom = to + "-" + from;
        return (transformSpecs[toFrom] === undefined) ? undefined :
            fluid.model.transform.invertConfiguration(transformSpecs[toFrom]);
    };

    /*
     * Takes a set of preferences in some ontology X and transforms they into some ontology Y. Note
     * that the preferences given should NOT be keyed by an ontology ID.
     *
     * @that (Object) - A gpii.ontologyHandler object
     * @prefs (Object) - The preferences set to be translated into a different ontology. The NP set 
     *     passed should be in the ontology specified by the 'fromView' parameter and NOT keyed by
     *     an ontology ID.
     * @fromView (String) - the ontology in which the NP set given in the 'prefs' parameter is formatted
     * @toView (String) - the ontology to which the NP set should be transformed.
     *
     * @return - the NP transformed into the ontology requested via the 'toView' parameter. If no
     *     valid transformation to that ontology was found, an empty NP set is returned
     */
    gpii.ontologyHandler.prefsToOntology = function (that, prefs, fromView, toView) {
        if (fromView === toView) {
            return prefs;
        }
         var transformSpec = gpii.ontologyHandler.getTransformSpec(
                    that.options.ontologyTransformSpecs, fromView, toView);
        if (transformSpec === undefined) {
            return {};
        }

        var transformed = fluid.model.transformWithRules(prefs, transformSpec);
        fluid.log("translated from " + prefs + " to " + transformed + ", result: "
            + JSON.stringify(transformed, 2, null));
        return transformed;
    }

    /*
     * Takes a preferences set X in a particular ontology and removes all settings in the various
     * ontologies of the raw preferences set (Y) that are duplicates of the settings in the X
     * preferences set. The result is a raw preferences set that contains the preferences of X in
     * it's ontology, and no duplicates of settings of the X settings in the other ontologies. Note
     * that the preferneces given will overwrite the entire entry of that ontology in the raw
     * preferences set provided (ie. it wont get merged with any settings already existing in that
     * ontology)
     *
     * In other words: if any of the preferences that are being added are present in another 
     * ontology, that entry should be removed from the other ontology, to avoid duplication of the 
     * same term in different ontologies.
     *
     * @that (Object) - A gpii.ontologyHandler object
     * @prefs (Object) A preferences set in some ontology
     * @prefsView (String) the format of the preferences set given in the 'prefs' parameter
     * @rawPrefs (Object) the raw preferences set to be modified
     *
     * @return (Object) a raw preferences set that contains the settings of 'prefs' in the ontology
     *     'prefsView', and has no settings in any of the other ontologies that can be transformed
     *     (or created/inferred) from the settings of 'prefs'
     */
     gpii.ontologyHandler.addPrefsToRawPrefs = function (that, prefs, prefsView, rawPrefs) {
        var togo = fluid.copy(rawPrefs);

        //on an update, the consumer is responsible for sending _ALL_ relevant preferences in an 
        // ontology, so we can safely replace the existing preferences in that ontology
        togo[prefsView] = prefs;

        //for each of the remaining ontologies in the raw preferences, check if there are any 
        //preferences that are duplicate and remove them if that is the case:
        fluid.each(togo, function (existingPrefs, existingView) {
            if (existingView === prefsView) {
                return;
            }
            /*
                TODO KASPER: What are we gonna do about a user who wants to reset a setting, eg:
                User has the following raw prefs set: { ontA: { fontSize: 14 } }
                User loads the prefs set in ontB view: { ontB: { fontSize: Big }}
                the user now uses a preferences editor to set the fontSize setting to default. As
                a result the payload sent as PUT is : {}, specified as being in ontB.

                The desired result is to have the users NP set be: { ontA: {}}, but this wont happen
                unless we force all consumers to send both the original and the new preference set OR
                indicators for each 'default' setting that it has been set to default (/unset) during
                that session
            */
            //transform settings from the new preferences set (prefsView) into into the ontology
            //were current looking at (ie. 'existingView')
            var transformed = gpii.ontologyHandler.prefsToOntology(that, prefs, prefsView, existingView);
            //remove all the transformed preferences from that prefs set
            var filteredPrefs = gpii.ontologyHandler.utils.filterPrefs(existingPrefs, transformed);
            if (filteredPrefs === undefined) { //no more preferences left in this ontology
                delete togo[existingView];
                return;
            }
            togo[existingView] = filteredPrefs;
        });
        return togo;
     };
})();