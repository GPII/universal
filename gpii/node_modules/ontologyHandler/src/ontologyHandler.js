/*!
GPII Ontology Server

Copyright 2012 OCAD University
Copyright 2014 Raising The Floor - International

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

The research leading to these results has received funding from the European Union's
Seventh Framework Programme (FP7/2007-2013) under grant agreement no. 289016.

You may obtain a copy of the License at
https://github.com/GPII/universal/blob/master/LICENSE.txt

The ontologyHandler component is responsible for all the functionality related to ontologization,
etc., of preferences sets. It is not implemented as a kettle server and hence does _not_ expose any
URLs - this aspect is taken care of in the preferences server component.
*/

/* eslint strict: ["error", "function"] */

(function () {

    "use strict";

    var fluid = require("infusion"),
        gpii = fluid.registerNamespace("gpii"),
        fs = require("fs");

    // TODO: Create an incarnation of the ontologyHandler that is not tied to node.js and can be tested
    // the browser - it will need to be moved to using dataSources for I/O and have an "index" file rather than
    // calling fs.readdirSync().
    fluid.defaults("gpii.ontologyHandler", {
        gradeNames: ["fluid.component"],
        invokers: {
            prefsToOntology: {
                funcName: "gpii.ontologyHandler.prefsToOntology",
                args: [ "{that}", "{arguments}.0", "{arguments}.1", "{arguments}.2" ]
            },
            rawPrefsToOntology: {
                funcName: "gpii.ontologyHandler.rawPrefsToOntology",
                args: [ "{that}", "{arguments}.0", "{arguments}.1" ]
            },
            addPrefsToRawPrefs: {
                funcName: "gpii.ontologyHandler.addPrefsToRawPrefs",
                args: [ "{that}", "{arguments}.0", "{arguments}.1", "{arguments}.2" ]
            }
        },
        listeners: {
            onCreate: "gpii.ontologyHandler.loadOntologies"
        },
        ontologySourceListDir: "%universal/testData/ontologies", // directory with ontologies
        ontologyTransformSpecs: "" // will hold the actual ontology transformation definitions after read
    });

    gpii.ontologyHandler.loadOntologies = function (that) {
        // Check for re-occurence of GPII-1063
        fluid.log("loadOntologies for " + that.id + " path " + fluid.pathForComponent(that));
        var ontologyDir = fluid.module.resolvePath(that.options.ontologySourceListDir);

        // Read the list of available ontologyTransformations
        var ontologyTransformsList = fs.readdirSync(ontologyDir);
        // Load all the ontologies:
        gpii.ontologyHandler.loadOntologyTransformSpecs(that, ontologyDir, ontologyTransformsList);

    };

    /*
     * Sanitizes the context sections and the outer metadata section by removing entries for which
     * * Arrays are empty
     * * Values are undefined
     *
     * @prefs (Object) - the preferences to sanitize
     * @returns (Object) - the sanitized settings (according to above definition)
     */
    gpii.ontologyHandler.sanitizePreferencesSet = function (prefs) {
        fluid.each(prefs.contexts, function (context) {
            fluid.each(context, function (val, key) {
                if (val === undefined || (Array.isArray(val) && val.length === 0)) {
                    delete context[key];
                }
            });
        });
        if (prefs.metadata === undefined || (Array.isArray(prefs.metadata) && prefs.metadata.length === 0)) {
            delete prefs.metadata;
        }
        return prefs;
    };

    /*
     * Reads the files (or URLs) that contains the ontology transformation specs and stores it in
     * the ontologyTransformSpecs propery of the gpii.ontologyHandler object
     *
     * @that (Object) - the gpii.ontologyHandler object. Should at minimum contain ontologySourceURL
     *     and ontologyTransformSpecs properties
     * @ontologyDir (string) - path to folder containing the ontology transformation specs
     * @ontologyTransformList (Array) - A list of available ontology transformations
     */
    gpii.ontologyHandler.loadOntologyTransformSpecs = function (that, ontologyDir, ontologyTransformsList) {
        var transformSpecs = {};
        fluid.each(ontologyTransformsList, function (filename) {
            fluid.log("ontologyHandler Loading filename " + filename);
            var transformSpec = fs.readFileSync(ontologyDir + "/" + filename, "utf8");

            // remove ".json" part of filename to use as key
            filename = filename.substring(0, filename.length - 5);
            transformSpecs[filename] = JSON.parse(transformSpec);
        });
        that.options.ontologyTransformSpecs = transformSpecs;
    };

    /*
     * Function for getting a transformation spec translating between ontologies.
     *
     * If the desired transformation spec from the requested ontology to the requested ontology
     * can be produced, return it. Else return undefined.
     *
     * @transformSpecs - (Object) with all the available transformationSpecs. It should be keyed by:
     *     "<from>-<to>" values (where <from> and <to> are replaced by the keys of ontologies) and
     *     value should be the actual transformationSpec
     * @from (String) - the key of the ontology to transform from
     * @to (String) - the key of the ontology to transform to
     *
     * @return - Transformation spec for translating the from ontology defined by param 'from' to
     *     ontology defined by param 'from'
     */
    gpii.ontologyHandler.getTransformSpec = function (transformSpecs, from, to) {
        var fromTo = from + "-" + to;
        if (transformSpecs[fromTo] !== undefined) {
            return transformSpecs[fromTo];
        }

        var toFrom = to + "-" + from;
        return (transformSpecs[toFrom] === undefined) ? undefined :
            fluid.model.transform.invertConfiguration(transformSpecs[toFrom]);
    };


    /*
     * Function to collect all paths in the given object that has a certain value and return an
     * array of these paths as el-paths (strings). This is useful when transforming metadata and
     * we need to translate from an el-path in one ontology into an el-path in another ontology.
     *
     * The function is recursive and the 'target' parameter should be an array that will be
     * populated by the found paths.
     *
     * @obj (Object) to search through
     * @search the value to search for. Whenever this value is found, an el-path string leading to
     *      this location is saved to the target array
     * @target (Array) - it will be modified by this function to contain the el-paths that contain the
     *      'search' value
     * @pathArray - is used by the function to keep track of the current path. Should generally
     *      not be supplied to this function unless one wishes to have the paths that populate the
     *      the target being prefixed by some path.
     *
     * @return undefined - rather the array of collection will be built in the @target parameter
     */
    gpii.ontologyHandler.collectPaths = function (obj, search, target, pathArray) {
        if (!(pathArray instanceof Array)) {
            pathArray = [];
        }
        fluid.each(obj, function (entry, key) {
            pathArray.push(key);
            if (entry === search) {
                var path = fluid.pathUtil.composeSegments.apply(null, pathArray);
                target.push(path);
                pathArray.pop(key);
                return;
            }
            if (!fluid.isPrimitive(entry)) {
                gpii.ontologyHandler.collectPaths(entry, search, target, pathArray);
            }
            pathArray.pop(key);
        });
    };

    /*
     * Function to translate the metadata section of a preferences document - more specifically,
     * the scope section of a metadata part of a preferences document. For individual values
     * they will be translated as expected (ie. by a lookup in the transformation rules). In case
     * of wildcard characters, these are _only_ supported at the end of a string. A string containing
     * only the wildcard ("*") will be kept as it, as this is globally applicable across
     * ontologies. For other wildcards (eg. "display.*") they will be exploded when requested in a
     * different ontology than they're specified in. So for example, a metadata section with a scope
     * of "display.*" would first be exploded to all the preferences under the display object
     * and then each of these would be transformed to the requested ontology.
     *
     * @metadata (Array) - the metadata section to be transformed
     * @transformSpec (Object) - the transformation rules to be applied to the scopes
     *
     * @return the transformed metadata section
     */
    gpii.ontologyHandler.transformMetadata = function (metadata, transformSpec) {
        if (metadata === undefined) {
            return undefined;
        }
        var togo = [];

        fluid.each(metadata, function (entry) {
            // if metadata section is application priority, we dont want to have the
            // scope ontologized. We want to keep the flat-style application ID
            if (entry.type === "priority") {
                togo.push(entry);
                return;
            }

            var tmpEntry = fluid.copy(entry),
                toTransform = {},
                transformed,
                target;
            tmpEntry.scope = [];



            fluid.each(entry.scope, function (preference) {
                if (preference === "*") { // ontology independent wildcard - leave as is
                    tmpEntry.scope.push(preference);
                    return;
                }
                if (fluid.model.transform.hasWildcard(preference)) {
                    // explode wildcard preference to paths, and set all of these in toTransform
                    var paths = fluid.model.transform.collectInputPaths(transformSpec);
                    var prefix = preference.substring(0, preference.indexOf("*"));
                    for (var i in paths) {
                        var path = paths[i];
                        // each matching path should be added to toTransform for trannsform
                        if (path.indexOf(prefix) === 0) {
                            fluid.set(toTransform, path, true, fluid.model.escapedSetConfig);
                        }
                    }
                    return;
                }
                fluid.set(toTransform, preference, true, fluid.model.escapedSetConfig);
            });
            // transform to new ontology and collect all paths with 'true' value - these equal
            // the settings from the original scope array
            transformed = fluid.model.transformWithRules(toTransform, transformSpec);
            target = [];
            gpii.ontologyHandler.collectPaths(transformed, true, target);
            tmpEntry.scope = tmpEntry.scope.concat(target);
            togo.push(tmpEntry);
        });
        return togo;
    };

    /*
     * Takes a set of preferences in some ontology X and transforms they into some ontology Y. Note
     * that the preferences given should NOT be keyed by an ontology ID.
     *
     * @that (Object) - A gpii.ontologyHandler object
     * @prefs (Object) - The preferences set to be translated into a different ontology. The NP set
     *     passed should be in the ontology specified by the 'fromView' parameter and NOT keyed by
     *     an ontology ID.
     * @fromView (String) - the ontology in which the NP set given in the 'prefs' parameter is formatted
     * @toView (String) - the ontology to which the NP set should be transformed.
     *
     * @return - the NP transformed into the ontology requested via the 'toView' parameter. If no
     *     valid transformation to that ontology was found, an empty NP set is returned
     */
    gpii.ontologyHandler.prefsToOntology = function (that, prefs, fromView, toView) {
        var transformSpec,
            transformed = {
                contexts: {}
            };
        // if we're in same ontology, return as is
        if (fromView === toView) {
            return prefs;
        }
        // else look for fitting ontology transformation spec and retrieve it. Return {} if none found
        transformSpec = gpii.ontologyHandler.getTransformSpec(that.options.ontologyTransformSpecs,
            fromView, toView);
        if (transformSpec === undefined) {
            return {};
        }

        // copy values directly or transform - depending on key
        transformed.contexts = fluid.transform(prefs.contexts, function (context) {
            return fluid.transform(context, function (val, key) {
                var rule = gpii.ontologyHandler.contextBlocks[key];
                return rule === null ? val : fluid.invokeGlobalFunction(rule, [val, transformSpec]);
            });
        });

        // translate the context independent metadata block:
        transformed.metadata = gpii.ontologyHandler.transformMetadata(prefs.metadata, transformSpec);
        return gpii.ontologyHandler.sanitizePreferencesSet(transformed);
    };

    // Helper object for prefsToOntology function
    gpii.ontologyHandler.contextBlocks = {
        name: null,
        priority: null,
        preferences: "fluid.model.transformWithRules",
        metadata: "gpii.ontologyHandler.transformMetadata",
        conditions: null
    };

    /*
     * Function to merge two NP sets.
     *
     * Takes two (non-raw) prefs set, merges them and returns the resulting set. One cannot just
     * use fluid.extend, as this would override array entries in the metadata section, so a more
     * informed merge is required. The preferences sets are expected to be in the same ontology
     * and should not be keyed by ontology.
     *
     * @master Object - The first preference set to be merged
     * @secondary Object - the second preference set to be merged
     *
     * @returns Object - a merged preferences set (non-raw).
     */
    gpii.ontologyHandler.mergePrefsSets = function (master, secondary) {
        master = fluid.copy(master);
        secondary = fluid.copy(secondary);

        fluid.each(secondary.contexts, function (context, contextId) {
            var mcontext = master.contexts[contextId];
            // if not in master, just copy over from secondary:
            if (!mcontext) {
                master.contexts[contextId] = context;
            } else {
                // preferences and metadata should be the only things varying
                fluid.extend(true, mcontext.preferences, context.preferences);
                mcontext.metadata = fluid.makeArray(mcontext.metadata).concat(fluid.makeArray(context.metadata));
            }
        });

        // merge outer metadata block
        master.metadata = fluid.makeArray(master.metadata).concat(fluid.makeArray(secondary.metadata));
        return master;
    };

    /*
     * Function to take a raw preferences set and transform it into a desired ontology (incl. doing
     * the required transformations for each of the preferences. metadata, etc). This function does
     * not have any side-effects
     *
     * @that (Object) - A gpii.ontologyHandler object
     * @rawPrefs (Object) - the raw preferences as can be found on the raw preferences server - NOT
     *     expected keyed by 'preferences'
     * @toView (String) - the ontology to translate the raw NP set into
     *
     * @return Preferences in the ontology given in 'toView' parameter. This includes the preferences,
     *     metadata, etc., resulting from transforming all compatible preferences from different ontologies
     */
    gpii.ontologyHandler.rawPrefsToOntology = function (that, rawPrefs, toView) {
        var togo = {
            contexts: {}
        };

        fluid.each(rawPrefs, function (fromContent, fromView) {
            var transformed = gpii.ontologyHandler.prefsToOntology(that, fromContent, fromView, toView);
            togo = gpii.ontologyHandler.mergePrefsSets(togo, transformed);
        });
        return gpii.ontologyHandler.sanitizePreferencesSet(togo);
    };

    /*
     * Takes a preferences set X in a particular ontology and removes all settings in the various
     * ontologies of the raw preferences set (Y) that are duplicates of the settings in the X
     * preferences set. The result is a raw preferences set that contains the preferences of X in
     * it's ontology, and no duplicates of settings of the X settings in the other ontologies. Note
     * that the preferneces given will overwrite the entire entry of that ontology in the raw
     * preferences set provided (ie. it wont get merged with any settings already existing in that
     * ontology)
     *
     * In other words: if any of the preferences that are being added are present in another
     * ontology, that entry should be removed from the other ontology, to avoid duplication of the
     * same term in different ontologies.
     *
     * @that (Object) - A gpii.ontologyHandler object
     * @prefs (Object) A preferences set in some ontology
     * @prefsView (String) the format of the preferences set given in the 'prefs' parameter
     * @rawPrefs (Object) the raw preferences set to be modified
     *
     * @return (Object) a raw preferences set that contains the settings of 'prefs' in the ontology
     *     'prefsView', and has no settings in any of the other ontologies that can be transformed
     *     (or created/inferred) from the settings of 'prefs'
     */
    gpii.ontologyHandler.addPrefsToRawPrefs = function (that, prefs, prefsView, rawPrefs) {
        var togo = fluid.copy(rawPrefs);

        // on an update, the consumer is responsible for sending _ALL_ relevant preferences in an
        // ontology, so we can safely replace the existing preferences in that ontology
        togo[prefsView] = prefs;

        // for each of the remaining ontologies in the raw preferences, check if there are any
        // preferences that are duplicate and remove them if that is the case:
        fluid.each(togo, function (existingPrefs, existingView) {
            if (existingView === prefsView) {
                return;
            }
            // TODO - GPII-848: The preference merging needs to be improved once the user has the
            // ability to specifically 'unset' settings in the PCP/PMT - ie. decide that they do not
            // want eg. font-size defined anymore.

            // transform settings from the new preferences set (prefsView) into the ontology
            // we're current looking at (ie. 'existingView')
            var transformed = gpii.ontologyHandler.prefsToOntology(that, prefs, prefsView, existingView);
            // dig down to each of the prefs sets:
            var contexts = transformed.contexts;
            fluid.each(contexts, function (context, cname) {
                if (context.preferences && existingPrefs.contexts[cname] && existingPrefs.contexts[cname].preferences) {
                    var filteredPrefs = gpii.ontologyHandler.utils.filterPrefs(
                            existingPrefs.contexts[cname].preferences,
                            context.preferences);

                    togo[existingView].contexts[cname].preferences = filteredPrefs;
                }
            });
        });
        // clean up prefs sets for each ontology
        return fluid.transform(togo, gpii.ontologyHandler.sanitizePreferencesSet);
    };
})();
