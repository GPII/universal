/*
 * GPII Launch Handlers
 *
 * Copyright 2017 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = fluid || require("infusion"),
    gpii = fluid.registerNamespace("gpii");

/**
 * The flexibleHandler is a highly customizable launch handler that is implemented to handle all
 * the cases in which a solution's launch-cycle is too complex or specific to efficiently be handled
 * in one of the standard launchHandlers.
 *
 * Besides the normal launch handler options like retryOptions and verifySettings, the flexible handler
 * supports three directives: `getState`, `setTrue` and `setFalse`.
 *
 * `getState`: equals the launchHandler's "get" functionality, and should return a boolean value indicating
 *      whether the application is running or not. The content of this directive will be sent to the
 *      processReporter's handleIsRunning function
 * `setTrue`: Is run when a "true" value is sent to the launch handler. The content of this block should
 *      be an array of objects that can be run as graded functions in infusion. The result of runnings these
 *      blocks should be that the application is running
 * `setFalse`: Identical to `setTrue` but is run when a "false" is sent to the launch handler. The result from
 *      running the blocks in this directive should be that the application is closed/not running.
 */
fluid.registerNamespace("gpii.launchHandlers.flexibleHandler");

gpii.launchHandlers.flexibleHandler.set = function (payload) {
    return fluid.transform(payload, function (allSettingsBlocks, solutionId) {
        return fluid.transform(allSettingsBlocks, function (handlerData) {
            // find desired state { running: X }
            var desiredState = handlerData.settings.running;
            if (desiredState !== true && desiredState !== false) {
                fluid.fail("Unable to set the launch state of ", solutionId, " to ", desiredState);
            }

            // get current state
            var currentState = gpii.launchHandlers.flexibleHandler.executeGetBlock(handlerData.options, solutionId);

            // if not in desired state
            if (currentState !== desiredState) {
                desiredState === true ?
                    gpii.launchHandlers.flexibleHandler.executeSetBlock(handlerData, "setTrue") :
                    gpii.launchHandlers.flexibleHandler.executeSetBlock(handlerData, "setFalse");
            }

            return gpii.settingsHandlers.setSettings(handlerData, { running: currentState });
        });
    });
};

gpii.launchHandlers.flexibleHandler.get = function (payload) {
    return fluid.transform(payload, function (allSettingsBlocks, solutionId) {
        return fluid.transform(allSettingsBlocks, function (handlerData) {
            var currentState = gpii.launchHandlers.flexibleHandler.executeGetBlock(handlerData.options, solutionId);
            return { settings: { running: currentState }};
        });
    });
};

gpii.launchHandlers.flexibleHandler.executeSetBlock = function (mainEntry, blockName) {
    var setBlocks = fluid.get(mainEntry, [ "options", blockName ]);
    fluid.each(fluid.makeArray(setBlocks), function (setBlock) {
        fluid.invokeGradedFunction(setBlock.type, setBlock);
    });
};

gpii.launchHandlers.flexibleHandler.executeGetBlock = function (options) {
    return gpii.processReporter.handleIsRunning({ isRunning: options.getState });
};
