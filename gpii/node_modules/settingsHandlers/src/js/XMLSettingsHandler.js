/*!
GPII XML Settings Handler

Copyright 2012 Raising the Floor - International

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

/*global require, $ */


(function () {
    
    "use strict";
    
    var fluid = require("infusion"),
        fs = require("fs"),
        xm = require("xml-mapping"),
        gpii = fluid.registerNamespace("gpii");

    fluid.registerNamespace("gpii.settingsHandlers.XMLHandler");

    gpii.settingsHandlers.XMLHandler.applyPaths = function (operation, pathOp, paths) {
        for (var i = 0; i < paths.length; ++ i) {
            operation === "push" ? pathOp.push(paths[i]) : pathOp.pop();
        }
    };
    
    gpii.settingsHandlers.XMLHandler.expandInnerValues = function (inputPath, outputPath, expander, innerValues) {
        var inputPrefixOp = expander.inputPrefixOp;
        var outputPrefixOp = expander.outputPrefixOp;
        var apply = gpii.settingsHandlers.XMLHandler.applyPaths;
        
        apply("push", inputPrefixOp, inputPath);
        apply("push", outputPrefixOp, outputPath);
        var expanded = {};
        fluid.each(innerValues, function (innerValue) {
            var expandedInner = expander.expand(innerValue);
            $.extend(true, expanded, expandedInner);
        });
        apply("pop", outputPrefixOp, outputPath);
        apply("pop", inputPrefixOp, inputPath);
        
        return expanded;
    };

    /* -------- Transformation functions -------------------- */
    
    /**
     * Transforms the given array to an object.
     * Uses the expandSpec.options.key values from each object within the array as new keys.
     *
     * For example, with expandSpec.options.key = "name" and an input object like this:
     *
     * {
     *   b: [
     *     { name: b1, v: v1 },
     *     { name: b2, v: v2 }
     *   ]
     * }
     *
     * The output will be:
     * {
     *   b: {
     *     b1: {
     *       v: v1
     *     }
     *   },
     *   {
     *     b2: {
     *       v: v2
     *     }
     *   }
     * }
     */
    gpii.settingsHandlers.XMLHandler.arrayToObject = function (arr, expander, expandSpec) {
        if (fluid.get(expandSpec, "options.key") === undefined) {
            fluid.fail("arrayToObject requires a 'key' option.", expandSpec);
        }
        if (!fluid.isArrayable(arr)) {
            fluid.fail("arrayToObject didn't find array at inputPath.", expandSpec);
        }
        var newHash = {};
        var pivot = expandSpec.options.key;

        fluid.each(arr, function (v, k) {
            //check that we have a pivot entry in the object and it's a valid type:            
            var newKey = v[pivot];
            var keyType = typeof(newKey);
            if (keyType !== "string" && keyType !== "boolean" && keyType !== "number") {
                fluid.fail("arrayToObject encountered untransformable array due to missing or invalid key", v);
            }
            //use the value of the key element as key and use the remaining content as value
            var content = fluid.copy(v);
            delete content[pivot];
            //fix sub Arrays if needed:
            if (expandSpec.options.innerValue) {
                content = gpii.settingsHandlers.XMLHandler.expandInnerValues([expander.outputPrefix, k.toString()], 
                    [newKey], expander, expandSpec.options.innerValue);
            }
            newHash[newKey] = content;
        });
        return newHash;
    };

    gpii.settingsHandlers.XMLHandler.arrayToObject.invertRules = function (expandSpec, expander) {
        var togo = fluid.copy(expandSpec);
        togo.type = "gpii.settingsHandlers.XMLHandler.objectToArray";
        togo.inputPath = fluid.model.composePaths(expander.outputPrefix, expandSpec.outputPath);
        togo.outputPath = fluid.model.composePaths(expander.inputPrefix, expandSpec.inputPath);
        //invert expanders from innerValue as well:
        // TODO: The Model Transformations framework should be capable of this, but right now the
        // issue is that we use a "private contract" to operate the "innerValue" slot. We need to
        // spend time thinking of how this should be formalised
        if (togo.options && togo.options.innerValue) {
            var innerValue = togo.options.innerValue;
            for (var i = 0; i < innerValue.length; ++i) {
                innerValue[i] = fluid.model.transform.invertConfiguration(innerValue[i]);
            }            
        }
        return togo;
    };

    fluid.defaults("gpii.settingsHandlers.XMLHandler.arrayToObject", {
        gradeNames: ["fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "gpii.settingsHandlers.XMLHandler.arrayToObject.invertRules"
    });
    
    /**
     * Transforms an object into array of objects.
     * This performs the inverse transform of gpii.settingsHandlers.XMLHandler.arrayToObject.
     */
    gpii.settingsHandlers.XMLHandler.objectToArray = function (hash, expander, expandSpec) {
        if (fluid.get(expandSpec, "options.key") === undefined) {
            fluid.fail("objectToArray requires a 'key' option.", expandSpec);
        }
        
        var newArray = [];
        var pivot = expandSpec.options.key;

        fluid.each(hash, function (v, k) {
            var content = {};
            content[pivot] = k;
            if (expandSpec.options.innerValue) {
                v = gpii.settingsHandlers.XMLHandler.expandInnerValues([expandSpec.inputPath, k], [expandSpec.inputPath, newArray.length.toString()], 
                    expander, expandSpec.options.innerValue);
            }
            // TODO: remove this use of fluid.merge which will not be valid in 1.5 Infusion framework
            fluid.merge("replace", content, v);
            newArray.push(content);
        });
        return newArray;
    };
    
    fluid.defaults("gpii.settingsHandlers.XMLHandler.objectToArray", {
        gradeNames: "fluid.standardTransformFunction"
    });

    
    /* ------------------ XML handler specific ---------------------- */
    //Used when fluid.get'ing and set'ing, to allow escaped strings
    // TODO: When FLUID-4852 is fixed, remove these definitions
    var getParser = {
        parser: {
            parse: fluid.pathUtil.parseEL,
            compose: fluid.pathUtil.composePath
        },
        strategies: [fluid.model.defaultFetchStrategy]
    };

    var setParser = {
        parser: {
            parse: fluid.pathUtil.parseEL,
            compose: fluid.pathUtil.composePath
        },
        strategies: [fluid.model.defaultFetchStrategy, fluid.model.defaultCreatorStrategy]
    };
    
    /**
     * "Pretty-prints" an XML string.
     *
     * This function is derived from sample code posted by Dan Brooks on Stack Overflow:
     * http://stackoverflow.com/questions/376373/pretty-printing-xml-with-javascript
     *
     * @param {String} xml the XML string to reformat
     * @return {String} the reformatted XML document
     */
    gpii.settingsHandlers.XMLHandler.formatXml = function (xml) {
        var formatted = "";
        var reg = /(>)(<)(\/*)/g;
        xml = xml.replace(reg, "$1\r\n$2$3");
        var pad = 0;
        fluid.each(xml.split("\r\n"), function(node) {
            var indent = 0;
            if (node.match( /.+<\/\w[^>]*>$/ )) {
                indent = 0;
            } else if (node.match( /^<\/\w/ )) {
                if (pad !== 0) {
                    pad -= 1;
                }
            } else if (node.match( /^<\w[^>]*[^\/]>.*$/ )) {
                indent = 1;
            } else {
                indent = 0;
            }

            var padding = "";
            for (var i = 0; i < pad; i++) {
                padding += "  ";
            }

            formatted += padding + node + "\r\n";
            pad += indent;
        });
        return formatted;
    };

    //Gets a settings array and a json-ified version of the XML,
    //sets each the relevant settings and returns the settings object with 
    //{oldValue: XXXX, newValue: YYYY} as values
    //WARNING: Destructively modifies obj
    gpii.settingsHandlers.XMLHandler.applySettings = function (settings, obj) {
        var returnPayload = {};
        //edit each of the settings
        fluid.each(settings, function(value, el) {
            //store the previous value
            var prev = fluid.get(obj, el, getParser);            
            fluid.set(obj, el, value, setParser);
            
            //create entry in the return payload
            returnPayload[el] = { oldValue: prev, newValue: value };
        });
        return returnPayload;                
    };

    /**
     * Reads XML file and returns the equivalent transformed JSON structure
     * (array transformed to objects if given in knownArrays or detected
     * as using 'name' as pivot element)
    */
    gpii.settingsHandlers.XMLHandler.readXMLFile = function (options) {
        if (options === undefined) {
            fluid.fail("readXMLFile: expected an options block defining filename and encoding");
        }
         //TODO check for and handle read errors
        var xmlString = fs.readFileSync(options.filename, options.encoding || "utf-8");
        //parse XML to JSON and apply the settings
        var json = xm.tojson(xmlString);
        return (options && options.rules) ? fluid.model.transformWithRules(json, options.rules) : json;
    };

    gpii.settingsHandlers.XMLHandler.writeXMLFile = function (json, options) {
        //Create XML - first line is the xml-tag from options if set
        var xml = options["xml-tag"] || "";
        //transform back
        var inverseRules = fluid.model.transform.invertConfiguration(options.rules);
        var inversedJSON = fluid.model.transformWithRules(json, inverseRules);

        xml += xm.toxml(inversedJSON);
        //and fix indentation/newlines so it's readable
        var formattedXML = gpii.settingsHandlers.XMLHandler.formatXml(xml);
        //TODO check for and handler write errors
        fs.writeFileSync(options.filename, formattedXML, options.encoding || "utf-8");
    };

    // TODO: For testing purposes, accept additional arguments in "solution.options" to
    // produce data via a callback rather than hardcoded to hit the filesystem
    
    // TODO: Rescue the algorithm gpii.invokeSettingsHandler from RegistrySettingsHandler.js 
    // line 226 and use it to simplify the loops of all settings handlers including this one
    gpii.settingsHandlers.XMLHandler.set = function (data) {
        var returnObj = fluid.copy(data);
        //each solution block
        return fluid.transform(returnObj, function (solution) {
            //each array entry in the solution block
            return fluid.transform(solution, function (solutionEntry) {
                var options = solutionEntry.options;
                var settings = solutionEntry.settings;
                //only valid if a filename is set in options, else ignore this block
                if (options && options.filename) {
                    //parse XML to JSON, apply the settings, and write the file.
                    var json = gpii.settingsHandlers.XMLHandler.readXMLFile(options);
                    var newSettingsResponse = gpii.settingsHandlers.XMLHandler.applySettings(settings, json);
                    gpii.settingsHandlers.XMLHandler.writeXMLFile(json, options);
                    solutionEntry.settings = newSettingsResponse;
                }
                return solutionEntry;   
            });
        });
    };
}());
