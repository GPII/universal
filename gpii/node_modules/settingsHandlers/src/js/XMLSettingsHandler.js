/*!
GPII XML Settings Handler

Copyright 2012 Raising the Floor - International

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

/*global require, console */
(function () {
    var fluid = require("infusion"),
        fs = require("fs"),
        xm = require('xml-mapping'),
        gpii = fluid.registerNamespace("gpii");

    fluid.registerNamespace("gpii.settingsHandlers.XMLHandler");

    //When fluid.get'ing, allow escaped strings
    var parser = {
        parser: {
            parse: fluid.pathUtil.parseEL,
            compose: fluid.pathUtil.composePath
        },
        strategies: [fluid.model.defaultFetchStrategy]
    };

    //http://stackoverflow.com/questions/376373/pretty-printing-xml-with-javascript
    var formatXml = function (xml) {
        var formatted = '';
        var reg = /(>)(<)(\/*)/g;
        xml = xml.replace(reg, '$1\r\n$2$3');
        var pad = 0;
        fluid.each(xml.split('\r\n'), function(node, index) {
            var indent = 0;
            if (node.match( /.+<\/\w[^>]*>$/ )) {
                indent = 0;
            } else if (node.match( /^<\/\w/ )) {
                if (pad !== 0) {
                    pad -= 1;
                }
            } else if (node.match( /^<\w[^>]*[^\/]>.*$/ )) {
                indent = 1;
            } else {
                indent = 0;
            }

            var padding = '';
            for (var i = 0; i < pad; i++) {
                padding += '  ';
            }

            formatted += padding + node + '\r\n';
            pad += indent;
        });
        return formatted;
    };

    /**
     * Splits elPath on the last (tail) path.
     * @param elPath: an elPath - can be escaped
     * @return: array with index 0: elPath excluding last part (after . (dot)) and index 1 the last part (after last .)
     */
    var splitTailPath = function (elPath) {
        var matches = elPath.match(/(.*[^\\])\.((\\\.|[^\.])+)$/);
        return (matches && matches.length >= 2) ? [ matches[1], matches[2] ] : [ elPath ]; 
    };

    /**
     * Given a variable, checks that it's indeed an array
     * and that _all_ the objects within that array, has a 
     * key of the name given in pivot. Unless both of these hold
     * true, false is returned. 
     * This function is used to find whether an array is transformable
     * according to the reuqirement of the XML handler.
     *
     * @param arr: the array (or other type) to check
     * @param pivot: The name of the key required to be present in the arrays objects
     * @return true if it's an array, and all objects in the array have a key with the
     *         name given in the pivot parameter
     */
    var validateArray = function (arr, pivot) {
        //TODO: Can't this just be replaced by a fluid.get with *?
        //for each array entry check that object with key pivot exists
        for (var i=0; i<arr.length; ++i) {
            if (!fluid.get(arr[i], pivot, parser)) {
                return false;
            }
        }
        return true;
    };

    /**
     * Transforms the given array to an object, using the values from the elements with key /pivot/
     * as new keys. So for pivot = "foo" and the arr: 
     * [ { "foo": "bar1", "other": 2}, { "foo": "bar2", "other2": 100}]
     *  we would get:
     * { bar1: { other: 2}, bar2: {other2: 100 }}
     */
    var transformFromArray = function (arr, pivot) {    
        var transformed = {};
        var rmchk =  function (v,k) { return fluid.pathUtil.escapeSegment(k) === pivot; };
        for (var i=0; i<arr.length; ++i) {
            //use the value of the pivot element as key and use the remaining content as value
            transformed[fluid.get(arr[i], pivot, parser)] = fluid.remove_if(arr[i], rmchk);
        }
        return transformed;
    };


    gpii.settingsHandlers.XMLHandler.transformArrays = function (json, knownArrays) {
        fluid.copy(json);
        var path = "";
        var transformedPaths = [];
        // console.log("called with "+JSON.stringify(json)+ "(path: "+path+") and known arrays: "+knownArrays);
        var pathFinderImpl = function (list, path) {
            return fluid.transform(list, function (v, k) {
                var newPath = fluid.pathUtil.composePath(path, k);
                //console.log("transform called with "+JSON.stringify(v)+" and new path: "+path);
                if (fluid.isPrimitive(v)) {
                    return v;
                } else if (fluid.isArrayable(v)) {
                    var pivot = "name"; //use 'name' as key parameter unless otherwise declared
                    var known = false;
                    //check for other declarations of pivot
                    for (var i=0; i<knownArrays.length; i++) {
                        //check if it declared in knownArrays[i] with the last pivot (index) removed from elpath 
                        var segments = splitTailPath(knownArrays[i]);
                        // console.log("=================comparing first entry of segments: -"+segments+"- with "+newPath);
                        if (segments && segments.length === 2 && segments[0] === newPath) {
                            // console.log("Matches: "+JSON.stringify(segments));
                            pivot = segments[1];
                            known = true;
                            break;
                        }
                    }

                    if (validateArray(v, pivot)) {
                        if (!known) {
                            transformedPaths.push(newPath+"."+pivot);
                        }
                        // console.log("XML Settings handler transforming path: "+newPath);
                        return pathFinderImpl(transformFromArray(v, pivot), newPath);
                    }
                }
                return pathFinderImpl(v, newPath);
            });  
        };
        var ret = pathFinderImpl({root: json}, path);
        
        return { 
            pathArray: knownArrays.concat(transformedPaths), 
            knownArrays: knownArrays,
            root: ret.root
        };
    };


    var revertArray = function(json, pivot) {
        // console.log("reverting: "+JSON.stringify(json)+" based on "+pivot);
        var arr = [];
        fluid.each(json, function(v, k) {
            //The below three lines should be replaced by:
            // v[pivot.replace(/\\./g, ".")] = k;
            //but due to the xm.toxml function is dependent on the order of objects (sigh)
            //the pivot element needs to be first
            var tmp = {};
            tmp[pivot.replace(/\\./g, ".")] = k;
            fluid.merge("replace", tmp, v);
            arr.push(tmp);
        });
        return arr;
    };

    gpii.settingsHandlers.XMLHandler.revertArrays = function (json, knownArrays) {
        if (!knownArrays) return json;

        json = fluid.copy(json);
        var lookup = {};
        //we want to transform inner arrays first, so save lengths of each array we know:
        for (var i=0; i<knownArrays.length; ++i) {
            var matches = knownArrays[i].match(/([^\\]\.)/g);
            // console.log("After match: "+matches);
            lookup[knownArrays[i]] = (matches) ? matches.length+1 : 1;
        }
        // console.log(JSON.stringify(lookup)+" ================");
        var sorted = knownArrays.sort(function(a, b) { return lookup[b] - lookup[a];});
        for (i=0; i<sorted.length; ++i) {
            var segments = splitTailPath(sorted[i]);
            var tmp = fluid.get(json, segments[0], parser);
            var reverted = revertArray(tmp, segments[1]);
            // console.log("======================================================\n"+
            //     "Setting: "+JSON.stringify(json)+"\n"+
            //     "elpath: "+JSON.stringify(segments[0])+"\n"+
            //     "replacing with: "+JSON.stringify(reverted)+"\n"+
            //     "=====================================================");
            fluid.set(json, segments[0], reverted, parser);
            // console.log("New JSON: "+JSON.stringify(json));
        }
        // console.log("Returning "+JSON.stringify(json));
        return json;
    };

    var createFromEL = function (root, el, value) {
        // console.log("createFromEL: "+el+" in "+JSON.stringify(root));
        var headPath = fluid.pathUtil.getHeadPath(el);
        var fromHeadPath = fluid.pathUtil.getFromHeadPath(el);
        // var currentObj = fluid.get(root, headPath, parser);
        if (root[headPath]) {
            return createFromEL(root[headPath], fromHeadPath, value);
        } else {
            if (!fromHeadPath) {
                root[headPath] = value;
                return { oldValue: undefined, newValue: value };
            } else {
                root[headPath] = {};
                return createFromEL(root[headPath], fromHeadPath, value);
            }
        }
    };


    //Gets a settings array and a json-ified version of the XML,
    //sets each the relevant settings and returns the settings object with 
    //{oldValue: XXXX, newValue: YYYY} as values
    gpii.settingsHandlers.XMLHandler.applySettings = function (settings, obj) {
        var returnPayload = {};
        //edit each of the settings
        fluid.each(settings, function(value, el) {
            //store the previous value
            var prev = fluid.get(obj, el, parser);
            if (!prev) {                
                // console.log("EL: "+el+" In array: "+JSON.stringify(obj));
                createFromEL(obj, el, value);
            } else {
                //set the new value
                fluid.set(obj, el, value, parser);
            }
            //create entry in the return payload
            returnPayload[el] = { oldValue: prev, newValue: value };
        });
        return returnPayload;
    };
   
    gpii.settingsHandlers.XMLHandler.readXMLFile = function (filename, encoding, knownArrays) {
         //TODO check for and handle read errors
        var xmlString = fs.readFileSync(filename, encoding || "utf-8");
        // //parse XML to JSON and apply the settings
        var json = xm.tojson(xmlString);
        return gpii.settingsHandlers.XMLHandler.transformArrays(json, knownArrays || []);
    };

    var getELSubpaths = function (obj, elPath) {
        var toReturn = {};
        var json = fluid.get(obj.root, elPath, parser);

        var deepGetValues = function (root, path) {
            if (fluid.isPrimitive(root)) {
                toReturn[path] = root;
                return;
            } else if (fluid.isArrayable(root)) {
                fluid.log("Got reference to array on get - ignoring: "+path);
                return;
            } else { //recursive call for values
                fluid.each(root, function (v, k) {
                    deepGetValues(v, fluid.pathUtil.composePath(path, k));
                });
            }
        };
        deepGetValues(json, elPath);
        return toReturn;
    };


    gpii.settingsHandlers.XMLHandler.get = function (data) {
        var returnObj = fluid.copy(data);

        return fluid.transform(returnObj, function (solution, solutionId) {
            //each array entry in the solution block
            return fluid.transform(solution, function (solutionEntry) {
                var options = solutionEntry.options;
                var settings = solutionEntry.settings;
                //only valid if a filename is set in options, else ignore this block
                if (options && options.filename) {
                    var settingsFound = {};

                    //read XML file
                    var json = gpii.settingsHandlers.XMLHandler.readXMLFile(options.filename, options.encoding, options.knownArrays);
                    solutionEntry.options.knownArrays = json.knownArrays;
                    solutionEntry.options.pathArray = json.pathArray;
                    //get things we want:
                    fluid.each(settings, function(v, k) {
                        var tmp = getELSubpaths(json, k);
                        settingsFound = fluid.merge("replace", settingsFound, tmp);
                    });
                    solutionEntry.settings = settingsFound;
                } else {
                    //TODO implement error handling
                    fluid.log("Invalidly formed settings file for: "+solutionId+" - missing options or options.filename");
                }

                return solutionEntry;   
            });
        });
    };

    gpii.settingsHandlers.XMLHandler.set = function (data) {
        var returnObj = fluid.copy(data);
      //each solution block
        return fluid.transform(returnObj, function (solution, solutionId) {
            //each array entry in the solution block
            return fluid.transform(solution, function (solutionEntry) {
                var options = solutionEntry.options;
                var settings = solutionEntry.settings;
                //only valid if a filename is set in options, else ignore this block
                if (options && options.filename) {
                    //read XML file
                    var json = gpii.settingsHandlers.XMLHandler.readXMLFile(options.filename, options.encoding, options.knownArrays);
                    // console.log("RETURNED: "+JSON.stringify(json));
                    solutionEntry.options.pathArray = json.pathArray;
                    //return;
                    var newSettingsResponse = gpii.settingsHandlers.XMLHandler.applySettings(settings, json.root);
                    // console.log("SETTINGS REPSONSE: "+JSON.stringify(newSettingsResponse));
                    //Create XML - first line is the xml-tag from options if set
                    //the remaining file is our modified json converted to XML
                    var xml = options["xml-tag"] || "";
                    var revertedJSON = gpii.settingsHandlers.XMLHandler.revertArrays({ root: json.root}, json.pathArray);
                    xml += xm.toxml(revertedJSON.root);

                    //ensure text formatting is correct
                    var formatting = { "&": "&amp;" };
                    fluid.each(formatting, function(to, from) {
                        xml = xml.replace(new RegExp(from, "g"), to);
                    });
                    //and fix indentation/newlines so it's readable
                    var formattedXML = formatXml(xml);
                    //TODO check for and handler write errors
                    fs.writeFileSync(options.filename, formattedXML, options.encoding || "utf-8");
                    solutionEntry.settings = newSettingsResponse;
                    // console.log("SETTINGS REPSONSE: "+JSON.stringify(solutionEntry.settings));
                }
                // console.log("FINAL REPSONSE: "+JSON.stringify(solutionEntry));

                return solutionEntry;   
            });
        });
    };
}());
