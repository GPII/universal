/*!
GPII Settings Handler Utilities

Copyright 2013 OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

The research leading to these results has received funding from the European Union's
Seventh Framework Programme (FP7/2007-2013) under grant agreement no. 289016.

You may obtain a copy of the License at
https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

"use strict";

var fluid = fluid || require("infusion"),
    fs = typeof(require) === "undefined" ? null : require("fs"), // courtesy to run web-based tests for partial file contents
    kettle = fluid.registerNamespace("kettle"),
    gpii = fluid.registerNamespace("gpii");

/***************************************************************************************************
 * Low-level settings handler utilities, of use to practically anyone dealing with settings handlers
 */

// A useful utility to defer an activity by a fixed time, together with the necessary callback wrapping
// This or an equivalent MUST be used by anyone within the GPII who wishes to defer an activity
gpii.invokeLater = function (callback, time) {
    var wrapped = kettle.wrapCallback ? kettle.wrapCallback(callback) : callback;
    return time ? setTimeout(wrapped, time) : fluid.invokeLater(wrapped);
};

// Low-quality utility to force resolution of a value which is known to be either
// a plain value or a synchronous promise
gpii.resolveSync = function (response) {
    if (fluid.isPromise(response)) {
        response.then(function (resolved) {
            response = resolved;
        });
    }
    return response;
};

// Coerce a value or promise to a promise - this should really go in the core framework
gpii.toPromise = function (value) {
    if (fluid.isPromise(value)) {
        return value;
    } else {
        var togo = fluid.promise();
        togo.resolve(value);
        return togo;
    }
};

fluid.registerNamespace("gpii.settingsHandlers");

/**
 * Filters out all the settings from the `settings` argument which are
 * not in the `supportedSettings` argument
 *
 * @param {Object} settings - Object in which each key is a setting name that is to be filtered. This
 *     object will be modified.
 * @param {Object} supportedSettings - Object in which each key is a setting name that will be filtered by.
 * @return {Object} The `settings`, filtered by the `supportedSettings` entries, meaning that
 *    any setting that is not in supportedSettings will not be in the return object.
 */
gpii.settingsHandlers.filterSupportedSettings = function (settings, supportedSettings) {
    if (supportedSettings === undefined || settings === undefined) {
        return settings;
    } else {
        var filteredSettings = {};
        // we cant simply use fluid.filterKeys because that wont handle the cases where
        // there are 'undefined' values for the keys in handlerSpec.settings
        for (var settingName in supportedSettings) {
            if (settingName in settings) {
                filteredSettings[settingName] = settings[settingName];
            }
        }
        return filteredSettings;
    }
};

// TODO: These utilities all clearly form part of some wider idiom of "payload handling" without some underpinnings
// for which they are rather hard to follow. For example, they could benefit from some form of "JSON type system"
// (whether provided via JSON schema or otherwise) in order to provide landmarks within the payloads, as well
// as actually validating arguments to these functions and payloads in general.
// cf. some vaguely related art in F# "Type Providers": http://fsharp.github.io/FSharp.Data/library/JsonProvider.html

/** A general utility function which helps in transforming settings handler payloads - these algorithms generally
 * must iterate over the two levels of containment (per-solution, per-settings) and then apply some transform
 * to the nested values
 * @param {Object} payload - A settings handler payload (either GET/SET response or return). The top-level keys will be solution ids.
 * @param {Function} handler - A function whose signature is (oneSetting, [path], oneSolution) where -
 *    - oneSetting is the nested payload (i.e. the level containing "settings"/"options")
 *    - path is an array holding the path to this payload i.e. [solutionId, index]
 *    - oneSolution is the payload at the outer level of containment - i.e. payload[solutionId]
 * @return {Object} The transformed payload-structured value.
 */
gpii.settingsHandlers.transformPayload = function (payload, handler) {
    return fluid.transform(payload, function (oneSolution, solutionId) {
        return fluid.transform(oneSolution, function (oneSetting, settingPath) {
            var path = [solutionId, settingPath];
            return handler(oneSetting, path, oneSolution);
        });
    });
};

/** Transform the settings for one solution's worth of settings by a supplied transform.
 * @param {Object} oneSolution - One solution's worth of settings, with a member named `settings` containing a free hash of the settings indexed by settingsHandlerBlock name.
 * @param {Function} handler - A transformer whose signature is the same as the 2nd argument to gpii.settingsHandlers.transformPayload.
 * @param {Array of String} [path] - [optional] An array of path segments holding the path of oneSolution within an overall payload - this will be used to form the 2nd argument of `handler`.
*/

gpii.settingsHandlers.transformOneSolutionSettings = function (oneSolution, handler, path) {
    if (!fluid.isPlainObject(oneSolution)) {
        return oneSolution;
    }
    path = path || [];
    var togo = fluid.censorKeys(oneSolution, "settings");
    var newSettings = fluid.transform(oneSolution.settings, function (oneSetting, settingKey) {
        var innerPath = path.concat(["settings", settingKey]);
        return handler(oneSetting, innerPath, oneSolution);
    });
    if (newSettings !== undefined) { // ignore undefined settings blocks
        togo.settings = newSettings;
    }

    return togo;
};

/* As for gpii.settingsHandlers.transformPayload, only the transform runs one level deeper and iterates over any
 * "settings" block held within the payload.
 */

gpii.settingsHandlers.transformPayloadSettings = function (payload, handler) {
    return gpii.settingsHandlers.transformPayload(payload, function (oneSolution, path) {
        return gpii.settingsHandlers.transformOneSolutionSettings(oneSolution, handler, path);
    });
};

/* Extract just the settings (eliminating "options") from the nested settingsHandler blocks for a full payload (top-level keys are solution ids)
 * - this is used from gpii.settingsHandlers.comparePayloads and gpii.test.checkConfiguration
 */
gpii.settingsHandlers.extractSettingsBlocks = function (payload) {
    return gpii.settingsHandlers.transformPayload(payload, function (oneSolution) {
        return fluid.filterKeys(oneSolution, "settings");
    });
};

// A utility which will accept a payload and convert all leaf values to numbers which may validly be. This
// is useful for settings handlers such as the INI settings handler which only really have a concept of strings
// as leaf values - without this postprocessing, roundtripping data through the handler is harder. This is
// primarly just a courtesy to make mock settings handlers easier to write.
gpii.settingsHandlers.numberify = function (payload) {
    if (typeof(payload) === "string") {
        return isFinite(payload) ? Number(payload) : payload;
    } else if (fluid.isPrimitive(payload)) {
        return payload;
    } else {
        return fluid.transform(payload, function (value) {
            return gpii.settingsHandlers.numberify(value);
        });
    }
};

/** A general utility for invoking a settings handler, given a function for handling a single setting
 * @param {Function} handler - A function processing a single solution's entries.
 * @param {Object} payload - The full payload as supplied to the settings handler's top-level method
 * @return {Promise} A promise yielding the combined payload expected from a top-level settings handler - this
 * will resolve synchronously if the supplied handler function is synchronous ("ZALGO" notwithstanding).
 **/
gpii.settingsHandlers.invokeSettingsHandler = function (handler, payload) {
    var worklist = [];
    var response = gpii.settingsHandlers.transformPayload(payload, function (element, path) {
        var solutionId = path[0]; // first entry of path will always be solution ID
        // Note shallow copy performed within filterKeys
        var directLoad = fluid.filterKeys(element, ["settings", "options"]);
        var others = fluid.censorKeys(element, ["settings", "options"]);
        worklist.push({
            path: path,
            result: handler(directLoad, solutionId),
            others: others
        });
        return {}; // construct isomorphic skeleton of response
    });
    var sequence = fluid.promise.sequence(fluid.getMembers(worklist, "result"));
    var togo = fluid.promise();
    sequence.then(function (resolved) {
        fluid.each(resolved, function (oneResolve, i) {
            // shallow copy to avoid trashing any "undefined" values in returned payload
            var combined = fluid.extend({settings: oneResolve}, worklist[i].others);
            fluid.set(response, worklist[i].path, combined);
        });
        togo.resolve(response);
    }, togo.reject);
    return togo;
};

/** Utilities for converting to and from concrete settings to ChangeApplier requests
 * to enact those settings. On the "get" or "set" settingsHandler returns, we receive
 * concrete settings, which need to be modelised so that they can safely be stored and persisted.
 * In future, the "set" action will accept these requests as they are, but for now we need to
 * convert them back using "changesToSettings" to adapt to the historical API.
 */

// Firstly two utilities which transform an individual settings value from one format to the other

gpii.settingsHandlers.settingsToChanges = function (element) {
    return element === undefined ? {
        type: "DELETE"
    } : {
        type: "ADD",
        value: element
    };
};

gpii.settingsHandlers.changesToSettings = function (element) {
    // Preserve element.path is to satisfy the SPI settings handler requirment, particularly the high contrast use of it:
    // https://issues.gpii.net/browse/GPII-3452. The plan is to get rid of this logic once there aren't any more examples
    // of this in the solution registry.
    return element.type === "DELETE" ? undefined : element.path ? {
        path: element.path,
        value: element.value
    } : element.value;
};

// Secondly two utilities which do the same for an entire solution's worth of payloads as used in the LifecycleManager

gpii.settingsHandlers.settingsPayloadToChanges = function (response) {
    return gpii.settingsHandlers.transformPayloadSettings(response, gpii.settingsHandlers.settingsToChanges);
};

gpii.settingsHandlers.changesPayloadToSettings = function (response) {
    return gpii.settingsHandlers.transformPayloadSettings(response, gpii.settingsHandlers.changesToSettings);
};


/** Invoked by, e.g., the LifecycleManager to convert the SET response from a settingsHandler
 * to a form where it can be immediately relayed back to another SET handler to
 * restore the original settings values
 */

gpii.settingsHandlers.setResponseToSnapshot = function (response) {
    return gpii.settingsHandlers.transformPayloadSettings(response, function (element) {
        return element.oldValue;
    });
};


/************************************************************************
 * Utilities for automatically retrying settings handlers.
 */

gpii.settingsHandlers.comparePayloads = function (payload1, payload2) {
    var settings1 = gpii.settingsHandlers.extractSettingsBlocks(payload1);
    var settings2 = gpii.settingsHandlers.extractSettingsBlocks(payload2);
    var equal = fluid.model.diff(settings1, settings2);
    if (!equal) {
        fluid.log(fluid.logLevel.WARN, "Comparing payload ", JSON.stringify(settings1, null, 2), " with ", JSON.stringify(settings2, null, 2), " equal: " + equal);
    }
    return equal;
};

gpii.settingsHandlers.checkRereadSettings = function (that) {
    if (that.retryOptions.rewriteEvery && !fluid.resolveContext("gpii.contexts.test", that)) {
        fluid.fail("rewriteEvery is set to " + that.retryOptions.rewriteEvery
            + ": this facility should only be used in integration or unit tests");
    }
    // Note that this feature is now configured away as described in GPII-2522, although it is still (partially) tested
    var writeAttempt = that.retryOptions.rewriteEvery && (that.retries % that.retryOptions.rewriteEvery === 0);
    if (writeAttempt) {
        fluid.log(fluid.logLevel.WARN,
            "Stored settings have not settled to required values at attempt " + that.retries +
            ": attempting to rewrite");
    }
    // TODO: This will currently corrupt the SET response of a genuinely async set handler
    var response = gpii.resolveSync(fluid.invokeGlobalFunction(that.resolvedName + (writeAttempt ? ".set" : ".get"), [that.payload]));
    var getResponse = writeAttempt ? gpii.settingsHandlers.setResponseToSnapshot(response) : response;
    var equal = gpii.settingsHandlers.comparePayloads(getResponse, that.payload);
    if (equal) {
        that.togo.resolve(that.originalSetPayload);
    } else {
        ++that.retries;
        if (that.retries === that.retryOptions.numRetries) {
            fluid.log(fluid.logLevel.WARN, "Maximum retry count exceeded in settings handler " +
                that.resolvedName + " at retry " + that.retries + ": rejecting settings action");
            that.togo.reject({
                isError: true,
                message: "Failure to read settings for handler " + that.resolvedName + " as written after " + that.retries + " retries"
            });
        } else {
            fluid.log(fluid.logLevel.WARN, "Settings have not settled to required values - retrying read at attempt " +
                that.retries + " of " + that.retryOptions.numRetries + " in " + that.retryOptions.retryInterval + "ms");
            gpii.invokeLater(that.checkRereadSettings, that.retryOptions.retryInterval);
        }
    }
};

gpii.settingsHandlers.dispatchSettingsHandler = function (resolvedName, payload, operation, retryOptions) {
    return (operation === "get") ?
        gpii.settingsHandlers.dispatchSettingsHandlerGet(resolvedName, payload) :
        gpii.settingsHandlers.dispatchSettingsHandlerSet(resolvedName, payload, retryOptions);
};

/**
 * Called to invoke settings handlers' get functionality.

 * Structure of 'payload' argument is:
 * {
 *    "some.app.id": [{
 *         "settings": { ... },
 *         "options": {
 *             ...
 *         }
 *    }]
 *  }
 * @param {String} resolvedName - The resolved "trunk name" of the settings handler to be invoked - e.g. gpii.windows.registrySettingsHandler.
 * @param {Object} payload - The full payload that would be sent to the SET method of the settings handler
 * @return {Promise} A promise that will yield the original payload of the invoked GET method.
 */
gpii.settingsHandlers.dispatchSettingsHandlerGet = function (resolvedName, payload) {
    // TODO "gpii.lifecycleManager.specToSettingsHandler" is the one responsible for this awkward
    //   layout of the settings handler payload - all of this infrastructure will have to be updated
    //   and cleaned up at some point
    try {
        return gpii.settingsHandlers.invokeGetHandler(resolvedName, payload);
    } catch (e) {
        fluid.log(fluid.logLevel.WARN, "Error received when dispatching settingsHandler.get " + resolvedName + " with payload ",
            payload, ": " + e);
        return fluid.promise().reject(e);
    }
};

/**
 * Called to invoke settings handlers' set function.
 * @param {String} resolvedName - The resolved "trunk name" of the settings handler to be invoked - e.g. gpii.windows.registrySettingsHandler.
 * @param {Object} payload - The full payload that would be sent to the SET method of the settings handler.
 * @return {Promise} a promise that will yield the original payload of the invoked SET method. In the case
 *     that retrying is enabled, a rejection occurs if the GET payloads never match after the end of the nominated retry period
 */
gpii.settingsHandlers.dispatchSettingsHandlerSet = function (resolvedName, payload) {
    // TODO "gpii.lifecycleManager.specToSettingsHandler" is the one responsible for this awkward
    //   layout of the settings handler payload - all of this infrastructure will have to be updated
    //   and cleaned up at some point
    try {
        return gpii.settingsHandlers.invokeSetHandler(resolvedName, payload);
    } catch (e) {
        fluid.log(fluid.logLevel.WARN, "Error received when dispatching settingsHandler.set " + resolvedName + " with payload ",
            payload, ": " + e);
        return fluid.promise().reject(e);
    }
};

gpii.settingsHandlers.invokeGetHandler = function (resolvedName, payload) {
    return gpii.toPromise(fluid.invokeGlobalFunction(resolvedName + ".get", [payload]));
};

gpii.settingsHandlers.invokeSetHandler = function (resolvedName, payload) {
    return gpii.toPromise(fluid.invokeGlobalFunction(resolvedName + ".set", [payload]));
};

/****************************************************************
 * Two moderately generic utilities for handling "standard" settings handlers whose
 * data is backed by some kind of free-form in-memory JSON-like structure. These are called
 * called by the file-based getters and setters.
 */

gpii.settingsHandlers.getSettings = function (solutionEntry, currentSettings) {
    var newSettingsResponse = {};
    var userRequestedSettings = solutionEntry.settings;

    fluid.each(userRequestedSettings, function (settingVal, settingKey) {
        var value = fluid.get(currentSettings, settingKey, fluid.model.escapedGetConfig);
        newSettingsResponse[settingKey] = value;
    });

    return {
        settings: newSettingsResponse
    };
};

gpii.settingsHandlers.setSettings = function (solutionEntry, currentSettings) {
    var newSettingsResponse = {};
    var userRequestedSettings = solutionEntry.settings;
    var options = solutionEntry.options;
    var holder = {
        model: currentSettings
    };
    var applier = fluid.makeHolderChangeApplier(holder, {
        resolverGetConfig: fluid.model.escapedGetConfig,
        resolverSetConfig: fluid.model.escapedSetConfig
    });

    // record differences between required and default settings
    // so that the default settings can be restored
    fluid.each(userRequestedSettings, function (settingVal, settingKey) {
        var oldValue = fluid.get(holder.model, settingKey, fluid.model.escapedGetConfig);
        var change = {
            path: settingKey,
            value: settingVal
        };
        change.type = settingVal === undefined ? "DELETE" : "ADD";
        applier.fireChangeRequest(change);
        newSettingsResponse[settingKey] = {
            "oldValue": oldValue,
            "newValue": settingVal
        };
    });
    if (currentSettings !== holder.model) {
        // TODO: Re-understand again exactly why this is, and eliminate it
        fluid.clear(currentSettings); // We have a silly model based on object reference identity
        fluid.extend(currentSettings, holder.model);
    }
    return { options: options, settings: newSettingsResponse };
};

/**************** FILE DEPENDENCE BELOW THIS POINT *********************/

gpii.settingsHandlers.readFile = function (options) {
    if (!options || !options.filename) {
        fluid.fail("readFile: expected an options block defining filename and encoding");
    } else if (!fs.existsSync(options.filename)) {
        fluid.log("readFile: No settingsfile '", options.filename, "'' exists. reporting " +
            "'undefined' as current settings");
        return undefined;
    }

    // TODO check for and handle read errors
    var content = fs.readFileSync(options.filename, options.encoding || "utf-8");
    return content;
};

gpii.settingsHandlers.writeFile = function (content, options) {
    if (!options || !options.filename) {
        fluid.fail("writeFile: expected an options block defining filename and encoding");
    }
    // TODO check for and handle write errors.
    fs.writeFileSync(options.filename, content, options.encoding || "utf-8");
};

/**
 * A parser for settings handler types that includes `parse` and `stringify` functions to allow reading and
 * serialization for each filetype. For example `JSON`, `INI`, and `XML` formats would each have their own parsers for
 * this.
 *
 * @typedef {Object} gpii.settingsHandlers.parser
 * @property {gpii.settinghandlers.parser.parse} parse - Parses the data read from a file on disk or other source.
 * @property {gpii.settinghandlers.parser.stringify} stringify - Serializes the settings data back to a string to be
 * written to disk.
 */

/**
 * Parses the data read from a file on disk or other source.
 *
 * @typedef {Function} gpii.settinghandlers.parser.parse
 * @param {Object} parse.content - The file contents.
 * @param {Object} parse.options - The `options` block from the settings handler configuration for these settings.
 */

/**
 * Serializes the settings data back to a string to be written to disk.
 *
 * @typedef {Function} gpii.settinghandlers.parser.stringify
 * @param {Object} stringify.settings - The solution settings for this configuration.
 * @param {Object} stringify.options - The `options` block from the settings handler configuration for these settings.
 */

/**
 * `fetcher` is a function that returns a path to the file containing the data for this settings handler. This allows
 * dynamic resolution of the file during the life cycle. The original purpose and example for this was the current user
 * profile in JAWS, which is stored in another system settings file. This allows the current user profile setting and
 * file to be looked up and used to find the settings for the current handler.
 *
 * @typedef {Function} gpii.settingsHandlers.fetcher
 * @param {Object} options - The `options` block from the settings handler configuration for these settings.
 */

/*
 * Utility for file-based settings handler. Handle individual solution entry data. The 'modifier' function passed as
 * parameter is called to allow editing of the solutionEntry based on the
 * current settings (both passed as parameters to the modifier function)
 */
gpii.settingsHandlers.handleFileSolutionEntry = function (solutionEntry, modifier, parser, isWrite, fetcher) {
    var options = fluid.copy(solutionEntry.options);

    if (options && (options.path || options.filename)) {
        // fetch the target file to read
        if (fetcher) {
            options.filename = fetcher(options);
        }
        // read file - returns undefined if it doesn't exist
        var content = gpii.settingsHandlers.readFile(options);
        // if the file is non-existing, current settings are {}, else they're the parsed content of the file
        var currentSettings = (content === undefined) ? {} : parser.parse(content, options);

        // modification of the entry
        var settings = modifier(solutionEntry, currentSettings);
        if (isWrite) {
            solutionEntry.settings = currentSettings;
            var settingsData = parser.stringify(currentSettings, options);
            gpii.settingsHandlers.writeFile(settingsData, options);
        }
        return settings;
    }

    return solutionEntry;
};

/*
 * Function for looping through the payload sent to get/set calls. Looping
 * is done by fluid.transform calls, and at the level of each solution
 * entry.
 */
gpii.settingsHandlers.transformFilePayload = function (payload, modifier, parser, isWrite, fetcher) {
    return gpii.settingsHandlers.transformPayload(payload, function (solutionEntry) {
        return gpii.settingsHandlers.handleFileSolutionEntry(solutionEntry, modifier, parser, isWrite, fetcher);
    });
};

/**
 * Used for defining settings handler `get` functions supporting different file types. The supplied `parser` and
 * `fetcher` will be specific to the file format and settings handler.
 *
 * @param {gpii.settingsHandlers.parser} parser - Parser for the file contents.
 * @param {gpii.settingsHandlers.fetcher} fetcher - Optional fetcher to adjust the filename dynamically.
 * @return {Object} GPII Settings from the file.
 */
gpii.settingsHandlers.makeFileGet = function (parser, fetcher) {
    return function (payload) {
        return gpii.settingsHandlers.transformFilePayload(payload, gpii.settingsHandlers.getSettings, parser, false, fetcher);
    };
};

/**
 * Used for defining settings handler `set` functions supporting different file types. The supplied `parser` and
 * `fetcher` will be specific to the file format and settings handler.
 *
 * @param {gpii.settingsHandlers.parser} parser - Parser for the file contents.
 * @param {gpii.settingsHandlers.fetcher} fetcher - Optional fetcher to adjust the filename dynamically.
 * @return {String} Serialized GPII Settings to write to file.
 */
gpii.settingsHandlers.makeFileSet = function (parser, fetcher) {
    return function (payload) {
        return gpii.settingsHandlers.transformFilePayload(payload, gpii.settingsHandlers.setSettings, parser, true, fetcher);
    };
};

/**************** END OF FILE DEPENDENCE *********************/

/*
 * Given two settingsHandler blocks, copy the settings (even those with a value of undefined) from
 * the source to the target - overwriting the target settings. Note that the keys/values immediately
 * within the source settingshandler block (i.e. the named settinghandler sub blocks) must be present
 * in the target block structure
 * Also note that the target object *will be modified*
 */
gpii.settingsHandlers.copySettings = function (target, source) {
    for (var shName in source) {
        var shBlock = source[shName];
        for (var setting in shBlock.settings) { // will loop over undefined vals
            target[shName].settings[setting] = shBlock.settings[setting];
        }
    }
};
