/*!
GPII Settings Handler Utilities

Copyright 2013 OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

"use strict";

var fluid = fluid || require("infusion"),
    fs = typeof(require) === "undefined" ? null : require("fs"), // courtesy to run web-based tests for partial file contents
    $ = fluid.jQueryStandalone,
    kettle = fluid.registerNamespace("kettle"),
    gpii = fluid.registerNamespace("gpii");

/***************************************************************************************************
 * Low-level settings handler utilities, of use to practically anyone dealing with settings handlers
 */

// A useful utility to defer an activity by a fixed time, together with the necessary callback wrapping
// This or an equivalent MUST be used by anyone within the GPII who wishes to defer an activity
gpii.invokeLater = function (callback, time) {
    var wrapped = kettle.wrapCallback ? kettle.wrapCallback(callback) : callback;
    return time ? setTimeout(wrapped, time) : fluid.invokeLater(wrapped);
};

// Low-quality utility to force resolution of a value which is known to be either
// a plain value or a synchronous promise
gpii.resolveSync = function (response) {
    if (fluid.isPromise(response)) {
        response.then(function (resolved) {
            response = resolved;
        });
    }
    return response;
};

// Coerce a value or promise to a promise - this should really go in the core framework
gpii.toPromise = function (value) {
    if (fluid.isPromise(value)) {
        return value;
    } else {
        var togo = fluid.promise();
        togo.resolve(value);
        return togo;
    }
};

fluid.registerNamespace("gpii.settingsHandlers");

/* A general utility function which helps in transforming settings handler payloads - these algorithms generally
 * must iterate over the two levels of containment (per-solution, per-settings) and then apply some transform
 * to the nested values
 * @param payload {Object} A settings handler payload (either GET/SET response or return)
 * @param handler {Function} A function whose signature is (entry, [path], solution) where - 
 *    - entry is the nested payload (i.e. the level containing "settings"/"options"
 *    - path is an array holding the path to this payload i.e. [solutionId, index]
 *    - solution is the payload at the outer level of containment - i.e. payload[solutionId]
 * @return The transformed payload-structured value
 */
gpii.settingsHandlers.transformPayload = function (payload, handler) {
    return fluid.transform(payload, function (oneSolution, solutionPath) {
        return fluid.transform(oneSolution, function (element, elementPath) {
            var path = [solutionPath, elementPath];
            return handler(element, path, oneSolution);
        });
    });
};

/** As for gpii.settingsHandlers.transformPayload, only the transform runs one level deeper and iterates over any
 * "settings" block held within the payload.
 */

gpii.settingsHandlers.transformPayloadSettings = function (payload, handler) {
    return gpii.settingsHandlers.transformPayload(payload, function (element, path, oneSolution) {
        var settings = {}; // note that we don't use fluid.transform here to avoid destroying undefined values
        fluid.each(element.settings, function (oneSetting, settingKey) {
            var innerPath = path.concat(["settings", settingKey]);
            settings[settingKey] = handler(oneSetting, innerPath, element, oneSolution);
        });
        var togo = {settings: settings};
        return togo;
    });
};

gpii.settingsHandlers.extractSettingsBlocks = function (payload) {
    return gpii.settingsHandlers.transformPayloadSettings(payload, fluid.identity);
};

// A utility which will accept a payload and convert all leaf values to numbers which may validly be. This
// is useful for settings handlers such as the INI settings handler which only really have a concept of strings
// as leaf values - without this postprocessing, roundtripping data through the handler is harder. This is
// primarly just a courtesy to make mock settings handlers easier to write.
gpii.settingsHandlers.numberify = function (payload) {
    if (typeof(payload) === "string") {
        return isFinite(payload) ? Number(payload) : payload;
    } else if (fluid.isPrimitive(payload)) {
        return payload;
    } else {
        return fluid.transform(payload, function (value) {
            return gpii.settingsHandlers.numberify(value);
        });
    }
};

/** A general utility for invoking a settings handler, given a function for handling a single setting
 * @param handler A function processing a single solution's entries
 * @param payload The full payload as supplied to the settings handler's top-level method
 * @return A promise yielding the combined payload expected from a top-level settings handler - this
 * will resolve synchronously if the supplied handler function is synchronous ("ZALGO" notwithstanding)
 **/

gpii.settingsHandlers.invokeSettingsHandler = function (handler, payload) {
    var worklist = [];
    var response = gpii.settingsHandlers.transformPayload(payload, function (element, path) {
        // Note shallow copy performed within filterKeys
        var directLoad = fluid.filterKeys(element, ["settings", "options"]);
        var others = fluid.censorKeys(element, ["settings", "options"]);
        worklist.push({
            path: path,
            result: handler(directLoad),
            others: others
        });
        return {}; // construct isomorphic skeleton of response
    });
    var sequence = fluid.promise.sequence(fluid.getMembers(worklist, "result"));
    var togo = fluid.promise();
    sequence.then(function (resolved) {
        fluid.each(resolved, function (oneResolve, i) {
            // shallow copy to avoid trashing any "undefined" values in returned payload
            var combined = $.extend({settings: oneResolve}, worklist[i].others);
            fluid.set(response, worklist[i].path, combined);
        });
        togo.resolve(response);
    }, togo.reject);
    return togo;
};



/************************************************************************
 * Utilities for automatically retrying settings handlers.
 * the entry point "invokeRetryingHandler" accepts the materials for invoking
 * a SET settings handler and converts them to a more deferred promise that will
 * repeatedly reread the settings via GET until they match those expected.
 */

gpii.settingsHandlers.comparePayloads = function (payload1, payload2) {
    var settings1 = gpii.settingsHandlers.extractSettingsBlocks(payload1);
    var settings2 = gpii.settingsHandlers.extractSettingsBlocks(payload2);
    var equal = fluid.model.diff(settings1, settings2);
    if (!equal) {
        fluid.log(fluid.logLevel.WARN, "Comparing payload ", JSON.stringify(settings1, null, 2), " with ", JSON.stringify(settings2, null, 2), " equal: " + equal);
    }
    return equal;
};

gpii.settingsHandlers.setResponseToSnapshot = function (response) {
    return gpii.settingsHandlers.transformPayloadSettings(response, function (element) {
        return element.oldValue;
    });
};

gpii.settingsHandlers.checkRereadSettings = function (that) {
    var writeAttempt = that.retryOptions.rewriteEvery && (that.retries % that.retryOptions.rewriteEvery === 0);
    if (writeAttempt) {
        fluid.log(fluid.logLevel.WARN,
            "Stored settings have not settled to required values at attempt " + that.retries +
            ": attempting to rewrite");
    }
    // TODO: This will currently corrupt the SET response of a genuinely async set handler
    var response = gpii.resolveSync(fluid.invokeGlobalFunction(that.resolvedName + (writeAttempt ? ".set" : ".get"), [that.payload]));
    var getResponse = writeAttempt ? gpii.settingsHandlers.setResponseToSnapshot(response) : response;
    var equal = gpii.settingsHandlers.comparePayloads(getResponse, that.payload);
    if (equal) {
        that.togo.resolve(that.originalSetPayload);
    } else {
        ++that.retries;
        if (that.retries === that.retryOptions.numRetries) {
            fluid.log(fluid.logLevel.WARN, "Maximum retry count exceeded in settings handler " +
                that.resolvedName + " at retry " + that.retries + ": rejecting settings action");
            that.togo.reject("Failure to read settings for handler " + that.resolvedName + " as written after " + that.retries + " retries");
        } else {
            fluid.log(fluid.logLevel.WARN, "Settings have not settled to required values - retrying read at attempt " +
                that.retries + " of " + that.retryOptions.numRetries + " in " + that.retryOptions.retryInterval + "ms");
            gpii.invokeLater(that.checkRereadSettings, that.retryOptions.retryInterval);
        }
    }
};

/** Main entry point for applying an automatically retrying settings handlers.
 * @param resolvedName {String} The resolved "trunk name" of the settings handler to be invoked - e.g. gpii.windows.registrySettingsHandler
 * @param payload {Object} The full payload that would be sent to the SET method of the settings handler
 * @param retryOptions {Object} Options governing the retry behaviour of the wrapped handler. This contains fields:
 *     numRetries {Integer} A positive integer holding the total number of retries to make
 *     retryInterval {Integer} A positive integer holder the delay in milliseconds between each retry 
 * @return a promise that will yield the original payload of the originally invoked SET method if the GET calls eventually produce a result
 * that matches, or else a rejection if the GET payloads never match after the end of the nominated retry period
 */

gpii.settingsHandlers.invokeRetryingHandler = function (resolvedName, payload, retryOptions) {
    var that = {
        retryOptions: retryOptions,
        retries: 1,
        payload: payload,
        resolvedName: resolvedName,
        togo: fluid.promise(),
        checkRereadSettings: function () {
            gpii.settingsHandlers.checkRereadSettings(that);
        }
    };
    var originalResponse = gpii.toPromise(fluid.invokeGlobalFunction(resolvedName + ".set", [payload]));
    originalResponse.then(function (setPayload) {
        that.originalSetPayload = setPayload;
        that.checkRereadSettings();
    });
    return that.togo;
};

/****************************************************************
 * Two moderately generic utilities for handling "standard" settings handlers whose
 * data is backed by some kind of free-form in-memory JSON-like structure. These are called
 * called by the file-based getters and setters.
 */

gpii.settingsHandlers.getSettings = function (solutionEntry, currentSettings) {
    var newSettingsResponse = {};
    var userRequestedSettings = solutionEntry.settings;

    fluid.each(userRequestedSettings, function (settingVal, settingKey) {
        var value = fluid.get(currentSettings, settingKey, fluid.model.escapedGetConfig);
        newSettingsResponse[settingKey] = value;
    });

    return {
        settings: newSettingsResponse
    };
};

gpii.settingsHandlers.setSettings = function (solutionEntry, currentSettings) {
    var newSettingsResponse = {};
    var userRequestedSettings = solutionEntry.settings;
    var options = solutionEntry.options;
    var applier = fluid.makeChangeApplier(currentSettings, {
        resolverGetConfig: fluid.model.escapedGetConfig,
        resolverSetConfig: fluid.model.escapedSetConfig
    });

    // record differences between required and default settings
    // so that they default settings can be restored
    fluid.each(userRequestedSettings, function (settingVal, settingKey) {
        var oldValue = fluid.get(currentSettings, settingKey, fluid.model.escapedGetConfig);
        var change = {
            path: settingKey,
            value: settingVal
        };
        change.type = settingVal === undefined ? "DELETE" : "ADD";
        applier.fireChangeRequest(change);
        newSettingsResponse[settingKey] = {
            "oldValue": oldValue,
            "newValue": settingVal
        };
    });
    return { options: options, settings: newSettingsResponse };
};



/**************** FILE DEPENDENCE BELOW THIS POINT *********************/

gpii.settingsHandlers.readFile = function (options) {
    if (!options || !options.filename) {
        fluid.fail("readFile: expected an options block defining filename and encoding");
    }
    // TODO check for and handle read errors
    var content = fs.readFileSync(options.filename, options.encoding || "utf-8");
    return content;
};

gpii.settingsHandlers.writeFile = function (content, options) {
    if (!options || !options.filename) {
        fluid.fail("writeFile: expected an options block defining filename and encoding");
    }
    // TODO check for and handle write errors.
    fs.writeFileSync(options.filename, content, options.encoding || "utf-8");
};


/**
 * Utility for file-based settings handler. Handle individual solution entry data. The 'modifier' function passed as
 * parameter is called to allow editing of the solutionEntry based on the
 * current settings (both passed as parameters to the modifier function)
 */
gpii.settingsHandlers.handleFileSolutionEntry = function (solutionEntry, modifier, parser, isWrite) {
    var options = solutionEntry.options;

    if (options && (options.path || options.filename)) {
        // read file
        var content = gpii.settingsHandlers.readFile(options);
        var currentSettings = parser.parse(content, options);
        // modification of the entry
        var settings = modifier(solutionEntry, currentSettings);
        if (isWrite) {
            solutionEntry.settings = currentSettings;
            var settingsData = parser.stringify(currentSettings, options);
            gpii.settingsHandlers.writeFile(settingsData, options);
        }
        return settings;
    }

    return solutionEntry;
};

/**
 * Function for looping through the payload sent to get/set calls. Looping
 * is done by fluid.transform calls, and at the level of each solution
 * entry.
 */
gpii.settingsHandlers.transformFilePayload = function (payload, modifier, parser, isWrite) {
    return gpii.settingsHandlers.transformPayload(payload, function (solutionEntry) {
        return gpii.settingsHandlers.handleFileSolutionEntry(solutionEntry, modifier, parser, isWrite);
    });
};

gpii.settingsHandlers.makeFileGet = function (parser) {
    return function (payload) {
        return gpii.settingsHandlers.transformFilePayload(payload, gpii.settingsHandlers.getSettings, parser);
    };
};

gpii.settingsHandlers.makeFileSet = function (parser) {
    return function (payload) {
        return gpii.settingsHandlers.transformFilePayload(payload, gpii.settingsHandlers.setSettings, parser, true);
    };
};

