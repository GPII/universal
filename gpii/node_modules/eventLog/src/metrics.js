/*
 * Metrics logging.
 * This acts upon events that are deemed interesting enough to be recorded and sent to a log server for analysis.
 *
 * Copyright 2017 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion");

var gpii = fluid.registerNamespace("gpii");

fluid.defaults("gpii.metrics", {
    gradeNames: ["fluid.modelComponent", "fluid.contextAware"],
    contextAwareness: {
        platform: {
            checks: {
                test: {
                    contextValue: "{gpii.contexts.test}",
                    gradeNames: "gpii.metrics.test"
                },
                windows: {
                    contextValue: "{gpii.contexts.windows}",
                    gradeNames: "gpii.windowsMetrics"
                }
            }
        },
        metrics: {
            checks: {
                standaloneMetrics: {
                    contextValue: "{gpii.contexts.standalone-metrics}"
                }
            },
            defaultGradeNames: "gpii.metrics.lifecycle"
        }
    },
    invokers: {
        logMetric: {
            func: "{eventLog}.logEvent",
            args: ["metrics", "{arguments}.0", "{arguments}.1"] // event, data
        }
    },
    members: {
        sessionSolutions: {}
    },
    events: {
        "onStartMetrics": null,
        "onStopMetrics": null
    }
});

// Mixin grade for gpii.metrics to log lifecycle manager things
fluid.defaults("gpii.metrics.lifecycle", {
    modelListeners: {
        "{lifecycleManager}.model.logonChange": {
            funcName: "gpii.metrics.logonStateChanged",
            args: ["{that}", "{lifecycleManager}", "{change}.oldValue", "{change}.value"]
        }
    },
    listeners: {
        "{lifecycleManager}.events.onCreate": {
            namespace: "trackPrefsSetChange",
            listener: "gpii.metrics.trackPrefsSetChange",
            args: ["{that}", "{lifecycleManager}"]
        },
        "{lifecycleManager}.events.onSessionStart": [
            {
                namespace: "eventLog",
                func: "{eventLog}.logEvent",
                args: [
                    "lifecycle",
                    "SessionStart",
                    {
                        // onSessionStart fired with [gradeName, gpiiKey]
                        gpiiKey: "{arguments}.1",
                        session: "@expand:{lifecycleManager}.getSession({arguments}.1)"
                    }
                ]
            }, {
                func: "{that}.events.onStartMetrics"
            }],
        "{lifecycleManager}.events.onSessionStop": [{
            namespace: "eventLog",
            func: "{eventLog}.logEvent",
            args: [
                "lifecycle",
                "SessionStop",
                {
                    // onSessionStop fired with [{lifecycleManager}, {session}]
                    gpiiKey: "{arguments}.1.model.gpiiKey",
                    session: "{arguments}.1.id"
                }
            ]
        }, {
            namespace: "metrics.session",
            funcName: "gpii.metrics.sessionStopped",
            args: ["{that}", "{arguments}.1.id"]
        }, {
            "func": "{that}.events.onStopMetrics",
            "priority": "before:eventLog"
        }],
        "{lifecycleManager}.events.onSessionSnapshotUpdate": {
            namespace: "metrics",
            funcName: "gpii.metrics.snapshotUpdate",
            args: ["{that}", "{arguments}.1.id", "{arguments}.2"]
        }
    }
});

/**
 * Attached as the lifecycleManager.onCreate event.
 *
 * Adds a model change listener to the user session's model to listen for changes to the preferences.
 *
 * @param {Component} that - The gpii.metrics instance.
 * @param {Component} lifecycleManager - The lifecycleManager instance.
 */
gpii.metrics.trackPrefsSetChange = function (that, lifecycleManager) {
    var userSession = lifecycleManager.getSession();
    userSession.applier.modelChanged.addListener({
        path: "preferences.contexts",
        excludeSource: "SessionCleanup"
    }, function (newValue, oldValue) {
        var current = newValue && newValue[userSession.model.activePrefsSetName];
        current = current && current.preferences;
        var previous = oldValue && oldValue[userSession.model.activePrefsSetName];
        previous = previous && previous.preferences;

        gpii.metrics.preferenceChanged(that, current, previous);
    });
};

/**
 * Log the solutions as they're applied.
 *
 * @param {Component} that - The gpii.metrics instance.
 * @param {String} sessionID - Session ID.
 * @param {Object} originalSettings - The original settings (only interested in the keys).
 */
gpii.metrics.snapshotUpdate = function (that, sessionID, originalSettings) {
    var ids = fluid.keys(originalSettings);
    var solutionIDs = that.sessionSolutions[sessionID];
    if (!solutionIDs) {
        solutionIDs = that.sessionSolutions[sessionID] = {};
    }
    // Log the solution IDs that haven't been logged.
    fluid.each(ids, function (id) {
        if (!solutionIDs[id]) {
            that.logMetric("solution-applied", {
                solutionID: id
            });
            solutionIDs[id] = true;
        }
    });
};

/**
 * Called when a preference has changed. (a change in the preferences field of the session's model.)
 *
 * @param {Comment} that - The gpii.metrics instance.
 * @param {Object} current - The current preferences map for the active preferences set.
 * @param {Object} previous - The previous preferences map for the active preferences set.
 */
gpii.metrics.preferenceChanged = function (that, current, previous) {
    var diff = { changeMap: {}, changes: 0, unchanged: 0};
    var same = fluid.model.diff(previous, current, diff);
    if (!same) {
        var changedPreferences;
        if (fluid.isPlainObject(diff.changeMap)) {
            changedPreferences = {};
            fluid.each(diff.changeMap, function (value, key) {
                if (value === "ADD") {
                    changedPreferences[key] = current[key];
                }
            });
        } else if (diff.changeMap === "ADD") {
            // Everything is new
            changedPreferences = current;
        }

        fluid.each(changedPreferences, function (value, name) {
            that.logMetric("preference", {
                name: name,
                value: value
            });
        });
    }
};

/**
 * Removes the logged solution IDs for the session.
 * @param {Component} that - The gpii.metrics instance.
 * @param {String} sessionID - Session ID.
 */
gpii.metrics.sessionStopped = function (that, sessionID) {
    delete that.sessionSolutions[sessionID];
};

/**
 * A model state listener for {lifecycleManager}.model.logonChange.
 * When the login state changes from "login" to "logout", log the solutions that did not get applied for that session.
 *
 * @param {Component} that - The gpii.metrics instance.
 * @param {Component} lifecycleManager - The lifecycleManager instance.
 * @param {Object} oldValue - The old value.
 * @param {Object} newValue - The new value.
 */
gpii.metrics.logonStateChanged = function (that, lifecycleManager, oldValue, newValue) {
    if (oldValue && oldValue.type === "login" && (newValue.type === "logout" || !newValue.inProgress)) {
        var session = lifecycleManager.getSession(oldValue.gpiiKey);
        // The reason for this null checker is that the lifecyclaManager's "session" may be null after
        // having logged on with a bogus token which terminated the request in error before the
        // "session" could be created.
        if (session) {
            // Log the solution IDs that hadn't been applied.
            var expectedSolutions = fluid.keys(session.model.activeConfiguration.lifecycleInstructions);
            fluid.each(expectedSolutions, function (id) {
                if (!session.model.currentSettings[id]) {
                    that.logMetric("solution-failed", {
                        solutionID: id
                    });
                }
            });
        }
    }
};
