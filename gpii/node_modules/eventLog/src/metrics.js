/*
 * Metrics logging.
 * This acts upon events that are deemed interesting enough to be recorded and sent to a log server for analysis.
 *
 * Copyright 2017 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion");

var gpii = fluid.registerNamespace("gpii");

fluid.defaults("gpii.metrics", {
    gradeNames: ["fluid.modelComponent", "fluid.contextAware"],
    contextAwareness: {
        platform: {
            checks: {
                windows: {
                    contextValue: "{gpii.contexts.windows}",
                    gradeNames: "gpii.metrics.windows"
                }
            }
        }
    },
    invokers: {
        logMetric: {
            func: "{eventLog}.logEvent",
            args: ["{eventLog}", "metrics", "{arguments}.0", "{arguments}.1"]
        }
    },
    members: {
        sessionSolutions: {}
    },
    events: {
        "onStartMetrics": null,
        "onStopMetrics": null
    },
    modelListeners: {
        "{lifecycleManager}.model.logonChange": {
            funcName: "gpii.metrics.logonStateChanged",
            args: [ "{that}", "{lifecycleManager}", "{change}.oldValue", "{change}.value" ]
        }
    },
    listeners: {
        "{lifecycleManager}.events.onSessionStart": "{that}.events.onStartMetrics",
        "{lifecycleManager}.events.onSessionStop": [{
            namespace: "metrics.session",
            funcName: "gpii.metrics.sessionStopped",
            args: ["{that}", "{arguments}.1.id"]
        }, {
            "func": "{that}.events.onStopMetrics",
            "priority": "before:eventLog"
        }],
        "{lifecycleManager}.events.onSessionSnapshotUpdate": {
            namespace: "metrics",
            funcName: "gpii.metrics.snapshotUpdate",
            args: ["{that}", "{arguments}.1.id", "{arguments}.2"]
        }
    }
});

/**
 * Log the solutions as they're applied.
 *
 * @param that {Component} The gpii.metrics instance.
 * @param sessionID {String} Session ID.
 * @param originalSettings {Object} The original settings (only interested in the keys).
 */
gpii.metrics.snapshotUpdate = function (that, sessionID, originalSettings) {
    var ids = fluid.keys(originalSettings);
    var solutionIDs = that.sessionSolutions[sessionID];
    if (!solutionIDs) {
        solutionIDs = that.sessionSolutions[sessionID] = {};
    }
    // Log the solution IDs that haven't been logged.
    fluid.each(ids, function (id) {
        if (!solutionIDs[id]) {
            that.logMetric("solution-applied", {
                solutionID: id
            });
            solutionIDs[id] = true;
        }
    });
};

/**
 * Removes the logged solution IDs for the session.
 * @param that {Component} The gpii.metrics instance.
 * @param sessionID {String} Session ID.
 */
gpii.metrics.sessionStopped = function (that, sessionID) {
    delete that.sessionSolutions[sessionID];
};

/**
 * A model state listener for {lifecycleManager}.model.logonChange.
 * When the login state changes from "login" to "logout", log the solutions that did not get applied for that session.
 *
 * @param that {Component} The gpii.metrics instance.
 * @param lifecycleManager {Component} The lifecycleManager instance.
 * @param oldValue {object} The old value.
 * @param newValue {object} The new value.
 */
gpii.metrics.logonStateChanged = function (that, lifecycleManager, oldValue, newValue) {
    if (oldValue && oldValue.type === "login" && (newValue.type === "logout" || !newValue.inProgress)) {
        var session = lifecycleManager.getSession(oldValue.userToken);
        // The reason for this null checker is that the lifecyclaManager's "session" may be null after
        // having logged on with a bogus token which terminated the request in error before the
        // "session" could be created.
        if (session) {
            // Log the solution IDs that hadn't been applied.
            var expectedSolutions = fluid.keys(session.model.activeConfiguration.lifecycleInstructions);
            fluid.each(expectedSolutions, function (id) {
                if (!session.model.appliedSolutions[id]) {
                    that.logMetric("solution-failed", {
                        solutionID: id
                    });
                }
            });
        }
    }
};
