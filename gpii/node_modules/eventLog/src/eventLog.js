/*
 * Event logging.
 * Handles logging of events that are deemed interesting enough to be recorded and sent to a log server for analysis.
 * The log produced here is in JSON and sent to a different output than the usual fluid.log.
 *
 * Copyright 2017 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion");
var fs = require("fs"),
    path = require("path");

var gpii = fluid.registerNamespace("gpii"),
    $ = fluid.registerNamespace("jQuery");

fluid.registerNamespace("gpii.eventLog");

fluid.defaults("gpii.eventLog", {
    gradeNames: ["fluid.component", "fluid.contextAware"],
    components: {
        installID: {
            type: "gpii.installID"
        },
        settingsDir: {
            type: "gpii.settingsDir"
        },
        metrics: {
            type: "gpii.metrics"
        }
    },
    invokers: {
        logEvent: "gpii.eventLog.log",
        logError: "gpii.eventLog.logError",
        getGpiiSettingsDir: "{settingsDir}.getGpiiSettingsDir",
        getLogFile: "gpii.eventLog.getLogFile"
    },
    members: {
        // The log file.
        logFilePath: null,
        // The installation ID
        installationID: "@expand:{that}.installID.getInstallID()"
    },
    listeners: {
        "onCreate.logFile": {
            func: "gpii.eventLog.getLogFile",
            args: ["{that}"]
        },
        "onCreate.log": {
            func: "{that}.logEvent",
            args: ["{that}", "gpii", "Start", {}]
        },
        "onDestroy.log": {
            func: "{that}.logEvent",
            args: [ "{that}", "gpii", "Stop", {}]
        },
        "{lifecycleManager}.events.onSessionStart": {
            namespace: "eventLog",
            func: "{that}.logEvent",
            args: [
                "{that}",
                "lifecycle",
                "SessionStart",
                {
                    // onSessionStart fired with [gradeName, userToken]
                    userToken: "{arguments}.1",
                    session: "@expand:{lifecycleManager}.getSession({arguments}.1)"
                }
            ]
        },
        "{lifecycleManager}.events.onSessionStop": {
            namespace: "eventLog",
            func: "{that}.logEvent",
            args: [
                "{that}",
                "lifecycle",
                "SessionStop",
                {
                    // onSessionStop fired with [{lifecycleManager}, {session}]
                    userToken: "{arguments}.1.model.userToken",
                    session: "{arguments}.1.id"
                }
            ]
        }
    }
});

/**
 * Returns the actual Date and time
 */
gpii.eventLog.getTimestamp = function () {
    return new Date();
};

/**
 * Creates an object for the log. Everything in this object is what will be logged, and the "time" field will be added
 * later when it is actually logged.
 *
 * @param moduleName {String} The part of GPII causing this event.
 * @param event {String} Name of the event.
 * @param data [optional] Event specific data.
 * @param level {Object} [optional] Level of the log, see fluid.logLevelsSpec [FATAL,FAIL,WARN,IMPORTANT,INFO,TRACE].
 * @return {Object} The log object.
 */
gpii.eventLog.createLogObject = function (moduleName, event, data, level) {
    var eventObject = {
        module: moduleName || "GPII",
        event: event,
        level: level
    };

    var hasValue = (data !== null && data !== undefined);
    if (hasValue && fluid.isPlainObject(data)) {
        hasValue = !$.isEmptyObject(data);
    }

    if (hasValue) {
        eventObject.data = fluid.copy(data);
        // Replace any components in the data object with their id.
        fluid.each(eventObject.data, function (value, key) {
            if (fluid.isComponent(value)) {
                eventObject.data[key] = value.id;
            }
        });
    }
    return eventObject;
};

/**
 * Logs an event.
 *
 * @param that {Component} The gpii.eventLog instance.
 * @param moduleName {String} The part of GPII causing this event.
 * @param event {String} The event name.
 * @param data {Object} [optional] Event specific data. Can (shallowly) contain components, in which case just the ID is
 * logged.
 * @param level {Object} [optional] Level of the log, see fluid.logLevelsSpec [FATAL,FAIL,WARN,IMPORTANT,INFO,TRACE].
 */
gpii.eventLog.log = function (that, moduleName, event, data, level) {
    var eventObject = gpii.eventLog.createLogObject(moduleName, event, data, level);
    gpii.eventLog.writeLog(that, level, eventObject);
};

/**
 * Logs an error.
 *
 * @param that {Component} The gpii.eventLog instance.
 * @param moduleName {String} The part of GPII causing this error.
 * @param errType {String} Type of error.
 * @param err {Object} The error.
 * @param level {Object} [optional] Level of the log. default: fluid.logLevel.FAIL.
 */
gpii.eventLog.logError = function (that, moduleName, errType, err, level) {
    if (!level) {
        level = fluid.logLevel.FAIL;
    }

    var data = {};
    if (err instanceof Error) {
        // Error doesn't serialise
        data.error = {};
        fluid.each(Object.getOwnPropertyNames(err), function (a) {
            data.error[a] = err[a];
        });
    } else if (fluid.isPlainObject(err, true)) {
        data.error = Object.assign({}, err);
    } else {
        data.error = {
            message: err
        };
    }

    if (!data.error.stack) {
        data.error.stack = new Error().stack;
    }

    var eventObject = gpii.eventLog.createLogObject(moduleName, "Error." + errType, data);
    gpii.eventLog.writeLog(that, fluid.logLevel.FAIL, eventObject);
};

// Log fluid.fail.
fluid.failureEvent.addListener(function (args) {
    var err = Array.isArray(args) ? args.join(" ") : err;
    gpii.eventLog.gotError(err, "Fail");
}, "gpii-eventLog", "before:fail");

/**
 * Logs an error caught by onUncaughtException or failureEvent.
 *
 * @param err The error.
 */
gpii.eventLog.gotError = function (err, errType) {
    var eventLog = fluid.queryIoCSelector(fluid.rootComponent, "gpii.eventLog");
    if (eventLog.length > 0) {
        eventLog[0].logError(eventLog[0], null, errType || "Exception", err);
    }
};

// Log uncaught exceptions.
fluid.onUncaughtException.addListener(gpii.eventLog.gotError, "gpii-eventLog");

/**
 * Gets the path of the new log file for this instance of gpii.
 *
 * @param that {Component} The gpii.eventLog instance.
 */
gpii.eventLog.getLogFile = function (that) {
    var logFile = that.logFilePath || process.env.GPII_EVENT_LOG;

    if (!logFile) {
        var startupTime = Date.now();
        var gpiiSettingsDir = that.getGpiiSettingsDir();
        logFile = path.join(gpiiSettingsDir, "gpii-" + gpii.journal.formatTimestamp(startupTime) + ".log");
        fluid.log(fluid.logLevel.IMPORTANT, "Writing event log to " + that.logFilePath);
    }

    that.logFilePath = logFile;

    return that.logFilePath;
};

/**
 * Writes an event to the log file.
 *
 * @param that {Component} The gpii.eventLog instance.
 * @param level {Object} Level of the log, see fluid.logLevelsSpec [FATAL,FAIL,WARN,IMPORTANT,INFO,TRACE].
 * @param event {Object} The object. This will be modified to what has been sent to the log, adding the installID and
 * timestamp fields.
 */
gpii.eventLog.writeLog = function (that, level, event) {
    var intLevel = gpii.eventLog.checkLevel(level);
    event.level = intLevel.value;

    // Log to console before the installation ID and timestamp are added (no one wants to see it).
    fluid.log(fluid.logLevel.IMPORTANT, event);

    event.installID = that.installationID;
    event.timestamp = gpii.eventLog.getTimestamp();
    fs.appendFileSync(that.logFilePath, JSON.stringify(event) + "\n");
};

/**
 * Ensure that the loglevel has a valid value. The levels are defined in the fluid.logLevelsSpec
 * Sets INFO as default loglevel
 *
 * @param level to check, can be a string that represents the value or a property of fluid.logLevel
 * @return a valid fluid.logLevel, with INFO as default
 */
gpii.eventLog.checkLevel = function (level) {
    if (typeof level === "string" && level in fluid.logLevelsSpec) {
        return fluid.logLevel[level];
    } else {
        return fluid.isLogLevel(level) ? level : fluid.logLevel.INFO;
    }
};
