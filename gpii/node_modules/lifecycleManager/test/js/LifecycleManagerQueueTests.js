/*!
GPII Lifecycle Manager Queue Tests

Copyright 2017 Raising The Floor - International

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

/* eslint-env browser */
/* eslint strict: ["error", "function"] */

/* global jqUnit, fluid */

(function () {
    "use strict";
    fluid.setLogging(true);

    var gpii = fluid.registerNamespace("gpii");

    fluid.registerNamespace("gpii.tests.lifecycleManager.queue");

    /**
     * Creates (and returns) an asynchronous function that returns a promise.
     * The function will wait the given `timeout` ms, the run the provided function and finally resolve (or reject) the promise.
     * The promise will be rejected if the `reject` parameter is a truthy. The value passed
     * in the rejection or resolving of the promise will be the same value that the created function
     * is called with
     *
     * @param {Integer} timeout - The number of ms the function should wait before resolving (or rejecting) the promise.
     * @param {String|Function} func - The function to call after `timeout` ms, immediately before resolving or rejecting the promise.
     * @param {Boolean} reject - If true, this will cause the promise to be rejected instead of resolved.
     * @return {Promise} A promise that will resolve with the original value func was called with or rejected on error.
     */
    gpii.tests.lifecycleManager.queue.createAsyncPromiseFunc = function (timeout, func, reject) {
        return function (arg) {
            var myPromise = fluid.promise();
            setTimeout(function () {
                func(arg);
                reject ? myPromise.reject(arg) : myPromise.resolve(arg);
            }, timeout);
            return myPromise;
        };
    };

    /*
     * Creates an item suitable for the lifecycle managers queue.
     * The function provided to the queue-item is generated by gpii.tests.lifecycleManager.queue.createAsyncPromiseFunc
     * using the timeout and func parameters.
     */
    gpii.tests.lifecycleManager.queue.createCustomTask = function (timeout, func, arg) {
        return {
            func: gpii.tests.lifecycleManager.queue.createAsyncPromiseFunc(timeout, func),
            arg: arg
        };
    };

    // ensure that we're processing queue in the correct order:
    jqUnit.asyncTest("Tasks are being processed on addition", function () {
        var lifecycleManager = gpii.lifecycleManager();
        jqUnit.expect(1);

        var queuePromise = lifecycleManager.addToActionQueue(gpii.tests.lifecycleManager.queue.createCustomTask(1, fluid.identity, 1));

        queuePromise.then(function (val) {
            jqUnit.assertEquals("Task was processed on addition to queue", 1, val);
            jqUnit.start();
        });
    });

    // ensure that we're processing queue in the correct order:
    jqUnit.asyncTest("Queue is being processed in the correct order", function () {
        var lifecycleManager = gpii.lifecycleManager();
        var results = [];
        var pushResultFunc = function (arg) {
            results.push(arg);
        };

        jqUnit.expect(1);

        lifecycleManager.addToActionQueue(gpii.tests.lifecycleManager.queue.createCustomTask(300, pushResultFunc, 1));
        lifecycleManager.addToActionQueue(gpii.tests.lifecycleManager.queue.createCustomTask(50, pushResultFunc, 2));
        var queuePromise3 = lifecycleManager.addToActionQueue(gpii.tests.lifecycleManager.queue.createCustomTask(100, pushResultFunc, 3));

        queuePromise3.then(function () {
            jqUnit.assertDeepEq("Task was processed on addition to queue", [1, 2, 3], results);
            jqUnit.start();
        });
    });

    jqUnit.asyncTest("Rejected promises causes the queue promise to be rejected", function () {
        var lifecycleManager = gpii.lifecycleManager();
        jqUnit.expect(1);

        var task = {
            func: gpii.tests.lifecycleManager.queue.createAsyncPromiseFunc(200, fluid.identity, true),
            promise: fluid.promise()
        };
        var queuePromise = lifecycleManager.addToActionQueue(task);

        queuePromise.then(function () {
            jqUnit.fail("Rejected task should reject promise");
            jqUnit.start();
        }, function () {
            jqUnit.assertTrue("Task failed and promise was rejected", true);
            jqUnit.start();
        });
    });

    jqUnit.asyncTest("All promises in queue are rejected when a task fail", function () {
        var lifecycleManager = gpii.lifecycleManager();
        jqUnit.expect(4);

        var failTask = {
            func: gpii.tests.lifecycleManager.queue.createAsyncPromiseFunc(200, fluid.identity, true),
            promise: fluid.promise()
        };
        // first task that succeeds
        lifecycleManager.addToActionQueue(gpii.tests.lifecycleManager.queue.createCustomTask(300, fluid.identity)).then(function () {
            jqUnit.assertTrue("First task should succeed", true);
        });
        // next task fails
        lifecycleManager.addToActionQueue(failTask).then(function () {
            jqUnit.fail("Second task should fail");
        }, function () {
            jqUnit.assertTrue("Second task failed as expected", true);
        });
        // subsequent tasks fail:
        lifecycleManager.addToActionQueue(gpii.tests.lifecycleManager.queue.createCustomTask(50, fluid.identity)).then(
            function () {},
            function () { jqUnit.assertTrue("third task failed as expected", true); }
        );
        lifecycleManager.addToActionQueue(gpii.tests.lifecycleManager.queue.createCustomTask(50, fluid.identity)).then(
            function () {},
            function () {
                jqUnit.assertTrue("fourth task failed as expected", true);
                jqUnit.start();
            }
        );
    });
})();
