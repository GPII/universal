/*!
 * Private MatchMaker
 *
 * Copyright 2018 OCAD University
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

 "use strict";

 var fluid = fluid || require("infusion"),
     gpii = fluid.registerNamespace("gpii");

// This component is used by the lifecycleManager to perform a local matchmaking at handling requests for applying
// new preferences that don't exist in lifecycleManager.session.model.preferences.
 fluid.defaults("gpii.lifecycleManager.privateMatchMaker", {
     gradeNames: ["fluid.component", "gpii.flowManager.matchMaking"],
     invokers: {
         doMatch: {
             funcName: "gpii.lifecycleManager.privateMatchMaker.doMatch",
             args: [
                 "{that}",
                 "{flowManager}.deviceReporter",
                 "{arguments}.0",  // gpiiKey
                 "{arguments}.1"   // preferences
             ]
         }
     },
     events: {
         onSuccess: null,
         onError: null
     },
     listeners: {
         "onGpiiKey.getPreferences": "fluid.identity",
         "onMatchDone.matchToSettings": {
             listener: "gpii.flowManager.cloudBased.matchToSettings",
             args: ["{arguments}.0", "{that}.events.onSuccess", "Private MatchMaker"]
         }
     }
 });

 gpii.lifecycleManager.privateMatchMaker.doMatch = function (that, deviceReporter, gpiiKey, preferences) {
     var requestPromise = fluid.promise();

     that.events.onSuccess.addListener(function (payload) {
         requestPromise.resolve(payload);
         // TODO: To work around the issue that a fixed listener always binds to the first request prmoise
         // which causes subsequent match making requests throw "promise has been resolved" error. The proper
         // solution is to request-scope the private matchMaker by perhaps adding a "UserUpdate" request type
         // to go along with other UserLogon request types.
         that.events.onSuccess.removeListener("resolvePromise");
     }, "resolvePromise");

     that.events.onError.addListener(function (error) {
         requestPromise.reject(error);
         that.events.onError.removeListener("rejectPromise");
     }, "rejectPromise");

     // Do match making
     that.events.onGpiiKey.fire(gpiiKey);
     that.events.onPreferences.fire(preferences);

     var devicePromise = deviceReporter.get();
     devicePromise.then(function (deviceData) {
         fluid.log("Private MatchMaker, doMatch - received device data: ", deviceData);
         that.events.onDeviceContext.fire(deviceData);
     }, function (err) {
         fluid.log("Private MatchMaker, doMatch - error at receiving device data: " + err.message);
         that.events.onError.fire(err);
     });

     return requestPromise;
 };
