/*!
 * A temp match making processor
 *
 * Copyright 2018 OCAD University
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = fluid || require("infusion");
var gpii = fluid.registerNamespace("gpii");

fluid.defaults("gpii.lifecycleManager.matchMaking.request", {
    gradeNames: ["fluid.component", "gpii.flowManager.matchMakingRequest"],
    invokers: {
        doMatchMaking: {
            funcName: "gpii.lifecycleManager.matchMaking.request.doMatchMaking",
            args: [
                "{that}",
                "{flowManager}.deviceReporterDataSource",
                "{arguments}.0",
                "{arguments}.1"
            ]
        }
    },
    events: {
        onSuccess: null,
        onError: null
    },
    listeners: {
        "onGpiiKey.getPreferences": {
            listener: "fluid.identity"
        },
        onMatchDone: {
            listener: "gpii.flowManager.cloudBased.matchToSettings",
            args: ["{arguments}.0", "{that}.events.onSuccess"]
        }
    }
});

gpii.lifecycleManager.matchMaking.request.doMatchMaking = function (that, deviceReporterDataSource, gpiiKey, preferences) {
    that.events.onGpiiKey.fire(gpiiKey);
    that.events.onPreferences.fire(preferences);

    var deviceContextPromise = deviceReporterDataSource.get();
    deviceContextPromise.then(function (deviceData) {
        fluid.log("Lifecycle Manager, doMatchMaking - received device data: ", deviceData);
        that.events.onDeviceContext.fire(deviceData);
    }, function () {
        fluid.log("Lifecycle Manager, doMatchMaking - error at receiving device data");
    });

    var requestPromise = fluid.promise();

    that.events.onSuccess.addListener(function (payload) {
        requestPromise.resolve(payload);
        // To work around the issue that a fixed listener always binds to the first request prmoise
        // which causes subsequent match making requests throw "promise has been resolved" error.
        that.events.onSuccess.removeListener("resolvePromise");
    }, "resolvePromise");

    that.events.onError.addListener(function (error) {
        requestPromise.reject(error);
        that.events.onError.removeListener("rejectPromise");
    }, "rejectPromise");

    return requestPromise;
};
