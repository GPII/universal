/*!
 * Lifecycle Manager
 *
 * Copyright 2012 Antranig Basman
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = fluid || require("infusion");
var gpii = fluid.registerNamespace("gpii");

(function () {

    fluid.defaults("gpii.lifecycleManager", {
        gradeNames: ["fluid.component"],
        retryOptions: {      // Options governing how often to recheck whether settings are set (and in future, to check for running processes)
            rewriteEvery: 3, // Every 3rd attempt, rewrite the required settings again
            numRetries: 12,  // Make 12 attempts over a period of 12 seconds to discover whether settings are set
            retryInterval: 1000
        },
        components: {
            variableResolver: {
                type: "gpii.lifecycleManager.variableResolver"
            },
            nameResolver: {
                type: "gpii.lifecycleManager.nameResolver"
            }
        },
        members: {
            activeSessions: {}
        },
        invokers: {
            getActiveSessionTokens: {
                funcName: "gpii.lifecycleManager.getActiveSessionTokens",
                args: "{that}.activeSessions"
            },
            getSession: {
                funcName: "gpii.lifecycleManager.getSession",
                args: ["{that}.activeSessions", "{arguments}.0"] // user token
            },
            // TODO: refactor these three methods so that they return promises
            // TODO: really do it!
            stop: {
                funcName: "gpii.lifecycleManager.stop",
                args: ["{that}", "{request}", "{arguments}.0", "{arguments}.1"]
            },                    // options, callback
            start: {
                funcName: "gpii.lifecycleManager.start",
                args: ["{that}", "{request}", "{arguments}.0", "{arguments}.1"]
                                  // finalPayload, callback
            },
            update: {
                funcName: "gpii.lifecycleManager.update",
                args: ["{that}", "{request}", "{arguments}.0", "{arguments}.1"]
            },                    // finalPayload, callback
            applySolution: {
                funcName: "gpii.lifecycleManager.applySolution",
                args: ["{that}", "{arguments}.0", "{arguments}.1", "{arguments}.2", "{arguments}.3", "{arguments}.4"]
                                  // solutionId,  solutionRecord, sessionState, lifecycleBlocksKeys, saveSnapshot
            },
            stopSolution: {
                funcName: "gpii.lifecycleManager.stopSolution",
                args: ["{that}", "{arguments}.0", "{arguments}.1", "{arguments}.2", "{arguments}.3"]
                                  // solutionId,  solutionRecord, sessionState, lifecycleBlockKeys
            },
            executeActions: {
                funcName: "gpii.lifecycleManager.executeActions",
                args: ["{that}", "{arguments}.0", "{arguments}.1", "{arguments}.2", "{arguments}.3"]
                                  // solutionId, settingsHandlers, actions, sessionState
            },
            invokeSettingsHandlers: {
                funcName: "gpii.lifecycleManager.invokeSettingsHandlers",
                args: ["{that}",  "{arguments}.0", "{arguments}.1"]
                                  // solutionId, settingsHandlers
            }
        }
    });

    // A standard interception point so that the process of resolving names onto
    // settings handlers and actions can be mocked for integration tests
    fluid.defaults("gpii.lifecycleManager.nameResolver", {
        gradeNames: ["fluid.component"],
        invokers: {
            resolveName: {
                funcName: "fluid.identity"
            }
        }
    });

    fluid.defaults("gpii.lifecycleManager.variableResolver", {
        gradeNames: ["fluid.component"],
        components: {
            resolverConfig: {
                type: "gpii.lifecycleManager.standardResolverConfig"
            }
        },
        members: {
            resolvers: {
                expander: {
                    func: "gpii.lifecycleManager.variableResolver.computeResolvers",
                    args: "{that}.resolverConfig.options.resolvers"
                }
            },
            fetcher: {
                expander: {
                    func: "gpii.resolversToFetcher",
                    args: "{that}.resolvers"
                }
            }
        },
        invokers: {
            resolve: {
                funcName: "gpii.lifecycleManager.variableResolver.resolve",
                args: ["{arguments}.0", "{that}.fetcher", "{arguments}.1"]
            }
        }
    });

    gpii.lifecycleManager.variableResolver.computeResolvers = function (resolvers) {
        return fluid.transform(resolvers, fluid.getGlobalValue);
    };

    gpii.lifecycleManager.variableResolver.resolve = function (material, fetcher, extraFetcher) {
        return fluid.expand(material, {
            bareContextRefs: false,
            // TODO: FLUID-4932 - the framework currently has no wildcard support in mergePolicy.
            mergePolicy: {
                0: {
                    capabilitiesTransformations: {
                        "*": {
                            noexpand: true
                        }
                    }
                }
            },
            fetcher: gpii.combineFetchers(fetcher, extraFetcher)
        });
    };

    gpii.resolversToFetcher = function (resolvers) {
        return function (parsed) {
            var resolver = resolvers[parsed.context];
            return !resolver ? undefined : (
                typeof(resolver) === "function" ?
                    resolver(parsed.path) : fluid.get(resolver, parsed.path));
        };
    };

    gpii.combineFetchers = function (main, fallback) {
        return fallback ? function (parsed) {
            var fetched = main(parsed);
            return fetched === undefined ? fallback(parsed) : fetched;
        } : main;
    };

    fluid.defaults("gpii.lifecycleManager.standardResolverConfig", {
        gradeNames: "fluid.component",
        resolvers: {
            environment: "gpii.lifecycleManager.environmentResolver"
        }
    });

    gpii.lifecycleManager.environmentResolver = function (name) {
        return process.env[name];
    };

    // Transforms the handlerSpec (handler part of the transformer's response payload) to a form
    // accepted by a settingsHandler - we use a 1-element array holding the payload for a single solution
    // per handler
    gpii.lifecycleManager.specToSettingsHandler = function (solutionId, handlerSpec) {
        var returnObj = {};
        returnObj[solutionId] = [{
            settings: handlerSpec.settings,
            options: handlerSpec.options
        }];
        return returnObj; // NB array removed here
    };

    // Transform the response from the handler SET to a format that we can pass to handler SET on restore - "oldValue" becomes plain value
    gpii.lifecycleManager.responseToSnapshot = function (solutionId, handlerResponse) {
        var unValued = gpii.settingsHandlers.setResponseToSnapshot(handlerResponse);
        // Note - we deal in these 1-element arrays just for simplicity in the LifecycleManager. A more efficient
        // implementation might send settings for multiple solutions to the same settingsHandler in a single request.
        // Note that in the session's snapshots, this level of array containment has been removed.
        return fluid.get(unValued, [solutionId, 0]);
    };

   //@param handlerSpec {Object} A single settings handler specification
   // Payload example:
   //   http://wiki.gpii.net/index.php/Settings_Handler_Payload_Examples
   // Transformer output:
   //   http://wiki.gpii.net/index.php/Transformer_Payload_Examples
    gpii.lifecycleManager.invokeSettingsHandlers = function (that, solutionId, handlerSpec) {
        // first prepare the payload for the settingsHandler in question - a more efficient
        // implementation might bulk together payloads destined for the same handler
        var settingsHandlerPayload = gpii.lifecycleManager.specToSettingsHandler(solutionId, handlerSpec);
        var resolvedName = that.nameResolver.resolveName(handlerSpec.type, "settingsHandler");
        var setSettingsPromise = gpii.settingsHandlers.dispatchSettingsHandler(resolvedName, settingsHandlerPayload, that.options.retryOptions);
        var togo = fluid.promise();

        setSettingsPromise.then(function (handlerResponse) {
            // update the settings section of our snapshot to contain the new information
            var settingsSnapshot = gpii.lifecycleManager.responseToSnapshot(solutionId, handlerResponse);
            // Settings handlers may or may not return options (currently it seems they all do) - gain resistance to this by restoring the
            // original "options" supplied to them.
            fluid.each(handlerSpec, function (entry, key) {
                if (key !== "settings") {
                    settingsSnapshot[key] = fluid.copy(entry);
                }
            });
            togo.resolve(settingsSnapshot);
        }, togo.reject);

        return togo;
    };


    gpii.lifecycleManager.invokeAction = function (action, nameResolver) {
        var resolvedName = nameResolver.resolveName(action.type, "action");
        return fluid.invokeGradedFunction(resolvedName, action);
    };

    /**
     * @param that {Object} The lifecycle manager component
     * @param solutionId {String} the ID of the solution for which to execute the settings
     * @param solutionRecord {Object} The solution registry entry for the solution
     * @param sessionState {Object} The current sessionState. This function will attach the
     *           solution record to the 'appliedSolutions' of the sessionState object (if successful)
     * @param settingsReturn {Object} this object will contain the snapshotted settings (ie. recorded before new
     *     settings are applied). It can contain already recorded settings, but *will also be modified* by this
     *     function.
     * @param settingsHandlerBlcok {String} should be a reference to a settings block from the
     *     settingsHandlers section.
     * @return {Function} a function, that once executed will set the settings returning a promise
     *     that will be resolved once the settings are successfully set.
    */
    gpii.lifecycleManager.executeSettingsAction = function (that, solutionId, solutionRecord, sessionState, settingsReturn, settingsHandlerBlockName) {
        var settingsHandlerBlock = solutionRecord.settingsHandlers[settingsHandlerBlockName];
        if (settingsHandlerBlock === undefined) {
            fluid.fail("Reference to non-existing settingshandler block named " + settingsHandlerBlockName +
                " in solution " + solutionId);
        }
        return function () {
            var expanded = sessionState.localResolver(settingsHandlerBlock);
            var settingsPromise = that.invokeSettingsHandlers(solutionId, expanded);
            settingsPromise.then(function (snapshot) {
                if (!sessionState.appliedSolutions) {
                    sessionState.appliedSolutions = {};
                }
                sessionState.appliedSolutions[solutionId] = solutionRecord;
                settingsReturn[settingsHandlerBlockName] = snapshot;
            });
            return settingsPromise;
        };
    };

    // Called for each solution during both the "stop" and "start" phases - it is agnostic as to which phase it is. Actions to be performed
    // are held in array "actions" and the settingsHandlers block from "solutions" (either Transformer output, or snapshot output from "start"
    // phase) encodes the settings to be set
    // Returns the results from the settings action present in the list, and builds up action returns in session state "actionResults" field
    // (so that these may be referenced from context expressions in further actions).
    gpii.lifecycleManager.executeActions = function (that, solutionId, solutionRecord, sessionState, actionBlock) {
        var settingsReturn = {};
        var steps = solutionRecord[actionBlock];
        if (steps === undefined) {
            fluid.log("No " + actionBlock + " actions defined for solution " + solutionId);
            return fluid.promise().resolve();
        }
        var sequence = fluid.transform(steps, function (action) {
            if (typeof(action) === "string") {
                // if the action is a reference to a settings block (settings.<refName> where <refName> is a key to
                // the settings handler block)
                if (action.indexOf("settings.") === 0) {
                    var settingsHandlerBlockName = action.substring("settings.".length);
                    return gpii.lifecycleManager.executeSettingsAction(that, solutionId, solutionRecord, sessionState, settingsReturn, settingsHandlerBlockName);
                } else if (actionBlock === "update") {
                    // Keywords: "start", "stop", "configure" are allowed here as well, and
                    // and will result in evaluating the respective block
                    // TODO (GPII-1230) Fix this up so we dont always run the full start and stops (including)
                    // system restoration, etc.
                    if (action === "start" || action === "configure") {
                        return that.executeActions(solutionId, solutionRecord, sessionState, action);
                    } else if (action === "stop") {
                        return that.executeActions(solutionId, sessionState.originalSettings[solutionId], sessionState, "stop");
                    } else {
                        fluid.fail("Unrecognised string action in LifecycleManager: " + action +
                            " inside 'update' section for solution " + solutionId);
                    }
                }
            } else { // TODO should be removed when GPII-1235 has been solved
                return function () {
                    var expanded = sessionState.localResolver(action);
                    var result = gpii.lifecycleManager.invokeAction(expanded, that.nameResolver);
                    if (action.name) {
                        sessionState.actionResults[action.name] = result;
                    }
                };
            }
        });
        var resolved = fluid.promise.sequence(sequence);
        var togo = fluid.promise();
        resolved.then(function () {
            togo.resolve(settingsReturn);
        }, togo.reject);
        return togo;
    };

    /** Invoked on both "start" and "update" phases - in addition to forwarding to gpii.lifecycleManager.executeActions,
     * it is responsible for saving the settings that are being set (when the fullSnapshot is true) and storing
     * the list of applied solutions to the sessionState
     *
     * @param solutionId {String} the ID of the solution
     * @param solutionRecord {Object} a solution record with settings that are to be applied to the system
     * @param sessionState {Object} the object holding the state of the system
     * @param lifecycleBlockKeys {Array} Array of ordered strings denoting which lifecycle blocks to run (usually "configure", "start" and/or "update")
     * @param fullSnapshot {boolean} indicates whether a full snapshot of the original settings should be taken
     *     before the new settings are written. If false, only changed settings that are not part of
     *     an already existing snapshot will be saved
     * @return {Promise} The same promise yielded by executeActions - the stateful construction of the session state is tacked onto this promise
     * as a side-effect
     */
    gpii.lifecycleManager.applySolution = function (that, solutionId, solutionRecord, sessionState, lifecycleBlockKeys, fullSnapshot) {
        var promises = [];
        fluid.each(lifecycleBlockKeys, function (key) {
            promises.push(that.executeActions(solutionId, solutionRecord, sessionState, key));
        });
        var promiseSequence = fluid.promise.sequence(promises);
        // snapshots is an array of snapshotted settingshandler results (one for each lifecycle action block)
        promiseSequence.then(function (snapshots) {
            var toSnapshot = fluid.copy(solutionRecord);
            toSnapshot.settingsHandlers = {};
            fluid.each(snapshots, function (snapshot) {
                if (snapshot !== undefined) { // can be removed once everything is settingsHandlers (GPII-1235)
                    fluid.each(snapshot, function (handlerBlock, blockKey) {
                        toSnapshot.settingsHandlers[blockKey] = handlerBlock;
                    });
                }
            });
            if (fullSnapshot) {
                sessionState.originalSettings[solutionId] = toSnapshot;
            } else {
                // if we're doing an update, keep the settings that are already stored from the
                // original snapshot, but augment it with any settings from the new snapshot
                // that were not present in the original snapshot.
                // First merge the basic structures:
                var tmpOrigSettings = fluid.extend(true, {}, toSnapshot, sessionState.originalSettings[solutionId]);

                // ensure that our augmented snapshot has any 'undefined' settings value copied over as well
                gpii.settingsHandlers.copySettings(tmpOrigSettings.settingsHandlers, toSnapshot.settingsHandlers);

                // now recopy the original settings snapshot on top of the stored settings, but this time
                // make sure that the settings from the original snapshot with a stored value of 'undefined' are copied over
                // properly
                if (sessionState.originalSettings[solutionId]) {
                    gpii.settingsHandlers.copySettings(tmpOrigSettings.settingsHandlers, sessionState.originalSettings[solutionId].settingsHandlers);
                }
                sessionState.originalSettings[solutionId] = tmpOrigSettings;
            }
        });
        return promiseSequence;
    };

    /**
     * Invoked on "stop" phase. Will run the relevant entries via the executeActions function.
     * The expected outcome is that solution should be restored to its original state
     *
     * @param solutionId {String} the ID of the solution
     * @param solutionRecord {Object} consists of the original settings of the given solution
     * @param sessionState {Object} the object holding the state of the system
     * @param lifecycleBlockKeys {Array} Array of ordered strings denoting which lifecycle blocks to
          run (usually "restore" and/or "stop"
     * @return {Promise} A promise (sequence of promises) as returned by executeActions
     */
    gpii.lifecycleManager.stopSolution = function (that, solutionId, solutionRecord, sessionState, lifecycleBlockKeys) {
        var promises = [];
        fluid.each(lifecycleBlockKeys, function (key) {
            promises.push(that.executeActions(solutionId, solutionRecord, sessionState, key));
        });
        return fluid.promise.sequence(promises);
    };

    // Will return one of the users token keys for an active session
    // TODO: We need to implement logic to ensure at most one of these is set, or
    // to manage logic for superposition of sessions if we permit several (see GPII-102)
    gpii.lifecycleManager.getActiveSessionTokens = function (activeSessions) {
        return fluid.keys(activeSessions);
    };

    gpii.lifecycleManager.getSession = function (activeSessions, userTokens) {
        if (userTokens.length === 0) {
            fluid.fail("Attempt to get sessions without keys");
        } else {
            return activeSessions[userTokens[0]];
        }
    };

    /**
     * Structure of lifecycleManager options:
     * userid: userid,
     * actions: either start or stop configuration from solutions registry
     * settingsHandlers: transformed settings handler blocks
     */
    gpii.lifecycleManager.stop = function (that, request, options, callback) {
        var userToken = options.userToken;
        var sessionState = that.activeSessions[userToken];
        if (!sessionState) {
            callback(false);
            return;
        }

        var promises = fluid.transform(sessionState.originalSettings, function (solutionRecord, solutionId) {
            return that.stopSolution(solutionId, solutionRecord, sessionState, [ "stop", "restore" ]);
        });

        // TODO: In theory we could stop all solutions in parallel
        var sequence = fluid.promise.sequence(fluid.values(promises));
        sequence.then(function () {
            delete that.activeSessions[userToken];
            callback(true);
        }, function (error) {
            request.events.onError.fire(error);
        });
    };

    /**
     * Update user preferences.
     */
    gpii.lifecycleManager.update = function (that, request, finalPayload, callback) {
        var userToken = finalPayload.userToken,
            lifecycleInstructions = finalPayload.lifecycleInstructions;
        var sessionState = that.activeSessions[userToken];
        if (!sessionState) {
            fluid.fail("User with token ", userToken, " has no active session");
        }

        var promises = [];
        fluid.each(lifecycleInstructions, function (solution, solutionId) {
            var sol = fluid.copy(solution);
            if (sessionState.appliedSolutions && sessionState.appliedSolutions[solutionId]) {
                // merge already applied settings with the updates
                sol = fluid.extend(true, {}, sessionState.appliedSolutions[solutionId], sol);
            }
            promises.push(that.applySolution(solutionId, sol, sessionState, [ "update" ], false));
        });
        var sequence = fluid.promise.sequence(promises);
        sequence.then(function () {
            callback({ success: true });
        }, function (error) {
            request.events.onError.fire(error);
        });
        return sequence;
    };

    gpii.lifecycleManager.start = function (that, request, finalPayload, callback) {
        var userToken = finalPayload.userToken,
            lifecycleInstructions = finalPayload.lifecycleInstructions;
        if (that.activeSessions[userToken]) {
            // TODO: develop async architecture to prevent rat's nest of callbacks
            that.stop({userToken: userToken}, fluid.identity);
        }
        // TODO: Make global map of all users of session state
        //   activeConfiguration: Assigned in contextManager.evaluateMatch, consumed in UserUpdate
        //   userToken, solutionsRegistryEntries: Assigned in initialPayload, consumed in UserUpdate
        var sessionState = fluid.extend(true, {
            actionResults: {}
        }, fluid.filterKeys(finalPayload, ["userToken", "activeContextName", "activeConfiguration", "solutionsRegistryEntries", "matchMakerOutput"]));

        // let the user's token as well as any named action results accumulated
        // to date be resolvable for any future action
        sessionState.localFetcher = gpii.combineFetchers(
            gpii.resolversToFetcher({userToken: userToken}),
            gpii.resolversToFetcher(sessionState.actionResults));

        sessionState.localResolver = function (material) {
            return that.variableResolver.resolve(material, sessionState.localFetcher);
        };

        // This "start" action will result in the original settings of the system (i.e. those that
        // were on the system before the user logged in) being stored inside sessionState.originalSettings.
        // When "stop" is called this payload will be used to restore the settings back to their
        // original state.
        sessionState.originalSettings = {};
        var tasks = [];
        fluid.each(lifecycleInstructions, function (solution, solutionId) {
            tasks.push(function () {
                // build structure for returned values (for later reset)
                return that.applySolution(solutionId, solution, sessionState,
                    (solution.active ? [ "configure", "start" ] : [ "configure" ]), true);
            });
        });
        that.activeSessions[userToken] = sessionState;
        // Note that these promises are only sequenced for their side-effects (the ones on sessionState within applySolution and on the system at large
        // via the settings handlers)
        var sequence = fluid.promise.sequence(tasks);
        sequence.then(function () {
            callback(true);
        }, function (error) {
            request.events.onError.fire(error);
        });
    };

})();
