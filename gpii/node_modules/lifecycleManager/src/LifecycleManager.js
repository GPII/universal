/*!
Lifecycle Manager

Copyright 2012 Antranig Basman


Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

"use strict";

var fluid = fluid || require("infusion");
var $ = fluid.registerNamespace("jQuery");
var gpii = fluid.registerNamespace("gpii");

(function () {

    fluid.defaults("gpii.lifecycleManager", {
        gradeNames: ["fluid.eventedComponent", "autoInit"],
        components: {
            variableResolver: {
                type: "gpii.lifecycleManager.variableResolver"
            },
            nameResolver: {
                type: "gpii.lifecycleManager.nameResolver"
            }
        },
        members: {
            activeSessions: {}
        },
        invokers: {
            getActiveSessionTokens: {
                funcName: "gpii.lifecycleManager.getActiveSessionTokens",
                args: "{that}.activeSessions"
            },
            getSession: {
                funcName: "gpii.lifecycleManager.getSession",
                args: ["{that}.activeSessions", "{arguments}.0"] // token
            },
            stop: {
                funcName: "gpii.lifecycleManager.stop",
                args: ["{that}", "{arguments}.0", "{arguments}.1"]
            },
            start: {
                funcName: "gpii.lifecycleManager.start",
                args: ["{that}", "{arguments}.0", "{arguments}.1", "{arguments}.2"]
                                  // options, solutions, callback
            },
            update: {
                funcName: "gpii.lifecycleManager.update",
                args: ["{that}", "{arguments}.0", "{arguments}.1", "{arguments}.2"]
            }                     // options, solutions, callback
        }
    });

    // A standard interception point so that the process of resolving names onto
    // settings handlers and actions can be mocked for integration tests
    fluid.defaults("gpii.lifecycleManager.nameResolver", {
        gradeNames: ["fluid.littleComponent", "autoInit"],
        invokers: {
            resolveName: {
                funcName: "fluid.identity"
            }
        }
    });

    fluid.defaults("gpii.lifecycleManager.variableResolver", {
        gradeNames: ["fluid.eventedComponent", "autoInit"],
        components: {
            resolverConfig: {
                type: "gpii.lifecycleManager.standardResolverConfig"
            }
        },
        members: {
            resolvers: {
                expander: {
                    func: "gpii.lifecycleManager.variableResolver.computeResolvers",
                    args: "{that}.resolverConfig.options.resolvers"
                }
            },
            fetcher: {
                expander: {
                    func: "gpii.resolversToFetcher",
                    args: "{that}.resolvers"
                }
            }
        },
        invokers: {
            resolve: {
                funcName: "gpii.lifecycleManager.variableResolver.resolve",
                args: ["{arguments}.0", "{that}.fetcher", "{arguments}.1"]
            }
        }
    });

    gpii.lifecycleManager.variableResolver.computeResolvers = function (resolvers) {
        return fluid.transform(resolvers, fluid.getGlobalValue);
    };

    gpii.lifecycleManager.variableResolver.resolve = function (material, fetcher, extraFetcher) {
        return fluid.expand(material, {
            bareContextRefs: false,
            // TODO: FLUID-4932 - the framework currently has no wildcard
            // support in mergePolicy.
            mergePolicy: {
                0: {
                    capabilitiesTransformations: {
                        "*": {
                            noexpand: true
                        }
                    }
                }
            },
            fetcher: gpii.combineFetchers(fetcher, extraFetcher)
        });
    };

    gpii.resolversToFetcher = function (resolvers) {
        return function (parsed) {
            var resolver = resolvers[parsed.context];
            return !resolver? undefined : (
                typeof(resolver) === "function" ?
                    resolver(parsed.path) : fluid.get(resolver, parsed.path));
        };
    };

    gpii.combineFetchers = function (main, fallback) {
        return fallback ? function (parsed) {
            var fetched = main(parsed);
            return fetched === undefined? fallback(parsed) : fetched;
        } : main;
    };

    fluid.defaults("gpii.lifecycleManager.standardResolverConfig", {
        gradeNames: ["fluid.littleComponent", "autoInit", "fluid.applyGradeLinkage"],
        resolvers: {
            environment: "gpii.lifecycleManager.environmentResolver"
        }
    });

    gpii.lifecycleManager.environmentResolver = function (name) {
        return process.env[name];
    };

    // Transforms the handlerSpec (handler part of the payload) to the model
    // required by the settingsHandler
    gpii.lifecycleManager.specToSettingsHandler = function (solutionId, handlerSpec) {
        var returnObj = {};
        returnObj[solutionId] = [{
            settings: handlerSpec.settings,
            options: handlerSpec.options
        }];
        return returnObj; // NB array removed here
    };

    gpii.lifecycleManager.responseToSnapshotRules = {
        "*.*.settings.*": {
            transform: {
                type: "value",
                inputPath: "oldValue"
            }
        }
    };

    fluid.model.escapedPath = function () {
        var path = "";
        for (var i = 0; i < arguments.length; ++i) {
            path = fluid.pathUtil.composePath(path, arguments[i]);
        }
        return path;
    };

    // Transform the response from the handler to a format that we can pass back to it
    gpii.lifecycleManager.responseToSnapshot = function (solutionId, handlerResponse) {
        var unValued = fluid.model.transform(handlerResponse,
            gpii.lifecycleManager.responseToSnapshotRules, {isomorphic: true});
        // TODO: Should eventually be able to do this final stage through
        // transformation too
        return fluid.get(unValued, fluid.model.escapedPath(solutionId, "0"),
            fluid.model.escapedGetConfig);
    };

   // Payload example:
   //   http://wiki.gpii.net/index.php/Settings_Handler_Payload_Examples
   // Transformer output:
   //   http://wiki.gpii.net/index.php/Transformer_Payload_Examples
    gpii.lifecycleManager.invokeSettingsHandlers = function (solutionId, settingsHandlers, nameResolver) {
        // array just indexed by number, each one holds one handler for this id
        return fluid.transform(settingsHandlers, function (handlerSpec) {
            // first prepare the payload for the settingsHandler in question -
            // a more efficient implementation might bulk together payloads
            // destined for the same handler
            var settingsHandlerPayload = gpii.lifecycleManager.specToSettingsHandler(solutionId, handlerSpec);
            // send the payload to the settingsHandler
            var resolvedName = nameResolver.resolveName(handlerSpec.type, "settingsHandler");
            var handlerResponse = fluid.invokeGlobalFunction(resolvedName + ".set", [settingsHandlerPayload]);
            var settingsSnapshot = gpii.lifecycleManager.responseToSnapshot(solutionId, handlerResponse);
            var handlerCopy = fluid.copy(handlerSpec);
            delete handlerCopy.settings;
            return $.extend(true, handlerCopy, settingsSnapshot);
            // update the settings section of our snapshot to contain the new format
        });
    };


    gpii.lifecycleManager.invokeAction = function (action, nameResolver) {
        var resolvedName = nameResolver.resolveName(action.type, "action");
        var defaults = fluid.defaults(resolvedName);
        if (!defaults || !defaults.argumentMap) {
            fluid.fail("Error in action definition - " + resolvedName +
                " cannot be looked up to a function with a proper argument map: ", action);
        }
        var args = [];
        fluid.each(defaults.argumentMap, function (value, key) {
            args[value] = action[key];
        });
        return fluid.invokeGlobalFunction(resolvedName, args);
    };

    // Returns the results from any settings action, builds up action returns in
    // argument "actionResults"
    gpii.lifecycleManager.executeActions = function (solutionId, settingsHandlers, actions, sessionState, nameResolver) {
        var togo, expanded;
        for (var i = 0; i < actions.length; ++ i) {
            var action = actions[i];
            if (typeof(action) === "string") {
                if (action === "setSettings" || action === "restoreSettings") {
                    expanded = sessionState.localResolver(settingsHandlers);
                    togo = gpii.lifecycleManager.invokeSettingsHandlers(solutionId, expanded, nameResolver);
                }
            }
            else {
                expanded = sessionState.localResolver(action);
                var result = gpii.lifecycleManager.invokeAction(expanded, nameResolver);
                if (action.name) {
                    sessionState.actionResults[action.name] = result;
                }
            }
        }
        return togo;
    };

    // Will return one of the token keys for an active session
    // TODO: We need to implement logic to ensure at most one of these is set, or
    // to manage logic for superposition of sessions if we permit several (see GPII-102)
    gpii.lifecycleManager.getActiveSessionTokens = function (activeSessions) {
        return fluid.keys(activeSessions);
    };

    gpii.lifecycleManager.getSession = function (activeSessions, tokens) {
        if (tokens.length === 0) {
            fluid.fail("Attempt to get sessions without keys");
        } else {
            return activeSessions[tokens[0]];
        }
    };

    /**
     * Structure of lifecycleManager options:
     * userid: userid,
     * actions: either start or stop configuration from solutions registry
     * settingsHandlers: transformed settings handler blocks
     */
    gpii.lifecycleManager.stop = function (that, options, callback) {
        var userToken = options.userToken;
        var sessionState = that.activeSessions[userToken];
        if (!sessionState) {
            callback(false);
            return;
        }

        fluid.each(sessionState.solutions, function (solution, solutionId) {
            gpii.lifecycleManager.executeActions(solutionId,
                solution.settingsHandlers, solution.lifecycleManager.stop,
                sessionState, that.nameResolver);
        });
        delete that.activeSessions[userToken];
        callback(true);
    };

    /**
     * Update user preferences.
     */
    gpii.lifecycleManager.update = function (that, options, solutions, callback) {
        var userToken = options.userToken;
        var sessionState = that.activeSessions[userToken];
        if (!sessionState) {
            fluid.fail("User with token ", userToken, " has no active session");
        }

        var togo = {};
        fluid.each(solutions, function (solution, solutionId) {
            if (!solution.dynamic) {
                togo.restart = true;
                return;
            }
            var solIndex = fluid.find(sessionState.solutions,
                function findIndex(sol, index) {
                    if (sol.id === solutionId) {
                        return index;
                    }
                }
            );
            var sol, actions;
            if (solIndex < 0) {
                sol = fluid.copy(solution);
                actions = solution.lifecycleManager.start;
            } else {
                sol = sessionState.solutions.splice(solIndex, 1)[0];
                actions = ["setSettings"];
            }
            gpii.lifecycleManager.applySolution(sol, solution, actions, sessionState, that.nameResolver);
        });

        if (!togo.restart) {
            togo.success = true;
        }
        callback(togo);
    };

    gpii.lifecycleManager.applySolution = function (solution, solutionId, sessionState, nameResolver) {
        var solutionCpy = fluid.copy(solution);
        solutionCpy.settingsHandlers = gpii.lifecycleManager.executeActions(
            solutionId, solution.settingsHandlers, solution.lifecycleManager.start, sessionState, nameResolver);

        if (solutionCpy.lifecycleManager.start) {
            delete solutionCpy.lifecycleManager.start;
        }
        sessionState.solutions[solutionId] = solutionCpy;
    };

    gpii.lifecycleManager.start = function (that, options, solutions, callback) {
        var userToken = options.userToken;
        if (that.activeSessions[userToken]) {
            // TODO: develop async architecture to prevent rat's nest of callbacks
            that.stop({userToken: userToken}, fluid.identity);
        }
        var sessionState = $.extend(true, {
            actionResults: {}
        }, options);

        // let the user's token as well as any named action results accumulated
        // to date be resolvable for any future action
        sessionState.localFetcher = gpii.combineFetchers(
            gpii.resolversToFetcher({userToken: userToken}),
            gpii.resolversToFetcher(sessionState.actionResults));

        sessionState.localResolver = function (material) {
            return that.variableResolver.resolve(material, sessionState.localFetcher);
        };

        // Data is an array of solutions with settingsHandlers and
        // launchHandlers for each solution
        sessionState.solutions = {};
        fluid.each(solutions, function (solution, solutionId) {
            // build structure for returned values (for later reset)
            gpii.lifecycleManager.applySolution(solution, solutionId, sessionState, that.nameResolver);
        });
        that.activeSessions[userToken] = sessionState;
        callback(true);
    };

}());
