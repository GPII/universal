/*!
 * Lifecycle Manager
 *
 * Copyright 2012 Antranig Basman
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = fluid || require("infusion");
var $ = fluid.registerNamespace("jQuery");
var gpii = fluid.registerNamespace("gpii");

(function () {

    fluid.defaults("gpii.lifecycleManager", {
        gradeNames: ["fluid.eventedComponent", "autoInit"],
        retryOptions: {      // Options governing how often to recheck whether settings are set (and in future, to check for running processes)
            rewriteEvery: 3, // Every 3rd attempt, rewrite the required settings again
            numRetries: 12,  // Make 12 attempts over a period of 12 seconds to discover whether settings are set
            retryInterval: 1000
        },
        components: {
            variableResolver: {
                type: "gpii.lifecycleManager.variableResolver"
            },
            nameResolver: {
                type: "gpii.lifecycleManager.nameResolver"
            }
        },
        members: {
            activeSessions: {}
        },
        invokers: {
            getActiveSessionTokens: {
                funcName: "gpii.lifecycleManager.getActiveSessionTokens",
                args: "{that}.activeSessions"
            },
            getSession: {
                funcName: "gpii.lifecycleManager.getSession",
                args: ["{that}.activeSessions", "{arguments}.0"] // user token
            },
            // TODO: refactor these three methods so that they return promises
            stop: {
                funcName: "gpii.lifecycleManager.stop",
                args: ["{that}", "{requestProxy}", "{arguments}.0", "{arguments}.1"]
            },                    // options, callback
            start: {
                funcName: "gpii.lifecycleManager.start",
                args: ["{that}", "{requestProxy}", "{arguments}.0", "{arguments}.1"]
                                  // finalPayload, callback
            },
            update: {
                funcName: "gpii.lifecycleManager.update",
                args: ["{that}", "{requestProxy}", "{arguments}.0", "{arguments}.1"]
            },                    // finalPayload, callback
            applySolution: {
                funcName: "gpii.lifecycleManager.applySolution",
                args: ["{that}", "{arguments}.0", "{arguments}.1", "{arguments}.2", "{arguments}.3", "{arguments}.4", "{arguments}.5"]
                                  // toSnapshot, solutionId,  solutionRecord, actions, sessionState, isUpdate
            },
            executeActions: {
                funcName: "gpii.lifecycleManager.executeActions",
                args: ["{that}", "{arguments}.0", "{arguments}.1", "{arguments}.2", "{arguments}.3"]
                                  // solutionId, settingsHandlers, actions, sessionState
            },
            invokeSettingsHandlers: {
                funcName: "gpii.lifecycleManager.invokeSettingsHandlers",
                args: ["{that}",  "{arguments}.0", "{arguments}.1"]
                                  // solutionId, settingsHandlers
            }
        }
    });

    // A standard interception point so that the process of resolving names onto
    // settings handlers and actions can be mocked for integration tests
    fluid.defaults("gpii.lifecycleManager.nameResolver", {
        gradeNames: ["fluid.littleComponent", "autoInit"],
        invokers: {
            resolveName: {
                funcName: "fluid.identity"
            }
        }
    });

    fluid.defaults("gpii.lifecycleManager.variableResolver", {
        gradeNames: ["fluid.eventedComponent", "autoInit"],
        components: {
            resolverConfig: {
                type: "gpii.lifecycleManager.standardResolverConfig"
            }
        },
        members: {
            resolvers: {
                expander: {
                    func: "gpii.lifecycleManager.variableResolver.computeResolvers",
                    args: "{that}.resolverConfig.options.resolvers"
                }
            },
            fetcher: {
                expander: {
                    func: "gpii.resolversToFetcher",
                    args: "{that}.resolvers"
                }
            }
        },
        invokers: {
            resolve: {
                funcName: "gpii.lifecycleManager.variableResolver.resolve",
                args: ["{arguments}.0", "{that}.fetcher", "{arguments}.1"]
            }
        }
    });

    gpii.lifecycleManager.variableResolver.computeResolvers = function (resolvers) {
        return fluid.transform(resolvers, fluid.getGlobalValue);
    };

    gpii.lifecycleManager.variableResolver.resolve = function (material, fetcher, extraFetcher) {
        return fluid.expand(material, {
            bareContextRefs: false,
            // TODO: FLUID-4932 - the framework currently has no wildcard support in mergePolicy.
            mergePolicy: {
                0: {
                    capabilitiesTransformations: {
                        "*": {
                            noexpand: true
                        }
                    }
                }
            },
            fetcher: gpii.combineFetchers(fetcher, extraFetcher)
        });
    };

    gpii.resolversToFetcher = function (resolvers) {
        return function (parsed) {
            var resolver = resolvers[parsed.context];
            return !resolver ? undefined : (
                typeof(resolver) === "function" ?
                    resolver(parsed.path) : fluid.get(resolver, parsed.path));
        };
    };

    gpii.combineFetchers = function (main, fallback) {
        return fallback ? function (parsed) {
            var fetched = main(parsed);
            return fetched === undefined ? fallback(parsed) : fetched;
        } : main;
    };

    fluid.defaults("gpii.lifecycleManager.standardResolverConfig", {
        gradeNames: ["fluid.littleComponent", "autoInit", "fluid.applyGradeLinkage"],
        resolvers: {
            environment: "gpii.lifecycleManager.environmentResolver"
        }
    });

    gpii.lifecycleManager.environmentResolver = function (name) {
        return process.env[name];
    };

    // Transforms the handlerSpec (handler part of the transformer's response payload) to a form
    // accepted by a settingsHandler - we use a 1-element array holding the payload for a single solution
    // per handler
    gpii.lifecycleManager.specToSettingsHandler = function (solutionId, handlerSpec) {
        var returnObj = {};
        returnObj[solutionId] = [{
            settings: handlerSpec.settings,
            options: handlerSpec.options
        }];
        return returnObj; // NB array removed here
    };

    // Transform the response from the handler SET to a format that we can pass to handler SET on restore - "oldValue" becomes plain value
    gpii.lifecycleManager.responseToSnapshot = function (solutionId, handlerResponse) {
        var unValued = gpii.settingsHandlers.setResponseToSnapshot(handlerResponse);
        // Note - we deal in these 1-element arrays just for simplicity in the LifecycleManager. A more efficient
        // implementation might send settings for multiple solutions to the same settingsHandler in a single request.
        // Note that in the session's snapshots, this level of array containment has been removed.
        return fluid.get(unValued, [solutionId, 0]);
    };

   // Payload example:
   //   http://wiki.gpii.net/index.php/Settings_Handler_Payload_Examples
   // Transformer output:
   //   http://wiki.gpii.net/index.php/Transformer_Payload_Examples
    gpii.lifecycleManager.invokeSettingsHandlers = function (that, solutionId, settingsHandlers) {
        // array just indexed by number, each one holds one handler for this id
        var settingsPackage = fluid.transform(settingsHandlers, function (handlerSpec) {
            // first prepare the payload for the settingsHandler in question - a more efficient
            // implementation might bulk together payloads destined for the same handler
            var settingsHandlerPayload = gpii.lifecycleManager.specToSettingsHandler(solutionId, handlerSpec);
            var resolvedName = that.nameResolver.resolveName(handlerSpec.type, "settingsHandler");
            return {
                setSettings: function () {
                    var togo = gpii.settingsHandlers.dispatchSettingsHandler(resolvedName, settingsHandlerPayload, that.options.retryOptions);
                    return togo;
                },
                makeSnapshot: function (handlerResponse) {
                    // update the settings section of our snapshot to contain the new information
                    var settingsSnapshot = gpii.lifecycleManager.responseToSnapshot(solutionId, handlerResponse);
                    // Settings handlers may or may not return options (currently it seems they all do) - gain resistance to this by restoring the
                    // original "options" supplied to them.
                    fluid.each(handlerSpec, function (entry, key) {
                        if (key !== "settings") {
                            settingsSnapshot[key] = fluid.copy(entry);
                        }
                    });
                    return settingsSnapshot;
                }
            };
        });
        var responsePromise = fluid.promise.sequence(fluid.getMembers(settingsPackage, "setSettings"));
        var togo = fluid.promise();
        responsePromise.then(function (responses) {
            var snapshots = fluid.transform(responses, function (handlerResponse, i) {
                return settingsPackage[i].makeSnapshot(handlerResponse);
            });
            togo.resolve(snapshots);
        }, togo.reject);
        return togo;
    };

    gpii.lifecycleManager.invokeAction = function (action, nameResolver) {
        var resolvedName = nameResolver.resolveName(action.type, "action");
        return fluid.invokeGradedFunction(resolvedName, action);
    };

    // Called for each solution during both the "stop" and "start" phases - it is agnostic as to which phase it is. Actions to be performed
    // are held in array "actions" and the settingsHandlers block from "solutions" (either Transformer output, or snapshot output from "start"
    // phase) encodes the settings to be set

    // Returns the results from the settings action present in the list, and builds up action returns in session state "actionResults" field
    // (so that these may be referenced from context expressions in further actions).
    gpii.lifecycleManager.executeActions = function (that, solutionId, settingsHandlers, actions, sessionState) {
        var settingsReturn;
        var sequence = fluid.transform(actions, function (action) {
            if (typeof(action) === "string") {
                if (action === "setSettings" || action === "restoreSettings") {
                    return function () {
                        var expanded = sessionState.localResolver(settingsHandlers);
                        var settingsPromise = that.invokeSettingsHandlers(solutionId, expanded);
                        settingsPromise.then(function (snapshot) {
                            settingsReturn = snapshot;
                        });
                        return settingsPromise;
                    };
                } else {
                    fluid.fail("Unrecognised string action in LifecycleManager: " + action);
                }
            } else {
                return function () {
                    var expanded = sessionState.localResolver(action);
                    var result = gpii.lifecycleManager.invokeAction(expanded, that.nameResolver);
                    if (action.name) {
                        sessionState.actionResults[action.name] = result;
                    }
                };
            }
        });
        var resolved = fluid.promise.sequence(sequence);
        var togo = fluid.promise();
        resolved.then(function () {
            togo.resolve(settingsReturn);
        }, togo.reject);
        return togo;
    };

    /** Invoked on both "start" and "update" phases - in addition to forwarding to gpii.lifecycleManager.executeActions,
     * it ensures that the session state snapshot is updated with any results and deletes the "start" action set to
     * ensure this is executed just once (bug here)
     * @param toSnapshot {Object} is the structure which will be modified to form the snapshot record (aka. originalSettings) and stashed in sessionState
     * @param solutionRecord {Object} is not modified and consists of the original transformer return (doesn't really appear necessary)
     * @param isUpdate {boolean} indicates whether we're doing an update - in which case the originalSettings should not be written based on snapshot
     * @return {Promise} The same promise yielded by executeActions - the stateful construction of the session state is tacked onto this promise
     * as a side-effect
     */
    gpii.lifecycleManager.applySolution = function (that, toSnapshot, solutionId, solutionRecord, actions, sessionState, isUpdate) {
        var promise = that.executeActions(solutionId, solutionRecord.settingsHandlers, actions, sessionState);
        sessionState.appliedSolutions = {};
        promise.then(function (snapshot) {
            // always store the currently applied solutions
            sessionState.appliedSolutions[solutionId] = solutionRecord;

            if (!isUpdate) {
                // store original settings
                toSnapshot.settingsHandlers = snapshot;
                sessionState.originalSettings[solutionId] = toSnapshot;
            }
        });
        return promise;
    };

    // Will return one of the users token keys for an active session
    // TODO: We need to implement logic to ensure at most one of these is set, or
    // to manage logic for superposition of sessions if we permit several (see GPII-102)
    gpii.lifecycleManager.getActiveSessionTokens = function (activeSessions) {
        return fluid.keys(activeSessions);
    };

    gpii.lifecycleManager.getSession = function (activeSessions, userTokens) {
        if (userTokens.length === 0) {
            fluid.fail("Attempt to get sessions without keys");
        } else {
            return activeSessions[userTokens[0]];
        }
    };

    /**
     * Structure of lifecycleManager options:
     * userid: userid,
     * actions: either start or stop configuration from solutions registry
     * settingsHandlers: transformed settings handler blocks
     */
    gpii.lifecycleManager.stop = function (that, requestProxy, options, callback) {
        var userToken = options.userToken;
        var sessionState = that.activeSessions[userToken];
        if (!sessionState) {
            callback(false);
            return;
        }

        var promises = fluid.transform(sessionState.originalSettings, function (solution, solutionId) {
            return that.executeActions(solutionId, solution.settingsHandlers, solution.lifecycleManager.stop, sessionState);
        });
        // TODO: In theory we could stop all solutions in parallel
        var sequence = fluid.promise.sequence(fluid.values(promises));
        sequence.then(function () {
            delete that.activeSessions[userToken];
            callback(true);
        }, function (error) {
            requestProxy.events.onError.fire(error);
        });
    };

    /**
     * Update user preferences.
     */
    gpii.lifecycleManager.update = function (that, requestProxy, finalPayload, callback) {
        var userToken = finalPayload.userToken,
            lifecycleInstructions = finalPayload.lifecycleInstructions;
        var sessionState = that.activeSessions[userToken];
        if (!sessionState) {
            fluid.fail("User with token ", userToken, " has no active session");
        }

        var togo = {};
        var promises = [];
        fluid.each(lifecycleInstructions, function (solution, solutionId) {
            // This check is redundant. Currently PCP is only showing adjusters with dynamic solutions.
            // Also, dynamic solutions aren't explicitly distinguished from non-dynamic right now.
            // TODO: Add 'dynamic: true' to all dynamic solutions after PCP's visualization of adjusters becomes controlled by MM.
            /*if (!solution.dynamic) {
                togo.restart = true;
                return;
            }*/
            var sol = fluid.copy(solution);
            var actions = [];
            if (sessionState.appliedSolutions[solutionId]) {
                // merge already applied settings with the updates
                sol = $.extend(true, {}, sessionState.appliedSolutions[solutionId], sol);
            }

            // TODO: check if we need to modify this once: active: bool is supported
            if (solution.lifecycleManager.start.indexOf("setSettings") !== -1) {
                actions = [ "setSettings" ];
            }

            promises.push(that.applySolution(null, solutionId, sol, actions, sessionState, true));
        });
        var sequence = fluid.promise.sequence(promises);
        sequence.then(function () {
            if (!togo.restart) {
                togo.success = true;
            }
            callback(togo);
        }, function (error) {
            requestProxy.events.onError.fire(error);
        });
        return sequence;
    };

    gpii.lifecycleManager.start = function (that, requestProxy, finalPayload, callback) {
        var userToken = finalPayload.userToken,
            lifecycleInstructions = finalPayload.lifecycleInstructions;
        if (that.activeSessions[userToken]) {
            // TODO: develop async architecture to prevent rat's nest of callbacks
            that.stop({userToken: userToken}, fluid.identity);
        }
        // TODO: Make global map of all users of session state
        //   activeConfiguration: Assigned in contextManager.evaluateMatch, consumed in UserUpdate
        //   userToken, solutionsRegistryEntries: Assigned in initialPayload, consumed in UserUpdate
        var sessionState = $.extend(true, {
            actionResults: {}
        }, fluid.filterKeys(finalPayload, ["userToken", "activeConfiguration", "solutionsRegistryEntries", "matchMakerOutput"]));

        // let the user's token as well as any named action results accumulated
        // to date be resolvable for any future action
        sessionState.localFetcher = gpii.combineFetchers(
            gpii.resolversToFetcher({userToken: userToken}),
            gpii.resolversToFetcher(sessionState.actionResults));

        sessionState.localResolver = function (material) {
            return that.variableResolver.resolve(material, sessionState.localFetcher);
        };

        // This "start" action builds up a payload in sessionState.originalSettings which is exactly isomorphic with the one
        // we received from the transformer ourselves - only containing the original snapshotted solutions settings rather
        // than the user's ones. When "stop" is called we will supply this payload to gpii.lifecycleManager.executeActions directly
        sessionState.originalSettings = {};
        var tasks = [];
        fluid.each(lifecycleInstructions, function (solution, solutionId) {
            tasks.push(function () {
                // build structure for returned values (for later reset)
                var togo = fluid.copy(solution);
                return that.applySolution(togo, solutionId, solution, solution.lifecycleManager.start, sessionState, false);
            });
        });
        that.activeSessions[userToken] = sessionState;
        // Note that these promises are only sequenced for their side-effects (the ones on sessionState within applySolution and on the system at large
        // via the settings handlers)
        var sequence = fluid.promise.sequence(tasks);
        sequence.then(function () {
            callback(true);
        }, function (error) {
            requestProxy.events.onError.fire(error);
        });
    };
}());
