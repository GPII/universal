/*!
 * Lifecycle Manager Resolvers
 *
 * Copyright 2012 Antranig Basman
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = fluid || require("infusion");
var gpii = fluid.registerNamespace("gpii");

(function () {
    // A standard interception point so that the process of resolving names onto
    // settings handlers and actions can be mocked for integration tests

    fluid.defaults("gpii.lifecycleManager.nameResolver", {
        gradeNames: ["fluid.component"],
        invokers: {
            resolveName: {
                funcName: "fluid.identity"
            }
        }
    });

    /** The central machinery in the Lifecycle Manager which manages the process
      * of resolving contextual expressions such as ${{environment}.WINDIR} onto
      * strings by interpolation.
      */

    fluid.defaults("gpii.lifecycleManager.variableResolver", {
        gradeNames: ["fluid.component"],
        components: {
            resolverConfig: {
                type: "gpii.lifecycleManager.standardResolverConfig"
            }
        },
        members: {
            resolvers: {
                expander: {
                    func: "gpii.lifecycleManager.variableResolver.computeResolvers",
                    args: "{that}.resolverConfig.options.resolvers"
                }
            },
            fetcher: {
                expander: {
                    func: "gpii.resolversToFetcher",
                    args: "{that}.resolvers"
                }
            }
        },
        invokers: {
            /** Resolves interpolated variables within some options material (argument 0).
             * This is resolved first against the `builtin fetcher` which is computed by pooling
             * environmental fetchers from the platform-specific repositories, together with
             * a fetcher resolving onto variables in the user's current session (argument 1)
             */
            resolve: {
                funcName: "gpii.lifecycleManager.variableResolver.resolve",
                args: ["{arguments}.0", "{that}.fetcher", "{arguments}.1"]
            }
        }
    });

    gpii.lifecycleManager.variableResolver.computeResolvers = function (resolvers) {
        return fluid.transform(resolvers, fluid.getGlobalValue);
    };

    gpii.lifecycleManager.variableResolver.resolve = function (material, fetcher, extraFetcher) {
        // TODO: This relies on a horribly undocumented and unstable Infusion API
        return fluid.expand(material, {
            bareContextRefs: false,
            // TODO: FLUID-4932 - the framework currently has no wildcard support in mergePolicy.
            mergePolicy: {
                0: {
                    capabilitiesTransformations: {
                        "*": {
                            noexpand: true
                        }
                    }
                }
            },
            fetcher: gpii.combineFetchers(fetcher, extraFetcher)
        });
    };

    /** Converts a free hash of "resolvers" (keyed by resolver name) into a
     * "fetcher" suitable for being operated by Infusion's expansion machinery resolving
     * expressions such as ${{environment}.WINDIR} when they are seen within strings for interpolation.
     */

    gpii.resolversToFetcher = function (resolvers) {
        return function (parsed) {
            var resolver = resolvers[parsed.context];
            return !resolver ? undefined : (
                typeof(resolver) === "function" ?
                    resolver(parsed.path) : fluid.get(resolver, parsed.path));
        };
    };

    /** A hacked and unsatisfactory method to compose two fetchers (the second of which is optional)
     * into a single one
     */
    gpii.combineFetchers = function (main, fallback) {
        return fallback ? function (parsed) {
            var fetched = main(parsed);
            return fetched === undefined ? fallback(parsed) : fetched;
        } : main;
    };

    /** Central standard repository for "resolvers" mapping some environmental material onto
     * resolvable expressions. This is targetted, e.g., from the windows repository by a
     * grade linkage registering the Windows Registry resolver.
     * It contains an option named `resolvers` which maps resolver names (which will act as context names,
     * in expressions such as ${{environment}.WINDIR}) onto global names, which are resolvable via
     * `fluid.getGlobalValue` to unary functions resolving the path expressions - these unary
     * functions mapping Strings to Strings are named (variable) `resolvers`.
     */

    fluid.defaults("gpii.lifecycleManager.standardResolverConfig", {
        gradeNames: "fluid.component",
        resolvers: {
            environment: "gpii.lifecycleManager.environmentResolver"
        }
    });

    gpii.lifecycleManager.environmentResolver = function (name) {
        return process.env[name];
    };

})();
