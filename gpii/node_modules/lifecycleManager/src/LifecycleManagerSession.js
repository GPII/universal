/*!
 * Lifecycle Manager Session
 *
 * Copyright 2016 Raising the Floor - International
 * Copyright 2019 OCAD University
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = fluid || require("infusion"),
    $ = fluid.registerNamespace("jQuery"),
    gpii = fluid.registerNamespace("gpii");

(function () {

    /** Mediate between updates to the session component's original snapshot and the external `onSessionSnapshotUpdate` fired by the
      * LifecycleManager (principally to the journaller)
      */
    fluid.defaults("gpii.lifecycleManager.sessionSnapshotUpdater", {
        gradeNames: "fluid.component",
        modelListeners: {
            "originalSettings": {
                excludeSource: ["init", "SessionCleanup"],
                func: "{gpii.lifecycleManager}.events.onSessionSnapshotUpdate.fire",
                args: ["{gpii.lifecycleManager}", "{that}", "{change}.value"]
            }
        }
    });

    /** Two component of this type are constructed as lifecycleManager subcomponents for key-in sessions:
     * 1. The user key in session;
     * 2. The session for restoring the system to specific original settings.
     */
    fluid.defaults("gpii.lifecycleManager.session", {
        gradeNames: ["fluid.modelComponent"],
        model: {
            // The matchMaker output payload for applied preferences.
            gpiiKey: undefined,
            /*
            preferences: {Object},
            activePrefsSetName: {String},
            solutionsRegistryEntries: {Object},
            activeConfiguration: {Object},
            matchMakerOutput: {Object},
            */

            // The original solution settings at the key-in in preparation for a restore.
            originalSettings: {},
            // In the same structure as "originalSettings" but tracks currently applied solution settings.
            currentSettings: {},

            // Keep track of all preferences applied or read. PSPChannel goes through it to generate output
            // for PSPChannel clients.
            currentPreferences: {},

            // Action results of free lifecycle actions.
            actionResults: {}
        },
        modelListeners: {
            preferences: {
                listener: "gpii.lifecycleManager.session.savePrefsUpdates",
                args: ["{that}", "{change}.value", "{change}.transaction.sources", "{gpii.lifecycleManager}.events.onAutoSaveRequired"]
            }
        },
        invokers: {
            localResolver: "gpii.lifecycleManager.localResolver({gpii.lifecycleManager}, {that}, {arguments}.0)"
        }
    });

    /**
     * Filter the preferences by metadata defined in the preferences set. Only the preferences that are allowed to be
     * autosaved will be returned.
     * @param {Object} preferences - The updated preferences.
     * @param {Object} metadata - The metadata that defined in the prefs set.
     * @return {Object|Undefined} - The preferences to be autosaved. Return undefined when no preferences are found.
     */
    gpii.lifecycleManager.session.filterPrefsByAutoSave = function (preferences, metadata) {
        var autoSaveScope;
        fluid.each(metadata, function (meta) {
            if (meta.type === "autosave") {
                autoSaveScope = autoSaveScope || {};
                fluid.each(meta.scope, function (oneScope) {
                    var oneScopeArray = fluid.makeArray(oneScope);
                    fluid.set(autoSaveScope, oneScopeArray, true);
                });
            }
        });

        // Preferences will not be auto saved if the "autosave" metadata is not defined
        if (!autoSaveScope) {
            return undefined;
        }

        var prefsForAutoSave = {};
        fluid.each(preferences, function (prefValue, prefKey) {
            var autoSaveValue = autoSaveScope[prefKey];
            if (prefKey.startsWith("http://registry.gpii.net/applications")) {
                fluid.each(prefValue, function (commonValue, commonKey) {
                    var autoSaveCommon = autoSaveValue ? autoSaveValue[commonKey] : null;
                    if (autoSaveCommon === true) {
                        fluid.set(prefsForAutoSave, [prefKey, commonKey], commonValue);
                    }
                });
            } else if (autoSaveValue === true) {
                fluid.set(prefsForAutoSave, [prefKey], prefValue);
            }
        });

        return $.isEmptyObject(prefsForAutoSave) ? undefined : prefsForAutoSave;
    };

    /**
     * Auto save prefs to the cloud when the preferences are updated. Note that change requests on session.model.preferences
     * are also fired by the lifecycleManager session start and changes in preferences sets, in which cases preferences should
     * not be written to the cloud.
     * @param {Component} that - An instance of gpii.lifecycleManager.session.
     * @param {Object} preferences - The updated preferences that will be saved.
     * @param {Object} transactionSources - The transaction sources from the model change request.
     * @param {Event} onAutoSaveRequired - Fired to trigger the save action to the cloud.
     */
    gpii.lifecycleManager.session.savePrefsUpdates = function (that, preferences, transactionSources, onAutoSaveRequired) {
        var autoSavePrefs = fluid.copy(preferences);
        if (transactionSources.userUpdate) {
            var metadata = fluid.get(that.model, ["preferences", "contexts", that.model.activePrefsSetName, "metadata"]);
            var prefsInActivePrefsSet = fluid.get(preferences, ["contexts", that.model.activePrefsSetName, "preferences"]);
            var prefsForAutoSave = gpii.lifecycleManager.session.filterPrefsByAutoSave(prefsInActivePrefsSet, metadata);
            if (prefsForAutoSave) {
                fluid.set(autoSavePrefs, ["contexts", that.model.activePrefsSetName, "preferences"], prefsForAutoSave);
                fluid.log("Lifecycle Manager Session: auto save for gpiiKey (", that.model.gpiiKey, "), with preferences: ", autoSavePrefs);
                onAutoSaveRequired.fire(that.model.gpiiKey, autoSavePrefs);
            }
        }
    };

    /** A standard session corresponding to a standard user logon
     */
    fluid.defaults("gpii.lifecycleManager.userSession", {
        gradeNames: ["gpii.lifecycleManager.session", "gpii.lifecycleManager.sessionSnapshotUpdater"]
    });

    /** A special session type corresponding to a "restore" action by the journaller
    */
    fluid.defaults("gpii.lifecycleManager.restoreSession", {
        gradeNames: "gpii.lifecycleManager.session"
    });

    gpii.lifecycleManager.localResolver = function (lifecycleManager, session, material) {
        return lifecycleManager.variableResolver.resolve(material, session.localFetcher);
    };

    gpii.lifecycleManager.computeLocalFetcher = function (session) {
        // let the user's token as well as anything else in the session be resolvable (this latter is
        // intended only for use in test cases)
        return gpii.resolversToFetcher({
            gpiiKey: session.model.gpiiKey,
            session: function (path) {
                return fluid.get(session.model, path);
            }
        });
    };

})();
