/*!
 * Lifecycle Manager Session
 *
 * Copyright 2016 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = fluid || require("infusion");
var gpii = fluid.registerNamespace("gpii");

(function () {

    /** Mediate between the dynamic collection of session components and the lifecycleManager by maintaining an index
     * named "sessionIndex" mapping gpiiKeys onto session member names
     */

    fluid.defaults("gpii.lifecycleManager.sessionIndexer", {
        gradeNames: "gpii.indexedDynamicComponent",
        components: {
            dynamicIndexTarget: "{gpii.lifecycleManager}"
        },
        dynamicIndexTargetPath: "sessionIndex",
        dynamicIndexKeyPath: "options.gpiiKey"
    });

    /** Mediate between updates to the session component's original snapshot and the external `onSessionSnapshotUpdate` fired by the
      * LifecycleManager (principally to the journaller)
      */
    fluid.defaults("gpii.lifecycleManager.sessionSnapshotUpdater", {
        gradeNames: "fluid.component",
        modelListeners: {
            "originalSettings": {
                excludeSource: "init",
                func: "{gpii.lifecycleManager}.events.onSessionSnapshotUpdate.fire",
                args: ["{gpii.lifecycleManager}", "{that}", "{change}.value"]
            }
        }
    });

    /** One dynamic component of this type is constructed for each active (local) session on the LifecycleManager.
     * In practice we only support one of these at a time - in future we may support sessions bound to multiple users
     * simultaneously or multiple simultaneous sessions.
     */

    fluid.defaults("gpii.lifecycleManager.session", {
        gradeNames: ["fluid.modelComponent", "gpii.lifecycleManager.sessionIndexer"],
        model: {
            actionResults: {},
            originalSettings: {},
            appliedSolutions: {}
        },
        modelListeners: {
            preferences: {
                listener: "gpii.lifecycleManager.session.savePrefsUpdates",
                args: ["{that}.options.gpiiKey", "{change}.value", "{change}.transaction.sources", "{gpii.lifecycleManager}.events.preferencesUserUpdated"]
            }
        },
        members: {
            createTime: "@expand:Date.now()",
            localFetcher: "@expand:gpii.lifecycleManager.computeLocalFetcher({that})"
        },
        invokers: {
            localResolver: "gpii.lifecycleManager.localResolver({gpii.lifecycleManager}, {that}, {arguments}.0)"
        }
    });

    /**
     * Save prefs to the cloud when the preferences are updated. Note that change requests on session.model.preferences
     * are also fired by the lifecycleManager session start and the contextManager, in which cases preferences should
     * not be written to the cloud.
     * @param {String} gpiiKey - A GPII key.
     * @param {Object} preferences - The updated preferences that will be saved to the cloud.
     * @param {Object} transactionSources - The transaction sources from the model change request.
     * @param {Event} preferencesUserUpdated - Fired to trigger the save action to the cloud.
     */
    gpii.lifecycleManager.session.savePrefsUpdates = function (gpiiKey, preferences, transactionSources, preferencesUserUpdated) {
        if (transactionSources.userUpdate) {
            preferencesUserUpdated.fire(gpiiKey, preferences);
        }
    };

    /** A standard session corresponding to a standard user logon
     */
    fluid.defaults("gpii.lifecycleManager.userSession", {
        gradeNames: ["gpii.lifecycleManager.session", "gpii.lifecycleManager.sessionSnapshotUpdater"]
    });

    /** A special session type corresponding to a "restore" action by the journaller
    */
    fluid.defaults("gpii.lifecycleManager.restoreSession", {
        gradeNames: "gpii.lifecycleManager.session"
    });

    gpii.lifecycleManager.localResolver = function (lifecycleManager, session, material) {
        return lifecycleManager.variableResolver.resolve(material, session.localFetcher);
    };

    gpii.lifecycleManager.computeLocalFetcher = function (session) {
        // let the user's token as well as anything else in the session be resolvable (this latter is
        // intended only for use in test cases)
        return gpii.resolversToFetcher({
            gpiiKey: session.options.gpiiKey,
            session: function (path) {
                return fluid.get(session.model, path);
            }
        });
    };

})();
