/*!
 * Lifecycle Manager Session
 *
 * Copyright 2016 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = fluid || require("infusion");
var gpii = fluid.registerNamespace("gpii");

(function () {

    /** Mediate between the dynamic collection of session components and the lifecycleManager by maintaining an index
     * named "sessionIndex" mapping userTokens onto session member names
     */

    fluid.defaults("gpii.lifecycleManager.sessionIndexer", {
        gradeNames: "gpii.indexedDynamicComponent",
        components: {
            dynamicIndexTarget: "{gpii.lifecycleManager}"
        },
        dynamicIndexTargetPath: "sessionIndex",
        dynamicIndexKeyPath: "options.userToken"
    });

    /** Mediate between updates to the session component's original snapshot and the external `onSessionSnapshotUpdate` fired by the
      * LifecycleManager (principally to the journaller)
      */
    fluid.defaults("gpii.lifecycleManager.sessionSnapshotUpdater", {
        gradeNames: "fluid.component",
        modelListeners: {
            "originalSettings": {
                excludeSource: "init",
                func: "{gpii.lifecycleManager}.events.onSessionSnapshotUpdate.fire",
                args: ["{gpii.lifecycleManager}", "{that}", "{change}.value"]
            }
        }
    });

    /** One dynamic component of this type is constructed for each active (local) session on the LifecycleManager.
     * In practice we only support one of these at a time - in future we may support sessions bound to multiple users
     * simultaneously or multiple simultaneous sessions.
     */

    fluid.defaults("gpii.lifecycleManager.session", {
        gradeNames: ["fluid.modelComponent", "gpii.lifecycleManager.sessionIndexer"],
        model: {
            actionResults: {},
            originalSettings: {},
            appliedSolutions: {}
        },
        members: {
            createTime: "@expand:Date.now()",
            // TODO: Refactor this into some more satisfactory future pattern - some kind of lightweight version of "transforming promise chain"
            localFetcher: "@expand:gpii.lifecycleManager.computeLocalFetcher({that}, {that}.actionResultsFetcher)"
        },
        invokers: {
            actionResultsFetcher: "gpii.lifecycleManager.actionResultsFetcher({that}, {arguments}.0)",
            localResolver: "gpii.lifecycleManager.localResolver({gpii.lifecycleManager}, {that}, {arguments}.0)"
        }
    });

    /** A standard session corresponding to a standard user logon
     */
    fluid.defaults("gpii.lifecycleManager.userSession", {
        gradeNames: ["gpii.lifecycleManager.session", "gpii.lifecycleManager.sessionSnapshotUpdater"]
    });

    /** A special session type corresponding to a "restore" action by the journaller
    */
    fluid.defaults("gpii.lifecycleManager.restoreSession", {
        gradeNames: "gpii.lifecycleManager.session"
    });

    gpii.lifecycleManager.actionResultsFetcher = function (session, parsed) {
        var result = session.model.actionResults[parsed.context];
        return fluid.get(result, parsed.path);
    };

    gpii.lifecycleManager.localResolver = function (lifecycleManager, session, material) {
        return lifecycleManager.variableResolver.resolve(material, session.localFetcher);
    };

    gpii.lifecycleManager.computeLocalFetcher = function (session, actionResultsFetcher) {
        // let the user's token as well as any named action results accumulated
        // to date be resolvable for any future action
        // TODO: This is an opportunistic hack based on the existing 2-arg gpii.combineFetchers. Needs to be
        // generalised
        return gpii.combineFetchers(
            gpii.resolversToFetcher({userToken: session.options.userToken}),
            actionResultsFetcher);
    };



})();
