/*!
 * Lifecycle Manager Session
 *
 * Copyright 2016 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = fluid || require("infusion");
var gpii = fluid.registerNamespace("gpii");

(function () {

    /** Mediate between the dynamic collection of session components and the lifecycleManager by maintaining an index
     * named "sessionIndex" mapping gpiiKeys onto session member names
     */

    fluid.defaults("gpii.lifecycleManager.sessionIndexer", {
        gradeNames: "gpii.indexedDynamicComponent",
        components: {
            dynamicIndexTarget: "{gpii.lifecycleManager}"
        },
        dynamicIndexTargetPath: "sessionIndex",
        dynamicIndexKeyPath: "options.gpiiKey"
    });

    /** Mediate between updates to the session component's original snapshot and the external `onSessionSnapshotUpdate` fired by the
      * LifecycleManager (principally to the journaller)
      */
    fluid.defaults("gpii.lifecycleManager.sessionSnapshotUpdater", {
        gradeNames: "fluid.component",
        modelListeners: {
            "originalSettings": {
                excludeSource: "init",
                func: "{gpii.lifecycleManager}.events.onSessionSnapshotUpdate.fire",
                args: ["{gpii.lifecycleManager}", "{that}", "{change}.value"]
            }
        }
    });

    /** One dynamic component of this type is constructed for each active (local) session on the LifecycleManager.
     * In practice we only support one of these at a time - in future we may support sessions bound to multiple users
     * simultaneously or multiple simultaneous sessions.
     */

    fluid.defaults("gpii.lifecycleManager.session", {
        gradeNames: ["fluid.modelComponent", "gpii.lifecycleManager.sessionIndexer"],
        model: {
            actionResults: {},
            originalSettings: {},
            appliedSolutions: {}
        },
        modelListeners: {
            preferences: {
                listener: "gpii.lifecycleManager.session.savePrefsUpdates",
                args: ["{that}", "{change}.value", "{change}.transaction.sources", "{gpii.lifecycleManager}.events.preferencesUserUpdated"]
            }
        },
        members: {
            createTime: "@expand:Date.now()",
            localFetcher: "@expand:gpii.lifecycleManager.computeLocalFetcher({that})"
        },
        invokers: {
            localResolver: "gpii.lifecycleManager.localResolver({gpii.lifecycleManager}, {that}, {arguments}.0)"
        }
    });

    /**
     * Filter the preferences by metadata defined in the preferences set. Only the preferences that are allowed to be
     * autosaved will be returned.
     * @param {Object} preferences - The updated preferences.
     * @param {Object} metadata - The metadata that defined in the prefs set.
     * @return {Object} - The preferences to be autosaved.
     */
    gpii.lifecycleManager.session.filterPrefsByAutoSave = function (preferences, metadata) {
        var autosaveScope = [];
        fluid.each(metadata, function (meta) {
            if (meta.type === "autosave") {
                var metadataScope = fluid.makeArray(meta.scope);
                autosaveScope = autosaveScope.concat(metadataScope);
            }
        });

        // Preferences will not be auto saved if the "autosave" metadata is not defined
        if (autosaveScope.length === 0) {
            return undefined;
        }

        var prefsForAutoSave;
        fluid.each(autosaveScope, function (autosavePath) {
            autosavePath = fluid.makeArray(autosavePath);
            var matchedValue = fluid.get(preferences, autosavePath);
            if (matchedValue) {
                prefsForAutoSave = prefsForAutoSave || {};
                fluid.set(prefsForAutoSave, autosavePath, matchedValue);
            }
        });

        return prefsForAutoSave;
    };

    /**
     * Auto save prefs to the cloud when the preferences are updated. Note that change requests on session.model.preferences
     * are also fired by the lifecycleManager session start and the contextManager, in which cases preferences should
     * not be written to the cloud.
     * @param {Component} that - An instance of gpii.lifecycleManager.session.
     * @param {Object} preferences - The updated preferences that will be saved.
     * @param {Object} transactionSources - The transaction sources from the model change request.
     * @param {Event} preferencesUserUpdated - Fired to trigger the save action to the cloud.
     */
    gpii.lifecycleManager.session.savePrefsUpdates = function (that, preferences, transactionSources, preferencesUserUpdated) {
        var autoSavePrefs = fluid.copy(preferences);
        if (transactionSources.userUpdate) {
            var metadata = fluid.get(that.model, ["preferences", "contexts", that.model.activeContextName, "metadata"]);
            var prefsInActiveContext = fluid.get(preferences, ["contexts", that.model.activeContextName, "preferences"]);
            var prefsForAutoSave = gpii.lifecycleManager.session.filterPrefsByAutoSave(prefsInActiveContext, metadata);
            if (prefsForAutoSave) {
                fluid.set(autoSavePrefs, ["contexts", that.model.activeContextName, "preferences"], prefsForAutoSave);
                fluid.log("Lifecycle Manager Session: auto save for gpiiKey (", that.options.gpiiKey, "), with preferences: ", autoSavePrefs);
                preferencesUserUpdated.fire(that.options.gpiiKey, autoSavePrefs);
            }
        }
    };

    /** A standard session corresponding to a standard user logon
     */
    fluid.defaults("gpii.lifecycleManager.userSession", {
        gradeNames: ["gpii.lifecycleManager.session", "gpii.lifecycleManager.sessionSnapshotUpdater"]
    });

    /** A special session type corresponding to a "restore" action by the journaller
    */
    fluid.defaults("gpii.lifecycleManager.restoreSession", {
        gradeNames: "gpii.lifecycleManager.session"
    });

    gpii.lifecycleManager.localResolver = function (lifecycleManager, session, material) {
        return lifecycleManager.variableResolver.resolve(material, session.localFetcher);
    };

    gpii.lifecycleManager.computeLocalFetcher = function (session) {
        // let the user's token as well as anything else in the session be resolvable (this latter is
        // intended only for use in test cases)
        return gpii.resolversToFetcher({
            gpiiKey: session.options.gpiiKey,
            session: function (path) {
                return fluid.get(session.model, path);
            }
        });
    };

})();
