/*
 * Install on Demand.
 *
 * Copyright 2018 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion");

var path = require("path"),
    os = require("os"),
    fs = require("fs"),
    request = require("request"),
    glob = require("glob");

var gpii = fluid.registerNamespace("gpii");
fluid.registerNamespace("gpii.iod");

/**
 * Installation state.
 * @typedef {Object} Installation
 * @property {id} - Installation ID
 * @property {packageInfo} packageInfo - Package data.
 * @property {string} packageName - packageInfo.name
 * @property {Component} installer - The gpii.iod.installer instance.
 * @property {boolean} failed - true if the installation had failed.
 * @property {string} tmpDir - Temporary working directory.
 * @property {string} localPackage - Path to the downloaded package file.
 * @property {string[]} cleanupPaths - The directories to remove during cleanup.
 *
 */

fluid.defaults("gpii.iod", {
    gradeNames: ["fluid.component", "fluid.contextAware", "fluid.modelComponent"],
    contextAwareness: {
        platform: {
            checks: {
                windows: {
                    contextValue: "{gpii.contexts.windows}",
                    gradeNames: "gpii.windows.iod"
                }
            }
        }
    },
    components: {
        packages: {
            type: "gpii.iod.packages",
            options: {
                events: {
                    "onServiceFound": "onServiceFound"
                }
            }
        }
    },
    dynamicComponents: {
        installers: {
            createOnEvent: "onInstallerLoad",
            type: "{arguments}.0",
            options: {
                installationID: "{arguments}.1"
            }
        }
    },
    events: {
        onServiceFound: null, // [ endpoint address ]
        onServiceLost: null, // [ endpoint address ]
        onInstallerLoad: null // [ packageInstaller grade name, installation ID ]
    },
    listeners: {
        "onCreate.discoverServer": "{that}.discoverServer",
        "onCreate.readInstallations": "{that}.readInstallations",
        "onServiceFound": "{that}.serviceFound",
        "onServiceLost": "{that}.serviceLost"
    },
    invokers: {
        discoverServer: {
            funcName: "gpii.iod.discoverServer",
            args: ["{that}"]
        },
        requirePackage: {
            funcName: "gpii.iod.requirePackage",
            args: ["{that}", "{arguments}.0"]
        },
        initialiseInstallation: {
            funcName: "gpii.iod.initialiseInstallation",
            args: ["{that}", "{arguments}.0"]
        },
        getInstaller: {
            funcName: "gpii.iod.getInstaller",
            args: ["{that}", "{arguments}.0"]
        },
        getWorkingPath: {
            funcName: "gpii.iod.getWorkingPath",
            args: ["{arguments}.0"]
        },
        serviceFound: {
            funcName: "gpii.iod.serviceFound",
            args: ["{that}", "{arguments}.0"]
        },
        serviceLost: {
            funcName: "gpii.iod.serviceLost",
            args: ["{that}", "{arguments}.0"]
        },
        readInstallations: {
            funcName: "gpii.iod.readInstallations",
            args: ["{that}", "{gpii.journal}.settingsDir.gpiiSettingsDir" ]
        },
        writeInstallation: {
            funcName: "gpii.iod.writeInstallation",
            args: ["{that}", "{gpii.journal}.settingsDir.gpiiSettingsDir", "{arguments}.0"]
        },
        unrequirePackage: {
            funcName: "gpii.iod.unrequirePackage",
            args: ["{that}", "{arguments}.0"]
        },
        uninitialiseInstallation: {
            funcName: "gpii.iod.uninitialiseInstallation",
            args: ["{that}", "{arguments}.0"]
        },
        uninstallPackage: {
            funcName: "gpii.iod.uninstallPackage",
            args: ["{that}", "{arguments}.0"]
        }
    },

    endpoint: undefined,

    members: {
        installations: {}
    }
});

fluid.defaults("gpii.iodLifeCycleManager", {
    gradeNames: ["fluid.component"],
    listeners: {
        "{lifecycleManager}.events.onSessionStop": "{that}.uninitialiseInstallation"
    },

    model: {
        logonChange: "{lifecycleManager}.model.logonChange"
    }

});

/**
 * Reads the stored installations from a previous instance. Installations will be kept when an uninstall fails, or if
 * GPII was closed without keying out.
 * All installed packages from the previous instance will be set for removal.
 *
 * @param {Component} that The gpii.iod instance.
 * @param {String} directory The directory containing the stored installation info.
 * @return {Promise} Resolves when complete.
 */
gpii.iod.readInstallations = function (that, directory) {
    var promise = fluid.promise();
    var needRemove = false;

    glob(path.join(directory, "iod-installation.*.json"), function (err, files) {
        if (err) {
            promise.reject({
                isError: true,
                message: "Unable to read previous installations",
                error: err
            });
        } else {
            fluid.each(files, function (file) {
                try {
                    var content = fs.readFileSync(file);
                    var installation = JSON.parse(content);
                    if (installation && installation.id) {
                        fluid.log("IoD: Existing installation file '" + file + "': ", installation);
                        installation.remove = true;
                        installation.uninstalling = false;
                        needRemove = needRemove || installation.remove;
                        that.installations[installation.id] = installation;
                    }
                } catch (e) {
                    fluid.log("IoD: Error reading stored installation file '" + file + "': ", e);
                }
            });
            process.nextTick(promise.resolve);
        }
    });

    promise.then(function () {
        if (needRemove) {
            // Loaded some uninstalled installation.
            that.uninitialiseInstallation(0);
        }
    });

    return promise;
};

/**
 * Writes information about an installation so it can be uninstalled at a later time.
 * If the installation has been removed, then the file will be deleted.
 *
 * @param {Component} that The gpii.iod instance.
 * @param {String} directory The directory containing the stored installation info.
 * @param {Installation} installation The installation state.
 * @return {String} The file that the installation data was written to.
 */
gpii.iod.writeInstallation = function (that, directory, installation) {
    var filename = path.join(directory, "iod-installation." + installation.id + ".json");

    if (installation.removed) {
        fs.unlinkSync(filename);
    } else {
        // Don't write the installer component.
        var out = Object.assign({}, installation);
        delete out.installer;
        var content = JSON.stringify(out);
        fs.writeFileSync(filename, content);
    }
    return filename;
};

/**
 * Create a directory where packages are temporarily stored.
 *
 * @param {String} packageName Name of the package for which the directory is being created.
 * @return {Object} Contains the full path (fullPath), and the first path that was created (createdPath), for cleanup
 */
gpii.iod.getWorkingPath = function (packageName) {
    var createdPath = null;

    var parts = [
        os.tmpdir(),
        "gpii-iod",
        packageName && packageName.replace(/[^-a-z0-9]/, "_"),
        Math.random().toString(36)
    ];

    // Create a new directory
    var createDirectory = function (parent, child) {
        var dir = path.join(parent, child);
        try {
            fs.mkdirSync(dir);
            if (!createdPath) {
                createdPath = dir;
            }
        } catch (e) {
            if (e.code !== "EEXIST") {
                throw e;
            }
        }
        return dir;
    };

    // Create the parents of the path. (mkdirp isn't used because the first non-existing path is required to be known)
    var fullPath = parts.reduce(createDirectory, "");

    return {
        fullPath: fullPath,
        createdPath: createdPath
    };
};

/**
 * Finds a package installer component that handles the given type of package.
 *
 * @param {Component} that The gpii.iod instance.
 * @param {String} packageType The package type identifier.
 * @return {String} The grade name of the package installer.
 */
gpii.iod.getInstaller = function (that, packageType) {
    var packageInstallers = fluid.queryIoCSelector(that, "gpii.iod.packageInstaller");

    var installerComponent = fluid.find(packageInstallers, function (installer) {
        var packageTypes = fluid.makeArray(installer.options.packageTypes);
        return packageTypes.indexOf(packageType) >= 0
            ? installer
            : undefined;
    });

    return installerComponent && installerComponent.typeName;
};

/**
 * Starts the process of installing a package.
 *
 * @param {Component} that The gpii.iod instance.
 * @param {String|Object} packageRequest Package name, or object containing packageName, language, version.
 * @param {String} packageRequest.packageName Name of the package.
 * @param {String|String[]} packageRequest.language Language.
 * @return {Promise} Resolves when the installation is complete.
 */
gpii.iod.requirePackage = function (that, packageRequest) {
    if (typeof(packageRequest) === "string") {
        packageRequest = {
            packageName: packageRequest
        };
    }

    fluid.log("IoD: Requiring " + packageRequest.packageName);

    var promise = fluid.promise();

    var installation = fluid.find(that.installations, function (inst) {
        return inst.packageName === packageRequest.packageName ? inst : undefined;
    });

    if (installation) {
        // Package is already installed by IoD.
        installation.remove = false;
        that.writeInstallation(installation);
        promise.resolve(false);
    } else {
        that.initialiseInstallation(packageRequest).then(function (installation) {
            installation.installer.startInstaller().then(function () {
                installation.installed = true;
                // Store the installation info so it can still get removed if gpii restarts.
                that.writeInstallation(installation);
                promise.resolve(true);
            }, promise.reject);
        }, promise.reject);
    }

    return promise.then(function () {
        fluid.log("IoD: Installation of " + packageRequest.packageName + " complete");
    }, function (err) {
        fluid.log("IoD: Installation of " + packageRequest.packageName + " failed:", err.error || err);
    });
};

gpii.iod.initialiseInstallation = function (that, packageRequest) {
    if (typeof(packageRequest) === "string") {
        packageRequest = {
            packageName: packageRequest
        };
    }

    fluid.log("IoD: Initialising installation for " + packageRequest.packageName);

    var installation = {
        id: fluid.allocateGuid(),
        packageName: packageRequest.packageName,
        packageRequest: packageRequest,
        cleanupPaths: []
    };
    that.installations[installation.id] = installation;

    var promise = fluid.promise();

    // Get the package info.
    that.packages.getPackageInfo(packageRequest).then(function (packageInfo) {
        // Create the installer instance.
        installation.packageInfo = packageInfo;
        var installerGrade = that.getInstaller(packageInfo.packageType);
        if (installerGrade) {
            // Load the installer.
            that.events.onInstallerLoad.fire(installerGrade, installation.id);
            promise.resolve(installation);
        } else {
            promise.reject({
                isError: true,
                error: "Unable to find an installer for package type " + packageInfo.packageType
            });
        }
    }, promise.reject);

    return promise;
};

/**
 * No longer require a package. This will cause the package to be uninstalled in a short-time if there is no active
 * session.
 *
 * @param {Component} that The gpii.iod instance.
 * @param {String} packageName The name of the package to no longer require.
 * @return {Promise} Resolves immediately with a boolean indicating if the package was installed, and will be removed.
 */
gpii.iod.unrequirePackage = function (that, packageName) {

    var installation = fluid.find(that.installations, function (inst) {
        return inst.packageName === packageName ? inst : undefined;
    });

    if (installation) {
        installation.remove = true;
        that.writeInstallation(installation);
    }

    var promise = fluid.promise();
    promise.resolve(!!installation);
    return promise;
};

/**
 * Called by onSessionStop to uninstall the packages that are no longer required. The removal will be performed after
 * a short time if there is no active session, to avoid giving the computer too much to do while it's in use.
 *
 * @param {Component} that The gpii.iod instance.
 * @param {Number} wait Number of seconds to wait until uninstalling (default: 30).
 */
gpii.iod.uninitialiseInstallation = function (that, wait) {

    var uninstall = function () {
        var inSession = false;// that.model.logonChange.inProgress && that.model.logonChange.type !== "login";
        if (!inSession) {
            var installation = fluid.find(that.installations, function (inst) {
                return inst.remove && !inst.removed ? inst : undefined;
            });

            if (installation && !installation.uninstalling) {
                installation.uninstalling = true;
                that.uninstallPackage(installation).then(uninstall, uninstall);
            }
        }
    };

    if (wait === 0) {
        uninstall();
    }  else {
        setTimeout(uninstall, (wait || 30) * 1000);
    }
};

/**
 * Uninstall a package.
 *
 * @param {Component} that The gpii.iod instance.
 * @param {Installation|String} installation The installation state, or installation ID.
 * @return {Promise} Resolves when the package is removed.
 */
gpii.iod.uninstallPackage = function (that, installation) {
    var packageName;
    if (typeof(installation) === "string") {
        packageName = installation;
        installation = fluid.find(that.installations, function (inst) {
            return (inst.packageName === packageName) ? inst : undefined;
        });
    } else {
        packageName = installation.packageName;
    }

    var initPromise;
    if (installation && installation.installer) {
        initPromise = fluid.toPromise(installation);
    } else {
        initPromise = that.initialiseInstallation(installation);
    }

    var promiseTogo = fluid.promise();
    initPromise.then(function (installation) {
        var result = installation.installer.uninstallPackage();
        fluid.promise.follow(result, promiseTogo);
    });


    return promiseTogo.then(function () {
        fluid.log("IoD: Uninstallation of " + packageName + " complete");
        installation.remove = false;
        installation.removed = true;
        that.writeInstallation(installation);
        delete that.installations[installation.id];

    }, function (err) {
        fluid.log("IoD: Uninstallation of " + packageName + " failed:", err.error || err);
        // Remove it from the list so it's uninstalled again, but the file is kept so it tries again upon restart.
        that.writeInstallation(installation);
        delete that.installations[installation.id];
    });
};

/**
 * Discovers the IoD server.
 *
 * @param {Component} that The gpii.iod instance.
 */
gpii.iod.discoverServer = function (that) {

    var addr = process.env.GPII_IOD_ENDPOINT || that.options.endpoint;

    if (addr === "auto") {
        var bonjour = that.bonjourInstance || (that.bonjourInstance = require("bonjour")());
        if (bonjour) {
            var browser = bonjour.find({type: "gpii-iod"});
            browser.on("up", function (service) {
                fluid.log("IoD: Service up: " + service.fqdn);
                if (that.endpoint) {
                    that.events.onServiceLost.fire(that.endpoint);
                }
                var endpoint = service.txt.url || ("https://" + service.host + ":" + service.port);
                gpii.iod.checkService(endpoint).then(that.events.onServiceFound.fire);
            });

            browser.on("down", function (service) {
                if (that.endpoint && that.endpointService === service.fqdn) {
                    fluid.log("IoD: Service down: " + service.fqdn);
                    var oldEndpoint = service.txt.url || ("https://" + service.host + ":" + service.port);
                    if (oldEndpoint === that.endpoint) {
                        that.events.onServiceLost.fire(that.endpoint);
                    }
                }
            });

            // After a timeout use the default endpoint (if configured)
            if (that.options.defaultEndpoint) {
                setTimeout(function () {
                    if (!that.endpoint) {
                        fluid.log("IoD: No endpoint detected, trying " + that.options.defaultEndpoint);
                        gpii.iod.checkService(that.options.defaultEndpoint).then(that.events.onServiceFound.fire);
                    }
                }, 5000);
            }
        }
    } else if (addr) {
        gpii.iod.checkService(addr).then(that.events.onServiceFound.fire);
    }
};

/**
 * Check if an endpoint is listening for connections.
 *
 * @param {String} endpoint The service end point URI
 * @return {Promise} Resolves
 */
gpii.iod.checkService = function (endpoint) {
    var promise = fluid.promise();
    request(endpoint, function (error, response) {
        if (response) {
            promise.resolve(endpoint);
        } else {
            fluid.log("IoD: Unable to connect to endpoint " + endpoint);
            promise.reject(error);
        }
    });
    return promise;
};

/**
 * Invoked when the service endpoint is down.
 *
 * @param {Component} that The gpii.iod instance.
 * @param {String} endpoint The endpoint address.
 */
gpii.iod.serviceLost = function (that, endpoint) {
    fluid.log("IoD: Endpoint lost: " + endpoint);
    that.endpoint = null;
};

/**
 * Invoked when a service endpoint is up.
 *
 * @param {Component} that The gpii.iod instance.
 * @param {String} endpoint The endpoint address.
 */
gpii.iod.serviceFound = function (that, endpoint) {
    fluid.log("IoD: Endpoint found: " + endpoint);
    that.endpoint = endpoint;
};
