/*
 * Install on Demand.
 *
 * Copyright 2018 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion");

var path = require("path"),
    os = require("os"),
    fs = require("fs"),
    request = require("request"),
    glob = require("glob");

var gpii = fluid.registerNamespace("gpii");
fluid.registerNamespace("gpii.iod");

/**
 * Installation state.
 * @typedef {Object} Installation
 * @property {id} - Installation ID
 * @property {PackageData} packageData - Package data.
 * @property {string} packageName - packageData.name
 * @property {Component} installer - The gpii.iod.installer instance.
 * @property {boolean} failed - true if the installation had failed.
 * @property {string} tmpDir - Temporary working directory.
 * @property {string} installerFile - Path to the downloaded package file.
 * @property {string[]} cleanupPaths - The directories to remove during cleanup.
 *
 */

fluid.defaults("gpii.iod", {
    gradeNames: ["fluid.component", "fluid.modelComponent"],
    components: {
        packages: {
            type: "gpii.iod.packages",
            options: {
                events: {
                    "onServerFound": "{gpii.iod}.events.onServerFound"
                }
            }
        }
    },
    dynamicComponents: {
        installers: {
            createOnEvent: "onInstallerLoad",
            type: "{arguments}.0",
            options: {
                installation: "{arguments}.1"
            }
        }
    },
    events: {
        onServerFound: null, // [ endpoint address ]
        onInstallerLoad: null // [ packageInstaller grade name, installation ]
    },
    listeners: {
        "onCreate.discoverServer": "{that}.discoverServer",
        "onCreate.readInstallations": "{that}.readInstallations",
        "onServerFound.setEndpoint": {
            funcName: "fluid.set",
            args: [ "{that}", "endpoint", "{arguments}.0"]
        },
        "onServerFound.autoInstall": {
            funcName: "gpii.iod.autoInstall",
            args: ["{that}", "{that}.options.config.autoInstall"]
        }
    },
    invokers: {
        discoverServer: {
            funcName: "gpii.iod.discoverServer",
            args: ["{that}"]
        },
        requirePackage: {
            funcName: "gpii.iod.requirePackage",
            args: ["{that}", "{arguments}.0"]
        },
        initialiseInstallation: {
            funcName: "gpii.iod.initialiseInstallation",
            args: ["{that}", "{arguments}.0"]
        },
        getWorkingPath: {
            funcName: "gpii.iod.getWorkingPath",
            args: ["{arguments}.0"]
        },
        readInstallations: {
            funcName: "gpii.iod.readInstallations",
            args: ["{that}", "{gpii.journal}.settingsDir.gpiiSettingsDir" ]
        },
        writeInstallation: {
            funcName: "gpii.iod.writeInstallation",
            args: ["{that}", "{gpii.journal}.settingsDir.gpiiSettingsDir", "{arguments}.0"]
        },
        unrequirePackage: {
            funcName: "gpii.iod.unrequirePackage",
            args: ["{that}", "{arguments}.0"]
        },
        autoRemove: {
            funcName: "gpii.iod.autoRemove",
            args: ["{that}", "{arguments}.0"]
        },
        uninstallPackage: {
            funcName: "gpii.iod.uninstallPackage",
            args: ["{that}", "{arguments}.0"]
        }
    },

    config: {
        // The IoD server address
        endpoint: undefined,
        // Map of recognised keys that sign the packages.
        allowedKeys: {},
        // Packages to install on startup
        autoInstall: []
    },
    // Map of installer type -> grade name, for each type of installer.
    installerGrades: {},

    // Milliseconds to wait after key-out (or start up) before uninstalling any un-required packages
    autoRemoveDelay: 20000,

    members: {
        installations: {}
    }
});

fluid.defaults("gpii.iodLifeCycleManager", {
    gradeNames: ["fluid.component"],
    listeners: {
        "{lifecycleManager}.events.onSessionStop": {
            func: "{that}.autoRemove",
            args: [false]
        }
    },

    model: {
        logonChange: "{lifecycleManager}.model.logonChange"
    }

});

/**
 * Reads the stored installations from a previous instance. Installations will be kept when an uninstall fails, or if
 * GPII was closed without keying out.
 * All installed packages from the previous instance will be set for removal.
 *
 * @param {Component} that The gpii.iod instance.
 * @param {String} directory The directory containing the stored installation info.
 * @return {Promise} Resolves when complete.
 */
gpii.iod.readInstallations = function (that, directory) {
    var promise = fluid.promise();
    var needRemove = false;

    glob(path.join(directory, "iod-installation.*.json"), function (err, files) {
        if (err) {
            promise.reject({
                isError: true,
                message: "Unable to read previous installations",
                error: err
            });
        } else {
            fluid.each(files, function (file) {
                try {
                    var content = fs.readFileSync(file);
                    var installation = JSON.parse(content);
                    if (installation && installation.id) {
                        fluid.log("IoD: Existing installation file '" + file + "': ", installation);
                        installation.required = false;
                        installation.uninstalling = false;
                        needRemove = needRemove || !installation.required;
                        that.installations[installation.id] = installation;
                    }
                } catch (e) {
                    fluid.log("IoD: Error reading stored installation file '" + file + "': ", e);
                }
            });
            process.nextTick(promise.resolve);
        }
    });

    promise.then(function () {
        if (needRemove) {
            // Loaded some uninstalled installation.
            that.autoRemove();
        }
    });

    return promise;
};

/**
 * Writes information about an installation so it can be uninstalled at a later time.
 * If the installation has been removed, then the file will be deleted.
 *
 * @param {Component} that The gpii.iod instance.
 * @param {String} directory The directory containing the stored installation info.
 * @param {Installation} installation The installation state.
 * @return {String} The file that the installation data was written to.
 */
gpii.iod.writeInstallation = function (that, directory, installation) {
    var filename = path.join(directory, "iod-installation." + installation.id + ".json");

    if (installation.removed) {
        try {
            fs.unlinkSync(filename);
        } catch (e) {
            // ignore
        }
    } else {
        // Don't write the installer component.
        var out = Object.assign({}, installation);
        delete out.installer;
        var content = JSON.stringify(out);
        fs.writeFileSync(filename, content);
    }
    return filename;
};

/**
 * Create a directory where packages are temporarily stored.
 *
 * @param {String} packageName Name of the package for which the directory is being created.
 * @return {Object} Contains the full path (fullPath), and the first path that was created (createdPath), for cleanup
 */
gpii.iod.getWorkingPath = function (packageName) {
    var createdPath = null;

    var parts = [
        os.tmpdir(),
        "gpii-iod",
        packageName && packageName.replace(/[^-a-z0-9]/, "_"),
        Math.random().toString(36)
    ];

    // Create a new directory
    var createDirectory = function (parent, child) {
        var dir = path.join(parent, child);
        try {
            fs.mkdirSync(dir);
            if (!createdPath) {
                createdPath = dir;
            }
        } catch (e) {
            if (e.code !== "EEXIST") {
                throw e;
            }
        }
        return dir;
    };

    // Create the parents of the path. (mkdirp isn't used because the first non-existing path is required to be known)
    var fullPath = parts.reduce(createDirectory, "");

    return {
        fullPath: fullPath,
        createdPath: createdPath
    };
};

/**
 * Starts the process of installing a package.
 *
 * @param {Component} that The gpii.iod instance.
 * @param {String|Object} packageRequest Package name, or object containing packageName, language, version.
 * @param {String} packageRequest.packageName Name of the package.
 * @param {String|String[]} packageRequest.language Language.
 * @return {Promise} Resolves with true when the installation is complete, or with false if the package was already
 *  installed.
 */
gpii.iod.requirePackage = function (that, packageRequest) {
    if (typeof(packageRequest) === "string") {
        packageRequest = {
            packageName: packageRequest
        };
    }

    fluid.log("IoD: Requiring " + packageRequest.packageName);

    var promise = fluid.promise();

    that.packages.getPackageData(packageRequest).then(function (packageData) {
        var isInstalled = that.packages.checkInstalled(packageData);
        if (isInstalled) {
            promise.resolve(false);
        } else {
            that.initialiseInstallation(packageData).then(function (installation) {
                installation.required = true;
                if (installation.installed) {
                    promise.resolve(false);
                } else {
                    installation.installer.startInstaller().then(function () {
                        installation.installed = true;
                        installation.gpiiInstalled = true;
                        // Store the installation info so it can still get removed if gpii restarts.
                        that.writeInstallation(installation);
                        promise.resolve(true);
                    }, promise.reject);
                }

                // Destroy the installer
                var destroy = function () {
                    if (installation.installer) {
                        installation.installer.destroy();
                    }
                    delete installation.installer;
                };
                promise.then(destroy, destroy);

            }, promise.reject);
        }
    }, promise.reject);

    return promise.then(function () {
        fluid.log("IoD: Installation of " + packageRequest.packageName + " complete");
    }, function (err) {
        fluid.log("IoD: Installation of " + packageRequest.packageName + " failed:", err.error || err);
    });
};

/**
 * Creates the installer component for the given package.
 * @param {Component} that The gpii.iod instance.
 * @param {PackageData} packageData The package data.
 * @return {Promise} Resolves with a gpii.iod.installer instance.
 */
gpii.iod.initialiseInstallation = function (that, packageData) {
    fluid.log("IoD: Initialising installation for " + packageData.name);

    // See if it's already been loaded
    var installation = fluid.find(that.installations, function (inst) {
        return inst.packageName === packageData.name ? inst : undefined;
    });

    if (!installation) {
        installation = {
            id: fluid.allocateGuid(),
            packageName: packageData.name,
            cleanupPaths: []
        };
    }

    that.installations[installation.id] = installation;

    var promise = fluid.promise();

    // Create the installer instance.
    installation.packageData = packageData;
    var installerGrade = that.options.installerGrades[packageData.packageType];
    if (installerGrade) {
        // Load the installer.
        that.events.onInstallerLoad.fire(installerGrade, installation);
        promise.resolve(installation);
    } else {
        promise.reject({
            isError: true,
            error: "Unable to find an installer for package type " + packageData.packageType
        });
    }

    return promise;
};

/**
 * No longer require a package. This will cause the package to be uninstalled in a short-time if there is no active
 * session.
 *
 * @param {Component} that The gpii.iod instance.
 * @param {String} packageName The name of the package to no longer require.
 * @return {Promise} Resolves immediately with a boolean indicating if the package was installed, and will be removed.
 */
gpii.iod.unrequirePackage = function (that, packageName) {

    var installation = fluid.find(that.installations, function (inst) {
        return inst.packageName === packageName ? inst : undefined;
    });

    if (installation) {
        installation.required = false;
        that.writeInstallation(installation);
    }

    var promise = fluid.promise();
    promise.resolve(!!installation);
    return promise;
};

/**
 * Called by onSessionStop to uninstall the packages that are no longer required. The removal will be performed after
 * a short time if there is no active session, to avoid giving the computer too much to do while it's in use.
 *
 * @param {Component} that The gpii.iod instance.
 * @param {Boolean} immediate Uninstall immediately.
 */
gpii.iod.autoRemove = function (that, immediate) {

    var uninstall = function () {
        var inSession = false;// that.model.logonChange.inProgress && that.model.logonChange.type !== "login";
        if (!inSession) {
            // Get the first installation
            var installation = fluid.find(that.installations, function (inst) {
                return (!inst.required && !inst.removed &&
                    (!inst.packageData || inst.packageData.uninstallTime !== "never"))
                    ? inst
                    : undefined;
            });

            if (installation && !installation.uninstalling && installation.gpiiInstalled) {
                var autoInstalled = Array.isArray(that.options.config.autoInstall)
                    && that.options.config.autoInstall.indexOf(installation.packageData.name) > -1;
                if (!autoInstalled) {
                    installation.uninstalling = true;
                    that.uninstallPackage(installation).then(uninstall, uninstall);
                }
            }
        }
    };

    if (immediate) {
        uninstall();
    }  else {
        setTimeout(uninstall, that.options.autoRemoveDelay);
    }
};

/**
 * Uninstall a package.
 *
 * @param {Component} that The gpii.iod instance.
 * @param {Installation|String} installation The installation state, or package name.
 * @return {Promise} Resolves when the package is removed.
 */
gpii.iod.uninstallPackage = function (that, installation) {
    var packageName;
    if (typeof(installation) === "string") {
        packageName = installation;
        installation = fluid.find(that.installations, function (inst) {
            return (inst.packageName === packageName) ? inst : undefined;
        });
    } else {
        packageName = installation.packageName;
    }

    if (!installation.gpiiInstalled) {
        return fluid.promise().reject({
            isError: true,
            message: "Not uninstalling package '" + packageName + "': Installed externally"
        });
    }


    var initPromise;
    if (installation && installation.installer) {
        initPromise = fluid.toPromise(installation);
    } else {
        initPromise = that.initialiseInstallation(installation.packageData);
    }

    var promiseTogo = fluid.promise();
    initPromise.then(function (installation) {
        var result = installation.installer.startUninstaller();
        fluid.promise.follow(result, promiseTogo);
    });


    return promiseTogo.then(function () {
        fluid.log("IoD: Uninstallation of " + packageName + " complete");
        installation.required = false;
        installation.removed = true;
        that.writeInstallation(installation);
        delete that.installations[installation.id];

    }, function (err) {
        fluid.log("IoD: Uninstallation of " + packageName + " failed:", (err && err.error) || err);
        // Remove it from the list so it's uninstalled again, but the file is kept so it tries again upon restart.
        that.writeInstallation(installation);
        delete that.installations[installation.id];
    });
};

/**
 * Discovers the IoD server.
 *
 * @param {Component} that The gpii.iod instance.
 */
gpii.iod.discoverServer = function (that) {
    var addr = process.env.GPII_IOD_ENDPOINT || that.options.config.endpoint;
    if (addr) {
        gpii.iod.checkService(addr).then(that.events.onServerFound.fire);
    }
};

/**
 * Check if an endpoint is listening for connections.
 *
 * @param {String} endpoint The service end point URI
 * @return {Promise} Resolves with the endpoint address, rejects if it can't be connected to.
 */
gpii.iod.checkService = function (endpoint) {
    var promise = fluid.promise();

    request(endpoint, function (error, response) {
        if (response) {
            fluid.log("IoD: Endpoint found: " + endpoint);
            promise.resolve(endpoint);
        } else {
            fluid.log("IoD: Unable to connect to endpoint " + endpoint + ": ", error);
            promise.reject(error);
        }
    });
    return promise;
};

/**
 * Installs the packages mentioned in the site config.
 *
 * @param {Component} that The gpii.iod instance.
 * @param {Array<String>} packages The array of package names to install.
 */
gpii.iod.autoInstall = function (that, packages) {
    var next = function () {
        gpii.iod.autoInstall(that, packages.splice(1));
    };
    if (packages && packages.length > 0) {
        setTimeout(function () {
            that.requirePackage(packages[0]).then(next, next);
        }, 1000);
    }
};
