/*
 * Install on Demand.
 *
 * Copyright 2018 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion");

var path = require("path"),
    os = require("os"),
    fs = require("fs"),
    request = require("request"),
    url = require("url"),
    glob = require("glob");

var gpii = fluid.registerNamespace("gpii");
fluid.registerNamespace("gpii.iod");

/**
 * Installation state.
 * @typedef {Object} Installation
 * @property {id} - Installation ID
 * @property {PackageData} packageData - Package data.
 * @property {String} packageName - packageData.name
 * @property {Component} installer - The gpii.iod.installer instance.
 * @property {Boolean} failed - true if the installation had failed.
 * @property {String} tmpDir - Temporary working directory.
 * @property {String} installerFile - Path to the downloaded package file.
 * @property {String} installerFileHash - The hash of the downloaded installer.
 * @property {String[]} cleanupPaths - The directories to remove during cleanup.
 *
 */

fluid.defaults("gpii.iod", {
    gradeNames: ["fluid.component", "fluid.modelComponent", "fluid.contextAware"],

    contextAwareness: {
        platform: {
            checks: {
                windows: {
                    contextValue: "{gpii.contexts.windows}",
                    gradeNames: ["gpii.iod.windows"]
                }
            }
        }
    },
    components: {
        packages: {
            type: "gpii.iod.packages",
            options: {
                events: {
                    "onServerFound": "{gpii.iod}.events.onServerFound",
                    "onLocalPackagesFound": "{gpii.iod}.events.onLocalPackagesFound"
                },
                // Map of recognised keys that sign the packages.
                trustedKeys: "{gpii.iod}.options.config.trustedKeys"
            }
        }
    },
    dynamicComponents: {
        installers: {
            createOnEvent: "onInstallerLoad",
            type: "{arguments}.0",
            options: {
                installationID: "{arguments}.1"
            }
        }
    },
    events: {
        onServerFound: null, // [ endpoint address ]
        onLocalPackagesFound: null, // [ directory ]
        onInstallerLoad: null // [ packageInstaller grade name, installation ]
    },
    listeners: {
        "onCreate.configuredPackageSources": {
            func: "{that}.discoverPackageSources",
            args: [ "{that}.options.config.packageSources", false ]
        },
        "onCreate.localPackageSources": {
            priority: "after:configuredPackageSources",
            func: "{that}.discoverPackageSources",
            args: [ "@expand:{that}.getMountedVolumes()", true ]
        },
        "onCreate.readInstallations": "{that}.readInstallations",
        "onServerFound.autoInstall": {
            funcName: "gpii.iod.autoInstall",
            args: ["{that}", "{that}.options.config.autoInstall"]
        }
    },
    invokers: {
        getMountedVolumes: "fluid.identity",
        discoverPackageSources: {
            funcName: "gpii.iod.discoverPackageSources",
            args: [
                "{that}.events.onLocalPackagesFound",
                "{that}.events.onServerFound",
                "{arguments}.0", // address(es)
                "{arguments}.1" // check before adding?
            ]
        },
        requirePackage: {
            funcName: "gpii.iod.requirePackage",
            args: ["{that}", "{arguments}.0"]
        },
        initialiseInstallation: {
            funcName: "gpii.iod.initialiseInstallation",
            args: ["{that}", "{arguments}.0"]
        },
        getWorkingPath: {
            funcName: "gpii.iod.getWorkingPath",
            args: ["{arguments}.0"]
        },
        readInstallations: {
            funcName: "gpii.iod.readInstallations",
            args: ["{that}", "{gpii.journal}.settingsDir.gpiiSettingsDir" ]
        },
        writeInstallation: {
            funcName: "gpii.iod.writeInstallation",
            args: ["{that}", "{gpii.journal}.settingsDir.gpiiSettingsDir", "{arguments}.0"]
        },
        unrequirePackage: {
            funcName: "gpii.iod.unrequirePackage",
            args: ["{that}", "{arguments}.0"]
        },
        autoRemove: {
            funcName: "gpii.iod.autoRemove",
            args: ["{that}", "{arguments}.0"]
        },
        uninstallPackage: {
            funcName: "gpii.iod.uninstallPackage",
            args: ["{that}", "{arguments}.0"]
        }
    },

    config: {
        // The IoD server address
        endpoint: undefined,
        // Map of recognised keys that sign the packages.
        trustedKeys: {},
        // Packages to install on startup
        autoInstall: []
    },
    // Map of installer type -> grade name, for each type of installer.
    installerGrades: {},

    // Milliseconds to wait after key-out (or start up) before uninstalling any un-required packages
    autoRemoveDelay: 20000,

    members: {
        installations: {}
    }
});

fluid.defaults("gpii.iodLifeCycleManager", {
    gradeNames: ["fluid.component"],
    listeners: {
        "{lifecycleManager}.events.onSessionStop": {
            func: "{that}.autoRemove",
            args: [false]
        },
        "{userListeners}.usb.events.onMount": {
            func: "{that}.discoverPackageSources",
            args: ["{arguments}.1", true]
        }
    },

    model: {
        logonChange: "{lifecycleManager}.model.logonChange"
    }

});

/**
 * Reads the stored installations from a previous instance. Installations will be kept when an uninstall fails, or if
 * GPII was closed without keying out.
 * All installed packages from the previous instance will be set for removal.
 *
 * @param {Component} that The gpii.iod instance.
 * @param {String} directory The directory containing the stored installation info.
 * @return {Promise} Resolves when complete.
 */
gpii.iod.readInstallations = function (that, directory) {
    var promise = fluid.promise();
    var needRemove = false;

    glob(path.join(directory, "iod-installation.*.json"), function (err, files) {
        if (err) {
            promise.reject({
                isError: true,
                message: "Unable to read previous installations",
                error: err
            });
        } else {
            fluid.each(files, function (file) {
                try {
                    var content = fs.readFileSync(file);
                    var installation = JSON.parse(content);
                    if (installation && installation.id) {
                        fluid.log("IoD: Existing installation file '" + file + "': ", installation);
                        installation.required = false;
                        installation.uninstalling = false;
                        needRemove = needRemove || !installation.required;
                        that.installations[installation.id] = installation;
                    }
                } catch (e) {
                    fluid.log("IoD: Error reading stored installation file '" + file + "': ", e);
                }
            });
            process.nextTick(promise.resolve);
        }
    });

    promise.then(function () {
        if (needRemove) {
            // Loaded some uninstalled installation.
            that.autoRemove();
        }
    });

    return promise;
};

/**
 * Writes information about an installation so it can be uninstalled at a later time.
 * If the installation has been removed, then the file will be deleted.
 *
 * @param {Component} that The gpii.iod instance.
 * @param {String} directory The directory containing the stored installation info.
 * @param {Installation} installation The installation state.
 * @return {String} The file that the installation data was written to.
 */
gpii.iod.writeInstallation = function (that, directory, installation) {
    var filename = path.join(directory, "iod-installation." + installation.id + ".json");

    if (installation.removed) {
        try {
            fs.unlinkSync(filename);
        } catch (e) {
            // ignore
        }
    } else {
        // Don't write the installer component.
        var out = Object.assign({}, installation);
        delete out.installer;
        var content = JSON.stringify(out);
        fs.writeFileSync(filename, content);
    }
    return filename;
};

/**
 * Create a directory where packages are temporarily stored.
 *
 * @param {String} packageName Name of the package for which the directory is being created.
 * @return {Object} Contains the full path (fullPath), and the first path that was created (createdPath), for cleanup
 */
gpii.iod.getWorkingPath = function (packageName) {
    var createdPath = null;

    var parts = [
        os.tmpdir(),
        "gpii-iod",
        packageName && packageName.replace(/[^-a-z0-9]/, "_"),
        Math.random().toString(36)
    ];

    // Create a new directory
    var createDirectory = function (parent, child) {
        var dir = path.join(parent, child);
        try {
            fs.mkdirSync(dir);
            if (!createdPath) {
                createdPath = dir;
            }
        } catch (e) {
            if (e.code !== "EEXIST") {
                throw e;
            }
        }
        return dir;
    };

    // Create the parents of the path. (mkdirp isn't used because the first non-existing path is required to be known)
    var fullPath = parts.reduce(createDirectory, "");

    return {
        fullPath: fullPath,
        createdPath: createdPath
    };
};

/**
 * Starts the process of installing a package.
 *
 * @param {Component} that The gpii.iod instance.
 * @param {String|Object} packageRequest Package name, or object containing packageName, language, version.
 * @param {String} packageRequest.packageName Name of the package.
 * @param {String|String[]} packageRequest.language Language.
 * @return {Promise} Resolves with true when the installation is complete, or with false if the package was already
 *  installed.
 */
gpii.iod.requirePackage = function (that, packageRequest) {
    if (typeof(packageRequest) === "string") {
        packageRequest = {
            packageName: packageRequest
        };
    }

    fluid.log("IoD: Requiring " + packageRequest.packageName);

    var promise = fluid.promise();

    that.packages.getPackageData(packageRequest).then(function (packageData) {
        var isInstalled = that.packages.checkInstalled(packageData);
        if (isInstalled) {
            promise.resolve(false);
        } else {
            that.initialiseInstallation(packageData).then(function (installation) {
                installation.required = true;
                if (installation.installed) {
                    promise.resolve(false);
                } else {
                    installation.installer.startInstaller().then(function () {
                        installation.installed = true;
                        installation.gpiiInstalled = true;
                        // Store the installation info so it can still get removed if gpii restarts.
                        that.writeInstallation(installation);
                        promise.resolve(true);
                    }, promise.reject);
                }

                // Destroy the installer
                var destroy = function () {
                    if (installation.installer) {
                        installation.installer.destroy();
                    }
                    delete installation.installer;
                };
                promise.then(destroy, destroy);

            }, promise.reject);
        }
    }, promise.reject);

    return promise.then(function () {
        fluid.log("IoD: Installation of " + packageRequest.packageName + " complete");
    }, function (err) {
        fluid.log("IoD: Installation of " + packageRequest.packageName + " failed:", err.error || err);
    });
};

/**
 * Creates the installer component for the given package.
 * @param {Component} that The gpii.iod instance.
 * @param {PackageData} packageData The package data.
 * @return {Promise} Resolves with a gpii.iod.installer instance.
 */
gpii.iod.initialiseInstallation = function (that, packageData) {
    fluid.log("IoD: Initialising installation for " + packageData.name);

    // See if it's already been loaded
    var installation = fluid.find(that.installations, function (inst) {
        return inst.packageName === packageData.name ? inst : undefined;
    });

    if (!installation) {
        installation = {
            id: fluid.allocateGuid(),
            packageName: packageData.name,
            cleanupPaths: []
        };
    }

    that.installations[installation.id] = installation;

    var promise = fluid.promise();

    // Create the installer instance.
    installation.packageData = packageData;
    var installerGrade = that.options.installerGrades[packageData.packageType];
    if (installerGrade) {
        // Load the installer.
        that.events.onInstallerLoad.fire(installerGrade, installation.id);
        promise.resolve(installation);
    } else {
        promise.reject({
            isError: true,
            error: "Unable to find an installer for package type " + packageData.packageType
        });
    }

    return promise;
};

/**
 * No longer require a package. This will cause the package to be uninstalled in a short-time if there is no active
 * session.
 *
 * @param {Component} that The gpii.iod instance.
 * @param {String} packageName The name of the package to no longer require.
 * @return {Promise} Resolves immediately with a boolean indicating if the package was installed, and will be removed.
 */
gpii.iod.unrequirePackage = function (that, packageName) {

    var installation = fluid.find(that.installations, function (inst) {
        return inst.packageName === packageName ? inst : undefined;
    });

    if (installation) {
        installation.required = false;
        that.writeInstallation(installation);
    }

    var promise = fluid.promise();
    promise.resolve(!!installation);
    return promise;
};

/**
 * Called by onSessionStop to uninstall the packages that are no longer required. The removal will be performed after
 * a short time if there is no active session, to avoid giving the computer too much to do while it's in use.
 *
 * @param {Component} that The gpii.iod instance.
 * @param {Boolean} immediate Uninstall immediately.
 */
gpii.iod.autoRemove = function (that, immediate) {

    var uninstall = function () {
        var inSession = false;// that.model.logonChange.inProgress && that.model.logonChange.type !== "login";
        if (!inSession) {
            // Get the first installation
            var installation = fluid.find(that.installations, function (inst) {
                return (!inst.required && !inst.removed &&
                    (!inst.packageData || inst.packageData.uninstallTime !== "never"))
                    ? inst
                    : undefined;
            });

            if (installation && !installation.uninstalling && installation.gpiiInstalled) {
                var autoInstalled = Array.isArray(that.options.config.autoInstall)
                    && that.options.config.autoInstall.indexOf(installation.packageData.name) > -1;
                if (!autoInstalled) {
                    installation.uninstalling = true;
                    that.uninstallPackage(installation).then(uninstall, uninstall);
                }
            }
        }
    };

    if (immediate) {
        uninstall();
    }  else {
        setTimeout(uninstall, that.options.autoRemoveDelay);
    }
};

/**
 * Uninstall a package.
 *
 * @param {Component} that The gpii.iod instance.
 * @param {Installation|String} installation The installation state, or package name.
 * @return {Promise} Resolves when the package is removed.
 */
gpii.iod.uninstallPackage = function (that, installation) {
    var packageName;
    if (typeof(installation) === "string") {
        packageName = installation;
        installation = fluid.find(that.installations, function (inst) {
            return (inst.packageName === packageName) ? inst : undefined;
        });
    } else {
        packageName = installation.packageName;
    }

    if (!installation.gpiiInstalled) {
        return fluid.promise().reject({
            isError: true,
            message: "Not uninstalling package '" + packageName + "': Installed externally"
        });
    }


    var initPromise;
    if (installation && installation.installer) {
        initPromise = fluid.toPromise(installation);
    } else {
        initPromise = that.initialiseInstallation(installation.packageData);
    }

    var promiseTogo = fluid.promise();
    initPromise.then(function (installation) {
        var result = installation.installer.startUninstaller();
        fluid.promise.follow(result, promiseTogo);
    });


    return promiseTogo.then(function () {
        fluid.log("IoD: Uninstallation of " + packageName + " complete");
        installation.required = false;
        installation.removed = true;
        that.writeInstallation(installation);
        delete that.installations[installation.id];

    }, function (err) {
        fluid.log("IoD: Uninstallation of " + packageName + " failed:", (err && err.error) || err);
        // Remove it from the list so it's uninstalled again, but the file is kept so it tries again upon restart.
        that.writeInstallation(installation);
        delete that.installations[installation.id];
    });
};

/**
 * Adds the given packages sources, after optionally checking if it is valid.
 *
 * @param {Event} onLocalPackagesFound The event to fire when a local package source is to be added.
 * @param {Event} onServerFound The event to fire when a remote package source is to be added.
 * @param {Array<String>|String} addresses The package source address(es) to add.
 * @param {Boolean} check True to check if the source is usable before adding it.
 * @return {Promise} Resolves when complete.
 */
gpii.iod.discoverPackageSources = function (onLocalPackagesFound, onServerFound, addresses, check) {
    var promises = [];

    fluid.each(fluid.makeArray(addresses), function (address) {
        var localPath;
        if (address.includes("://")) {
            try {
                localPath = url.fileURLToPath(address);
            } catch (e) {
                // ignore
            }
        } else {
            localPath = address;
        }


        var foundPromise;
        if (localPath) {
            if (check) {
                var dataFile = path.join(localPath, ".morphic-packages");
                foundPromise = fluid.promise();
                fs.access(dataFile, function (err) {
                    if (err) {
                        fluid.log("IoD: Not using local package source '" + localPath + "': ", err.message);
                        foundPromise.reject();
                    } else {
                        fluid.log("IoD: Using local package source '" + localPath + "':");
                        foundPromise.resolve(localPath);
                    }
                });
            } else {
                foundPromise = fluid.toPromise(localPath);
            }

            foundPromise.then(onLocalPackagesFound.fire);
        } else {
            foundPromise = check ? gpii.iod.checkService(address) : fluid.toPromise(address);
            foundPromise.then(onServerFound.fire);
        }

        // Ignore any rejections
        var p = fluid.promise();
        foundPromise.then(p.resolve, function () {
            p.resolve();
        });
        promises.push(p);
    });

    return fluid.promise.sequence(promises);
};

/**
 * Check if an endpoint is listening for connections.
 *
 * @param {String} endpoint The service end point URI
 * @return {Promise} Resolves with the endpoint address, rejects if it can't be connected to.
 */
gpii.iod.checkService = function (endpoint) {
    var promise = fluid.promise();

    request(endpoint, function (error, response) {
        if (response) {
            fluid.log("IoD: Endpoint found: " + endpoint);
            promise.resolve(endpoint);
        } else {
            fluid.log("IoD: Unable to connect to endpoint " + endpoint + ": ", error);
            promise.reject(error);
        }
    });
    return promise;
};

/**
 * Installs the packages mentioned in the site config.
 *
 * @param {Component} that The gpii.iod instance.
 * @param {Array<String>} packages The array of package names to install.
 */
gpii.iod.autoInstall = function (that, packages) {
    var next = function () {
        gpii.iod.autoInstall(that, packages.splice(1));
    };
    if (packages && packages.length > 0) {
        setTimeout(function () {
            that.requirePackage(packages[0]).then(next, next);
        }, 1000);
    }
};

// For node < 10.12.0
if (!url.pathToFileURL) {
    url.pathToFileURL = function (localPath) {
        var togo = new url.URL("file://");
        togo.pathname = path.resolve(localPath);
        return togo;
    };
}
if (!url.fileURLToPath) {
    url.fileURLToPath = function (fileUrl) {
        var u = new url.URL(fileUrl);
        var pathTogo;
        if (u.protocol === "file:") {
            pathTogo = decodeURIComponent(u.pathname);
            if (process.platform === "win32") {
                pathTogo = pathTogo.replace(/\//g, "\\");
                if (u.hostname) {
                    // UNC path
                    pathTogo = "\\\\" + u.hostname + u.pathname;
                } else if (pathTogo[2] === ":") {
                    // X:\ path
                    pathTogo = pathTogo.substr(1);
                } else {
                    throw new Error("File url has no drive or host. " + fileUrl);
                }
            }
        } else {
            throw new Error("File url must be a file: url. " + fileUrl);
        }
        return pathTogo;
    };
}
