/*
 * A readonly data source which encapsulates multiple data sources into one, where each source gets queried until one
 * of them returns a result.
 *
 * Copyright 2019 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion");

require("kettle");

var gpii = fluid.registerNamespace("gpii");
fluid.registerNamespace("gpii.iod.multiDataSource");

fluid.defaults("gpii.iod.multiDataSource", {
    gradeNames: ["kettle.dataSource"],
    readOnlyGrade: "gpii.iod.multiDataSource",

    components: {
        encoding: {
            // The root sources provide their own encoding.
            type: "kettle.dataSource.encoding.none"
        }
    },
    dynamicComponents: {
        rootDataSources: {
            createOnEvent: "onNewDataSource",
            type: "{arguments}.0",
            options: {
                priority: "{arguments}.2",
                // The "path" or "url" value for the data source.
                address: "{arguments}.1",
                listeners: {
                    "onCreate.multiDataSource": {
                        func: "{gpii.iod.multiDataSource}.addDataSource",
                        args: ["{that}"]
                    },
                    "onDestroy.removeSource": {
                        func: "{gpii.iod.multiDataSource}.removeDataSource",
                        args: ["{that}"]
                    }
                }
            }
        }
    },
    events: {
        onNewDataSource: null // component name, path, priority
    },
    members: {
        sortedDataSources: []
    },
    invokers: {
        getImpl: {
            funcName: "gpii.iod.multiDataSource.getImpl",
            args: ["{that}", "{arguments}.0", "{arguments}.1"]
        },
        addDataSource: {
            funcName: "gpii.iod.multiDataSource.addDataSource",
            args: ["{that}", "{arguments}.0"]
        },
        removeDataSource: {
            funcName: "gpii.iod.multiDataSource.removeDataSource",
            args: ["{that}", "{arguments}.0"]
        }
    }
});

/**
 * Called when a new data source is to be added.
 * @param {Component} that The gpii.iod.multiDataSource instance.
 * @param {Component} dataSource The new data source.
 */
gpii.iod.multiDataSource.addDataSource = function (that, dataSource) {
    // Insert the new one at the top of the array, so newer sources of the same priority are before the older ones.
    that.sortedDataSources.unshift(dataSource);
    dataSource.options.priority = parseInt(dataSource.options.priority);
    fluid.stableSort(that.sortedDataSources, function (a, b) {
        return a.options.priority - b.options.priority;
    });
};

/**
 * Called when an existing data source has gone.
 * @param {Component} that The gpii.iod.multiDataSource instance.
 * @param {Component} dataSource The removed data source.
 */
gpii.iod.multiDataSource.removeDataSource = function (that, dataSource) {
    var index = that.sortedDataSources.indexOf(dataSource);
    if (index === -1) {
        fluid.log("multiDataSource: removed an unknown data source");
    } else {
        that.sortedDataSources.splice(index, 1);
    }
};

/**
 * Data source getter. Attempts a get() on each root data source until the first success.
 * @param {Component} that The gpii.iod.multiDataSource instance.
 * @param {Object} options The options.
 * @param {Object} directModel The request.
 * @return {Promise} Resolves with the result, rejects with the first rejection if all sources reject.
 */
gpii.iod.multiDataSource.getImpl = function (that, options, directModel) {
    var promise = fluid.promise();
    var firstReject;

    // Copy the data source array, so it doesn't get modified while being enumerated.
    var dataSources = that.sortedDataSources.slice();

    var next = function (index) {
        var source = dataSources[index];
        if (source) {
            var result = source.get(directModel, options);
            result.then(promise.resolve, function (reason) {
                if (!firstReject) {
                    firstReject = reason;
                }
                next(index + 1);
            });
        } else {
            promise.reject(firstReject);
        }
    };

    if (dataSources.length) {
        next(0);
    } else {
        promise.reject({
            isError: true,
            message: "no root data sources"
        });
    }

    return promise;
};
