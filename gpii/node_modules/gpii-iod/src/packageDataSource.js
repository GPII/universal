/*
 * Install on Demand package data source.
 *
 * Copyright 2019 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion"),
    crypto = require("crypto");

require("kettle");

var gpii = fluid.registerNamespace("gpii");
fluid.registerNamespace("gpii.iod.packages");

fluid.defaults("gpii.iod.remotePackageDataSource", {
    gradeNames: ["kettle.dataSource.URL"],
    listeners: {
        "onRead.checkSignature": {
            funcName: "gpii.iod.checkPackageSignature"
        }
    }
});

/**
 * Verifies the packageData JSON string against the packageDataSignature, returns the response with the packageData
 * field de-serialised.
 * @param {PackageResponse} packageResponse The response from the data source.
 * @return {Promise<PackageResponse>} Resolves with the response from the data source, with de-serialised packageData.
 */
gpii.iod.checkPackageSignature = function (packageResponse) {
    var promise = fluid.promise();
    gpii.iod.verifySignedJSON(packageResponse.packageData, packageResponse.packageDataSignature).then(function (obj) {
        var result = fluid.copy(packageResponse);
        result.packageData = obj;
        promise.resolve(result);
    }, promise.reject);

    return promise;
};

/**
 * Verifies a serialised object against a signature. The base64 encoded public key is inside the object under the
 * `publicKey` field.
 *
 * @param {String} data The JSON data to verify (expects a `publicKey` field)
 * @param {String} signature The signature (base64)
 * @return {Promise} Resolves, with the de-serialised object, when complete.
 */
gpii.iod.verifySignedJSON = function (data, signature) {
    var promise = fluid.promise();

    try {
        var verified = false;
        var obj = JSON.parse(data);
        if (obj.publicKey) {
            // PEM encode the key - it's already base64 encoded, so just surround with the header and footer.
            var publicKey = "-----BEGIN PUBLIC KEY-----\n"
                + obj.publicKey.trim()
                + "\n-----END PUBLIC KEY-----\n";

            // Verify the package data with the signature.
            var verify = crypto.createVerify("RSA-SHA512");
            verify.update(data);

            verified = verify.verify({key: publicKey}, signature, "base64");
        }

        if (verified) {
            promise.resolve(obj);
        } else {
            var extra = obj.publicKey ? "" : ": JSON object did not contain a publicKey field.";
            promise.reject({
                isError: true,
                message: "Signed JSON data failed verification" + extra
            });
        }
    } catch (e) {
        promise.reject({
            isError: true,
            message: "Error while verifying signed JSON data: " + (e.message || ""),
            error: e
        });
    }

    return promise;
};
