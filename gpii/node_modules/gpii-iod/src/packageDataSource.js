/*
 * Install on Demand package data source.
 *
 * Copyright 2019 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion"),
    crypto = require("crypto"),
    fs = require("fs"),
    json5 = require("json5"),
    path = require("path"),
    url = require("url");

require("kettle");

var gpii = fluid.registerNamespace("gpii");
fluid.registerNamespace("gpii.iod.packageDataSource");

fluid.defaults("gpii.iod.packageDataSource", {
    gradeNames: ["fluid.component"],
    readOnlyGrade: "gpii.iodServer.packageDataSource",
    events: {
        onLostDataSource: null
    }
});

fluid.defaults("gpii.iod.packageDataSource.remote", {
    gradeNames: ["kettle.dataSource.URL", "gpii.iod.packageDataSource"],
    url: "@expand:gpii.iod.joinUrl({that}.options.address, {that}.options.urlPath)",
    urlPath: "/packages/%packageName",
    termMap: {
        packageName: "%packageName"
    }
});

fluid.defaults("gpii.iod.packageDataSource.local", {
    gradeNames: ["kettle.dataSource", "gpii.iod.packageDataSource"],

    components: {
        encoding: {
            type: "kettle.dataSource.encoding.none"
        }
    },
    invokers: {
        getImpl: {
            funcName: "gpii.iod.packageDataSource.getLocal",
            args: [
                "@expand:{that}.loadData()",
                //"{arguments}.0",
                "{arguments}.1",
                "{that}.options.path"
            ]
        },
        loadData: {
            funcName: "gpii.iod.packageDataSource.loadData",
            args: ["{that}", "{that}.options.path", "{that}.options.dataFile"]
        }
    },
    path: "{that}.options.address",
    dataFile: ".morphic-packages",
    members: {
        data: undefined
    }
});

/**
 * @typedef {PackageResponse} LocalPackage
 */

/**
 * Convenience function to concatenate two parts of a URL together, ensuring there's a single '/' between each part
 * (like `path.join`, but performs no normalisation and always uses slash).
 *
 * @param {String} front The first part of the URL
 * @param {String} end The final part of the URL
 * @return {String} `font` and `end` combined.
 */
gpii.iod.joinUrl = function (front, end) {
    return front.replace(/\/+$/, "") + "/" + end.replace(/^\/+/, "");
};

/**
 * Gets the package data from a local path.
 * @param {Promise} loadPromise A promise that resolves when the local package data is available.
 * @param {Object} packageRequest The package request.
 * @param {Object} directory The directory where the local packages are located.
 * @return {Promise<LocalPackage>} Resolves with the package response.
 */
gpii.iod.packageDataSource.getLocal = function (loadPromise, packageRequest, directory) {
    var promise = fluid.promise();
    loadPromise.then(function (data) {
        /** @type {LocalPackage} */
        var localPackage = fluid.copy(data[packageRequest.packageName]);
        if (localPackage) {
            var checkInstallerPromise;

            if (localPackage.installer) {
                // Get the absolute path, and create the url for it.
                var localPath = path.join(directory, localPackage.installer);
                var installerURL = url.pathToFileURL(localPath);
                if (localPackage.offset) {
                    installerURL.searchParams.set("offset", localPackage.offset);
                }
                localPackage.installer = installerURL.toString();

                // Check if the installer file exists, as it would be pointless to return a response if the package
                // can't be installed.
                checkInstallerPromise = fluid.promise();
                fs.access(localPath, function (err) {
                    if (err) {
                        checkInstallerPromise.reject({
                            isError: true,
                            message: "File for " + packageRequest.packageName + " not found",
                            localPath: localPath,
                            error: err
                        });
                    } else {
                        checkInstallerPromise.resolve();
                    }
                });
            }

            fluid.toPromise(checkInstallerPromise).then(function () {
                promise.resolve(localPackage);
            }, promise.reject);

        } else {
            promise.reject({
                message: "Package " + packageRequest.packageName + " not found"
            });
        }
    }, promise.reject);

    return promise;
};

/**
 * Loads the package data from a local file.
 * @param {Component} that The gpii.iod.packageDataSource.local instance.
 * @param {String} directory The directory where the packages are kept.
 * @param {String} file The local package data file (a child of `directory`) (".morphic-packages")
 * @return {Promise<Map<String,LocalPackage>>} Resolves with the packages from the local data file.
 */
gpii.iod.packageDataSource.loadData = function (that, directory, file) {
    var promise = fluid.promise();
    var dataFile = path.join(directory, file);

    gpii.iod.packageDataSource.checkDataFile(that, dataFile).then(function (changed) {
        if (changed || !that.data) {
            fs.readFile(dataFile, "utf8", function (err, content) {
                if (err) {
                    promise.reject({
                        isError: true,
                        message: "IoD: unable to load the data file " + dataFile + ": " + err.message,
                        error: err
                    });
                } else {
                    try {
                        that.data = json5.parse(content);
                        if (!that.data.packages) {
                            that.data.packages = {};
                        }
                        fluid.log("IoD: Loaded " + Object.keys(that.data.packages).length + " packages from " + dataFile);
                        promise.resolve(that.data.packages);
                    } catch (err) {
                        promise.reject({
                            isError: true,
                            message: "IoD: unable to parse the data file " + dataFile + ": " + err.message,
                            error: err
                        });
                    }
                }
            });
        } else {
            promise.resolve(that.data.packages);
        }
    }, function (err) {
        fluid.log("IoD: Unable to read from " + dataFile + ": ", err.message || err);
        that.destroy();
        promise.reject(err);
    });

    return promise;
};

/**
 * Checks if the data file exists, and has changed since the last time this was called.
 * @param {Component} that The gpii.iod.packageDataSource.local instance.
 * @param {String} dataFile Path to the .morphic-packages file.
 * @return {Promise<Boolean>} Resolves with a boolean indicating if the file has changed (or the first call). Rejects
 *  if the file does not exist.
 */
gpii.iod.packageDataSource.checkDataFile = function (that, dataFile) {
    var promise = fluid.promise();
    fs.stat(dataFile, function (err, stats) {
        if (err) {
            promise.reject(err);
        } else {
            var changed = stats.mtimeMs !== that.dataFileTime;
            if (changed && that.dataFileTime) {
                fluid.log("IoD: local package data file has changed - reloading");
            }
            that.dataFileTime = stats.mtimeMs;
            promise.resolve(changed);
        }
    });

    return promise;
};

// fluid.defaults("gpii.iod.packageDataSource.local", {
//     gradeNames: [
//         "kettle.dataSource.file.moduleTerms", "kettle.dataSource.encoding.JSON5", "gpii.iod.packageDataSource"
//     ],
//     path: "%gpii-universal/testData/installOnDemand/%packageName.json5",
//     termMap: {
//         "packageName": "%packageName"
//     },
//     components: {
//         encoding: {
//             type: "kettle.dataSource.encoding.JSON5"
//         }
//     }
// });

/**
 * Verifies the packageData JSON string against the packageDataSignature, returns the response with the packageData
 * field de-serialised.
 * @param {PackageResponse} packageResponse The response from the data source.
 * @param {Object} trustedKeys Map of sha256 fingerprints (base64 encoded) of the public keys that are authorised.
 * @return {Promise<PackageResponse>} Resolves with the response from the data source, with de-serialised packageData.
 */
gpii.iod.checkPackageSignature = function (packageResponse, trustedKeys) {
    var promise = fluid.promise();
    gpii.iod.verifySignedJSON(packageResponse.packageData, packageResponse.packageDataSignature, trustedKeys)
        .then(function (packageData) {
            var result = fluid.copy(packageResponse);
            result.packageData = packageData;
            promise.resolve(result);
        }, promise.reject);

    return promise;
};

/**
 * Verifies a serialised object against a signature, and the public key is one of those specified.
 *
 * The base64 encoded public key is inside the object under the `publicKey` field.
 *
 * @param {String} data The JSON data to verify (expects a `publicKey` field)
 * @param {String} signature The signature (base64).
 * @param {Object} trustedKeys Map of sha256 fingerprints (base64 encoded) of the public keys that are authorised.
 *
 * @return {Promise} Resolves, with the de-serialised object, when complete. Rejects if the signature doesn't validate,
 *  or if one of the keys aren't in the given list.
 */
gpii.iod.verifySignedJSON = function (data, signature, trustedKeys) {
    var promise = fluid.promise();
    var failureMessage;
    var verified = false;

    try {
        var obj = JSON.parse(data);
        if (obj.publicKey) {
            // Get the sha256 fingerprint of the public key, and check if it's one of the allowed keys.
            var fingerprint = crypto.createHash("sha256").update(Buffer.from(obj.publicKey, "base64")).digest("base64");
            var keyName = fluid.keyForValue(trustedKeys, fingerprint);
            var authorised = keyName !== undefined;
            fluid.log("IoD: Package signing key: " + fingerprint + " - ", (keyName || "unknown"));

            if (authorised) {
                fluid.log("IoD: Package signing key name: " + keyName);
                // PEM encode the key - it's already base64 encoded, so just surround with the header and footer.
                var publicKey = "-----BEGIN PUBLIC KEY-----\n"
                    + obj.publicKey.trim()
                    + "\n-----END PUBLIC KEY-----\n";

                // Verify the package data with the signature.
                var verify = crypto.createVerify("RSA-SHA512");
                verify.update(data);

                verified = verify.verify({key: publicKey}, signature, "base64");

                if (!verified) {
                    failureMessage = "Signature could not be verified.";
                }

            } else {
                verified = false;
                failureMessage = "Signed by an unknown key.";
            }
        } else {
            verified = false;
            failureMessage = "JSON object did not contain a publicKey field.";
        }

        if (verified) {
            promise.resolve(obj);
        } else {
            promise.reject({
                isError: true,
                message: "Signed JSON data failed verification: " + failureMessage
            });
        }
    } catch (e) {
        verified = false;
        promise.reject({
            isError: true,
            message: "Error while verifying signed JSON data: " + (e.message || ""),
            error: e
        });
    }

    return promise;
};
