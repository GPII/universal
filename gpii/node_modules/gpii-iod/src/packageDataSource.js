/*
 * Install on Demand package data source.
 *
 * Copyright 2019 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion"),
    crypto = require("crypto");

require("kettle");

var gpii = fluid.registerNamespace("gpii");
fluid.registerNamespace("gpii.iod.packages");

fluid.defaults("gpii.iod.remotePackageDataSource", {
    gradeNames: ["kettle.dataSource.URL"],
    invokers: {
        "checkPackageSignature": {
            funcName: "gpii.iod.checkPackageSignature",
            args: [ "{arguments}.0", "{gpii.iod}.options.allowedKeys" ]
        }
    },
    listeners: {
        "onRead.checkSignature": {
            func: "{that}.checkPackageSignature",
            args: "{arguments}.0" // packageResponse
        }
    }
});

/**
 * Verifies the packageData JSON string against the packageDataSignature, returns the response with the packageData
 * field de-serialised.
 * @param {PackageResponse} packageResponse The response from the data source.
 * @param {Object} allowedKeys Map of sha256 fingerprints (base64 encoded) of the public keys that are authorised.
 * @return {Promise<PackageResponse>} Resolves with the response from the data source, with de-serialised packageData.
 */
gpii.iod.checkPackageSignature = function (packageResponse, allowedKeys) {
    var promise = fluid.promise();
    gpii.iod.verifySignedJSON(packageResponse.packageData, packageResponse.packageDataSignature, allowedKeys)
        .then(function (packageData) {
            var result = fluid.copy(packageResponse);
            result.packageData = packageData;
            promise.resolve(result);
        }, promise.reject);

    return promise;
};

/**
 * Verifies a serialised object against a signature, and the public key is one of those specified.
 *
 * The base64 encoded public key is inside the object under the `publicKey` field.
 *
 * @param {String} data The JSON data to verify (expects a `publicKey` field)
 * @param {String} signature The signature (base64).
 * @param {Object} allowedKeys Map of sha256 fingerprints (base64 encoded) of the public keys that are authorised.
 *
 * @return {Promise} Resolves, with the de-serialised object, when complete. Rejects if the signature doesn't validate,
 *  or if one of the keys aren't in the given list.
 */
gpii.iod.verifySignedJSON = function (data, signature, allowedKeys) {
    var promise = fluid.promise();
    var failureMessage;
    var verified = false;

    try {
        var obj = JSON.parse(data);
        if (obj.publicKey) {
            // Get the sha256 fingerprint of the public key, and check if it's one of the allowed keys.
            var fingerprint = crypto.createHash("sha256").update(Buffer.from(obj.publicKey, "base64")).digest("base64");
            var keyName = fluid.keyForValue(allowedKeys, fingerprint);
            var authorised = keyName !== undefined;

            if (authorised) {
                fluid.log("Package signing key: " + keyName);
                // PEM encode the key - it's already base64 encoded, so just surround with the header and footer.
                var publicKey = "-----BEGIN PUBLIC KEY-----\n"
                    + obj.publicKey.trim()
                    + "\n-----END PUBLIC KEY-----\n";

                // Verify the package data with the signature.
                var verify = crypto.createVerify("RSA-SHA512");
                verify.update(data);

                verified = verify.verify({key: publicKey}, signature, "base64");

                if (!verified) {
                    failureMessage = "Signature could not be verified.";
                }

            } else {
                verified = false;
                failureMessage = "Signed by an unknown key.";
            }
        } else {
            verified = false;
            failureMessage = "JSON object did not contain a publicKey field.";
        }

        if (verified) {
            promise.resolve(obj);
        } else {
            promise.reject({
                isError: true,
                message: "Signed JSON data failed verification: " + failureMessage
            });
        }
    } catch (e) {
        verified = false;
        promise.reject({
            isError: true,
            message: "Error while verifying signed JSON data: " + (e.message || ""),
            error: e
        });
    }

    return promise;
};
