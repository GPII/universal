/*
 * Abstraction of something that installs packages.
 *
 * Copyright 2018 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var path = require("path"),
    fs = require("fs"),
    request = require("request"),
    crypto = require("crypto"),
    child_process = require("child_process");

var fluid = require("infusion");
var gpii = fluid.registerNamespace("gpii");
fluid.registerNamespace("gpii.iod");

fluid.defaults("gpii.iod.packageInstaller", {
    gradeNames: ["fluid.component"],

    invokers: {
        created: {
            funcName: "gpii.iod.installerCreated",
            args: ["{that}", "{iod}"]
        },
        startInstaller: {
            funcName: "gpii.iod.startInstaller",
            args: ["{that}", "{iod}"]
        },
        startUninstaller: {
            funcName: "gpii.iod.startUninstaller",
            args: ["{that}", "{iod}"]
        },
        // Remaining invokers are part of the installation pipe-line. Each one is passed the installation and returns
        // an installation, either directly or via a promise.
        initialise: {
            funcName: "gpii.iod.initialise",
            args: ["{that}", "{iod}"]
        },
        downloadInstaller: {
            funcName: "gpii.iod.downloadInstaller",
            args: ["{that}", "{iod}"]
        },
        checkPackage: {
            funcName: "gpii.iod.checkPackage",
            args: ["{that}", "{iod}"]
        },
        prepareInstall: {
            funcName: "gpii.iod.prepareInstall",
            args: ["{that}", "{iod}"]
        },
        installPackage: "fluid.notImplemented",
        cleanup: {
            funcName: "gpii.iod.cleanup",
            args: ["{that}", "{iod}"]
        },
        startApplication: {
            funcName: "gpii.iod.startApplication",
            args: ["{that}", "{iod}"]
        },
        stopApplication: {
            funcName: "gpii.iod.stopApplication",
            args: ["{that}", "{iod}"]
        },
        uninstallPackage: "fluid.notImplemented"
    },
    events: {
        // Dummy events for the installation pipe-lines
        onInstallPackage: null,
        onRemovePackage: null
    },
    listeners: {
        "onCreate": "{that}.created",
        "onInstallPackage.initialise": {
            func: "{that}.initialise",
            priority: "first"
        },
        "onInstallPackage.download": {
            func: "{that}.downloadInstaller",
            priority: "after:initialise"
        },
        "onInstallPackage.check": {
            func: "{that}.checkPackage",
            priority: "after:download"
        },
        "onInstallPackage.prepareInstall": {
            func: "{that}.prepareInstall",
            priority: "after:check"
        },
        "onInstallPackage.install": {
            func: "{that}.installPackage",
            priority: "after:prepareInstall"
        },
        "onInstallPackage.cleanup": {
            func: "{that}.cleanup",
            priority: "after:install"
        },
        "onInstallPackage.startApplication": {
            func: "{that}.startApplication",
            priority: "after:cleanup"
        },

        "onRemovePackage.stopApplication": {
            func: "{that}.stopApplication",
            priority: "first"
        },
        "onRemovePackage.uninstallPackage": {
            func: "{that}.uninstallPackage",
            priority: "after:stopApplication"
        },
        "onRemovePackage.cleanup": {
            func: "{that}.cleanup",
            priority: "after:uninstallPackage"
        }
    },

    // Types of package this installer supports
    packageTypes: null,

    members: {
        // Package information from the server.
        packageData: null,
        // "install" or "uninstall"
        currentAction: null
    }
});


/**
 * Installer component created.
 *
 * @param {Component} that The gpii.iod.installer instance.
 * @param {Component} iod The gpii.iod instance.
 */
gpii.iod.installerCreated = function (that, iod) {
    that.installation = iod.installations[that.options.installationID];
    if (that.installation) {
        that.installation.installer = that;
        that.packageData = that.installation.packageData;
    }
};

/**
 * Starts the installation pipeline.
 *
 * @param {Component} that The gpii.iod.installer instance.
 * @param {Component} iod The gpii.iod instance.
 * @return {Promise} Resolves when complete.
 */
gpii.iod.startInstaller = function (that) {
    that.currentAction = "install";
    return fluid.promise.fireTransformEvent(that.events.onInstallPackage);
};

/**
 * Starts the un-installation pipeline.
 *
 * @param {Component} that The gpii.iod.installer instance.
 * @param {Component} iod The gpii.iod instance.
 * @return {Promise} Resolves when complete.
 */
gpii.iod.startUninstaller = function (that) {
    that.currentAction = "uninstall";
    return fluid.promise.fireTransformEvent(that.events.onRemovePackage);
};

/**
 * Initialises the installation.
 *
 * @param {Component} that The gpii.iod.installer instance.
 * @param {Component} iod The gpii.iod instance.
 */
gpii.iod.initialise = function (that, iod) {
    var tempDir = iod.getWorkingPath(that.packageData.name);
    that.installation.tempDir = tempDir.fullPath;
    that.installation.cleanupPaths.push(tempDir.createdPath);
};

/**
 * Downloads an installer from the server.
 *
 * @param {Component} that The gpii.iod.installer instance.
 * @param {Object} iod The gpii.iod instance.
 * @return {Promise} Resolves when complete.
 */
gpii.iod.downloadInstaller = function (that) {

    fluid.log("IoD: Downloading installer " + that.packageData.installerSource);

    var promise = fluid.promise();

    that.installation.installerFile = path.join(that.installation.tempDir, that.packageData.installer);

    if (that.packageData.installerSource) {
        if (/^https?:\/\//.test(that.packageData.installerSource)) {
            // Warning: Taking a url from an external source, downloading it, and then later executing it (as admin).
            var downloadPromise = gpii.iod.fileDownload(that.packageData.installerSource, that.installation.installerFile);
            fluid.promise.follow(downloadPromise, promise);
        } else {
            fs.copyFile(that.packageData.url, that.installation.installerFile, function (err) {
                if (err) {
                    promise.reject({
                        isError: true,
                        message: "Unable to copy package"
                    });
                } else {
                    promise.resolve();
                }
            });
        }
    } else {
        promise.resolve();
    }

    return promise.then(null, function (err) {
        fluid.log("IoD: Failed download of " + that.packageData.installerSource + ": ", err);
    });
};

/**
 * Downloads a file while generating its hash.
 *
 * @param {String} url The remote uri.
 * @param {String} localPath Destination path.
 * @param {Object} options Options
 * @param {String} options.hash The hash algorithm (default: sha512)
 * @param {Function} options.process Callback for the progress, called with current and total.
 * @return {Promise} Resolves with the hash when the download is complete.
 */
gpii.iod.fileDownload = function (url, localPath, options) {
    options = Object.assign({
        hash: "sha512"
    }, options);

    var promise = fluid.promise();

    var output = fs.createWriteStream(localPath);
    var hash = crypto.createHash(options.hash);

    hash.on("finish", function () {
        promise.resolve(hash.digest());
    });

    var req = request.get({
        url: url
    });

    req.on("error", function (err) {
        promise.reject({
            isError: true,
            message: "Unable to download package: " + err.message,
            url: url,
            error: err
        });
    });

    req.on("response", function (response) {
        if (response.statusCode === 200) {
            response.pipe(output);
            response.pipe(hash);
        } else {
            promise.reject({
                isError: true,
                message: "Unable to download package: " + response.statusCode + " " + response.statusMessage,
                url: url
            });
        }
    });

    return promise;
};

/**
 * Checks that a downloaded package is ok.
 *
 * @param {Component} that The gpii.iod.installer instance.
 * @param {Object} iod The gpii.iod instance.
 * @return {Promise} Resolves when complete.
 */
gpii.iod.checkPackage = function (that) {
    var promise = fluid.promise();
    fluid.log("IoD: Checking downloaded package file " + that.packageData.filename);
    // TODO: It shouldn't be checked here - another process may over-write it before the high privilege executes it.
    // Instead, take ownership then check the integrity in the same context as it's being ran.
    promise.resolve();
    return promise;
};

/**
 * Generate the installation instructions.
 *
 * @param {Component} that The gpii.iod.installer instance.
 * @param {Object} iod The gpii.iod instance.
 * @return {Promise} Resolves when complete.
 */
gpii.iod.prepareInstall = function (that) {
    var promise = fluid.promise();
    fluid.log("IoD: Preparing installation for " + that.packageData.name);
    promise.resolve();
    return promise;
};

/**
 * Cleans up things that are no longer required.
 *
 * @param {Component} that The gpii.iod.installer instance.
 * @return {Promise} Resolves when complete.
 */
gpii.iod.cleanup = function (that) {
    var promise = fluid.promise();
    if (that.packageData.keepInstaller || that.currentAction === "uninstall") {
        // TODO
        fluid.log("IoD: Cleaning installation of " + that.packageData.name);
    }
    promise.resolve();
    return promise;
};

/**
 * Starts the application.
 *
 * @param {Component} that The gpii.iod.installer instance.
 * @return {Promise} Resolves when the application has been started.
 */
gpii.iod.startApplication = function (that) {
    var promise = fluid.promise();
    fluid.log("IoD: Starting application " + that.packageData.name);
    if (that.packageData.start) {
        child_process.exec(that.packageData.start, function (err, stdout, stderr) {
            if (err) {
                fluid.log("IoD: startApplication error: ", err);
            }
            fluid.log("IoD: startApplication: ", { stdout: stdout, stderr: stderr });
        });
    }
    promise.resolve();
    return promise;
};

/**
 * Stops the application (for uninstallation).
 *
 * @param {Component} that The gpii.iod.installer instance.
 * @return {Promise} Resolves when the command has completed.
 */
gpii.iod.stopApplication = function (that) {
    var promise = fluid.promise();
    fluid.log("IoD: Stopping application " + that.packageData.name);
    if (that.packageData.start) {
        child_process.exec(that.packageData.start, function (err, stdout, stderr) {
            if (err) {
                fluid.log("IoD: stopApplication error: ", err);
            }
            fluid.log("IoD: stopApplication: ", { stdout: stdout, stderr: stderr });
            promise.resolve();
        });
    } else {
        promise.resolve();
    }
    return promise;
};
