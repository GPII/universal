/*
 * Abstraction of something that installs packages.
 *
 * Copyright 2018 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var path = require("path"),
    fs = require("fs"),
    request = require("request"),
    crypto = require("crypto"),
    URL = require("url").URL,
    child_process = require("child_process");

var fluid = require("infusion");
var gpii = fluid.registerNamespace("gpii");
fluid.registerNamespace("gpii.iod");

fluid.defaults("gpii.iod.packageInstaller", {
    gradeNames: ["fluid.component"],

    invokers: {
        created: {
            funcName: "gpii.iod.installerCreated",
            args: ["{that}", "{iod}"]
        },
        startInstaller: {
            funcName: "gpii.iod.startInstaller",
            args: ["{that}", "{iod}"]
        },
        startUninstaller: {
            funcName: "gpii.iod.startUninstaller",
            args: ["{that}", "{iod}"]
        },
        executeCommand: {
            funcName: "gpii.iod.executeCommand",
            // PackageCommand, command, args
            args: ["{that}", "{arguments}.0", "{arguments}.1", "{arguments}.2"]
        },
        startProcess: {
            funcName: "gpii.iod.startProcess",
            // command, args
            args: ["{arguments}.0", "{arguments}.1"]
        },

        // Remaining invokers are part of the installation pipe-line. Each one is passed the installation and returns
        // an installation, either directly or via a promise.
        initialise: {
            funcName: "gpii.iod.initialise",
            args: ["{that}", "{iod}", "{that}.installation", "{that}.installation.packageData"]
        },
        downloadInstaller: {
            funcName: "gpii.iod.downloadInstaller",
            args: ["{that}", "{that}.installation", "{that}.installation.packageData"]
        },
        checkPackage: {
            funcName: "gpii.iod.checkPackage",
            args: ["{that}", "{that}.installation", "{that}.installation.packageData"]
        },
        prepareInstall: {
            funcName: "gpii.iod.prepareInstall",
            args: ["{that}", "{that}.installation", "{that}.installation.packageData"]
        },
        installPackage: "fluid.notImplemented",
        cleanup: {
            funcName: "gpii.iod.cleanup",
            args: ["{that}", "{that}.installation", "{that}.installation.packageData"]
        },
        installComplete: {
            funcName: "gpii.iod.installComplete",
            args: ["{that}", "{that}.installation", "{that}.installation.packageData"]
        },
        startApplication: {
            funcName: "gpii.iod.startApplication",
            args: ["{that}", "{that}.installation", "{that}.installation.packageData"]
        },
        stopApplication: {
            funcName: "gpii.iod.stopApplication",
            args: ["{that}", "{that}.installation", "{that}.installation.packageData"]
        },
        uninstallPackage: "fluid.notImplemented",
        uninstallComplete: {
            funcName: "gpii.iod.installComplete",
            args: ["{that}", "{that}.installation", "{that}.installation.packageData"]
        }
    },
    events: {
        // Dummy events for the installation pipe-lines
        onInstallPackage: null,
        onRemovePackage: null
    },
    listeners: {
        "onCreate": "{that}.created",
        "onInstallPackage.initialise": {
            func: "{that}.initialise",
            priority: "first"
        },
        "onInstallPackage.download": {
            func: "{that}.downloadInstaller",
            priority: "after:initialise"
        },
        "onInstallPackage.check": {
            func: "{that}.checkPackage",
            priority: "after:download"
        },
        "onInstallPackage.prepareInstall": {
            func: "{that}.prepareInstall",
            priority: "after:check"
        },
        "onInstallPackage.install": {
            func: "{that}.installPackage",
            priority: "after:prepareInstall"
        },
        "onInstallPackage.cleanup": {
            func: "{that}.cleanup",
            priority: "after:install"
        },
        "onInstallPackage.complete": {
            func: "{that}.installComplete",
            priority: "after:cleanup"
        },
        "onInstallPackage.startApplication": {
            func: "{that}.startApplication",
            priority: "last"
        },

        "onRemovePackage.stopApplication": {
            func: "{that}.stopApplication",
            priority: "first"
        },
        "onRemovePackage.uninstallPackage": {
            func: "{that}.uninstallPackage",
            priority: "after:stopApplication"
        },
        "onRemovePackage.cleanup": {
            func: "{that}.cleanup",
            priority: "after:uninstallPackage"
        },
        "onRemovePackage.uninstallComplete": {
            func: "{that}.uninstallComplete",
            priority: "after:cleanup"
        }
    },

    // Types of package this installer supports
    packageTypes: null,

    members: {
        // Package information from the server.
        packageData: null,
        // "install" or "uninstall"
        currentAction: null
    }
});


/**
 * Installer component created.
 *
 * @param {Component} that The gpii.iod.installer instance.
 * @param {Component} iod The gpii.iod instance.
 */
gpii.iod.installerCreated = function (that, iod) {
    if (that.options.installationID) {
        that.installation = iod.installations[that.options.installationID];
    }
    if (that.installation) {
        that.installation.installer = that;
        that.packageData = that.installation.packageData;
        if (!that.packageData.installCommands) {
            that.packageData.installCommands = {};
        }
        if (!that.packageData.uninstallCommands) {
            that.packageData.uninstallCommands = {};
        }
    }
};

/**
 * Starts the installation pipeline.
 *
 * @param {Component} that The gpii.iod.installer instance.
 * @param {Component} iod The gpii.iod instance.
 * @return {Promise} Resolves when complete.
 */
gpii.iod.startInstaller = function (that) {
    that.currentAction = "install";
    gpii.iod.addStageListeners(that, that.events.onInstallPackage);
    return fluid.promise.fireTransformEvent(that.events.onInstallPackage);
};

/**
 * Starts the un-installation pipeline.
 *
 * @param {Component} that The gpii.iod.installer instance.
 * @param {Component} iod The gpii.iod instance.
 * @return {Promise} Resolves when complete.
 */
gpii.iod.startUninstaller = function (that) {
    that.currentAction = "uninstall";
    gpii.iod.addStageListeners(that, that.events.onRemovePackage);
    return fluid.promise.fireTransformEvent(that.events.onRemovePackage);
};

/**
 * Adds listeners before and after the existing listeners of an event (onInstallPackage or onRemovePackage), which
 * update+log the current stage and possibly execute a command specified in the packageData.installCommands for that
 * stage.
 *
 * @param {Component} that The gpii.iod.installer instance.
 * @param {Event} event The event.
 */
gpii.iod.addStageListeners = function (that, event) {
    // inject some listeners to record the current stage
    fluid.each(Object.keys(event.listeners), function (namespace) {
        event.addListener(function () {
            that.installation.currentStage = namespace;
            fluid.log("IoD: Entering stage: ", namespace);
            return gpii.iod.customCommand(that, "before");
        }, "_before_" + namespace, "before:" + namespace);

        event.addListener(function () {
            fluid.log("IoD: Leaving stage: ", namespace);
            return gpii.iod.customCommand(that, "after");
        }, "_after_" + namespace, "after:" + namespace);

    });
};

gpii.iod.customCommand = function (that, when) {
    var commands = that.currentAction === "install"
        ? that.packageData.installCommands
        : that.packageData.uninstallCommands;
    var command = commands && commands[that.installation.currentStage + ":" + when];
    var togo;
    if (command) {
        togo = that.executeCommand(command);
    }
    return togo;
};

/**
 * Initialises the installation.
 *
 * @param {Component} that The gpii.iod.installer instance.
 * @param {Component} iod The gpii.iod instance.
 * @param {Installation} installation The installation state.
 * @param {PackageData} packageData The package data.
 * @return {Promise} Resolves when complete.
 */
gpii.iod.initialise = function (that, iod, installation, packageData) {
    var tempDir = iod.getWorkingPath(packageData.name);
    installation.tempDir = tempDir.fullPath;
    installation.cleanupPaths.push(tempDir.createdPath);
    return packageData.installCommands.initialise
        ? that.executeCommand(packageData.installCommands.initialise)
        : fluid.promise().resolve();
};

/**
 * Downloads an installer from the server.
 *
 * @param {Component} that The gpii.iod.installer instance.
 * @param {Installation} installation The installation state.
 * @param {PackageData} packageData The package data.
 * @return {Promise} Resolves when complete.
 */
gpii.iod.downloadInstaller = function (that, installation, packageData) {

    fluid.log("IoD: Downloading installer " + packageData.installerSource);

    installation.installerFile = path.join(installation.tempDir, packageData.installer);

    var promise = fluid.promise();
    if (packageData.installCommands.download) {
        promise = that.executeCommand(packageData.installCommands.initialise);
    } else {
        promise = fluid.promise();


        if (packageData.installerSource) {

            if (packageData.installerSource.indexOf("://") >= 0) {
                // Warning: Taking a url from an external source, downloading it, and then later executing it (as admin).
                var downloadPromise = gpii.iod.fileDownload(packageData.installerSource, installation.installerFile);
                downloadPromise.then(function (hash) {
                    installation.installerFileHash = hash;
                    promise.resolve();
                }, promise.reject);
            } else {
                fs.copyFile(packageData.installerSource, installation.installerFile, function (err) {
                    if (err) {
                        promise.reject({
                            isError: true,
                            message: "Unable to copy package"
                        });
                    } else {
                        promise.resolve();
                    }
                });
            }
        } else {
            promise.resolve();
        }
    }
    return promise.then(null, function (err) {
        fluid.log("IoD: Failed download of " + packageData.installerSource + ": ", err);
    });
};

/**
 * Downloads a file while generating its hash.
 *
 * @param {String} address The remote uri.
 * @param {String} localPath Destination path.
 * @param {Object} options Options
 * @param {String} options.hash The hash algorithm (default: sha512)
 * @param {Function} options.process Callback for the progress, called with current and total.
 * @return {Promise<String>} Resolves with the hash (hex string) when the download is complete.
 */
gpii.iod.fileDownload = function (address, localPath, options) {
    options = Object.assign({
        hash: "sha512"
    }, options);

    var promise = fluid.promise();

    var output = fs.createWriteStream(localPath);
    var hash = crypto.createHash(options.hash);

    output.on("finish", function () {
        promise.resolve(hash.digest("hex"));
    });

    var url = new URL(address);

    var stream;
    if (url.protocol === "file:") {
        var offset = parseInt(url.searchParams.get("offset")) || 0;
        stream = fs.createReadStream(url.pathname, {
            start: offset
        });

        stream.on("open", function () {
            stream.pipe(output);
        });
    } else {
        stream = request.get({
            url: address
        });

        stream.on("response", function (response) {
            if (response.statusCode === 200) {
                stream.pipe(output);
            } else {
                promise.reject({
                    isError: true,
                    message: "Unable to download package: " + response.statusCode + " " + response.statusMessage,
                    address: address
                });
            }
        });
    }

    stream.on("data", function (data) {
        hash.update(data);
    });

    stream.on("error", function (err) {
        promise.reject({
            isError: true,
            message: "Unable to download package: " + err.message,
            address: address,
            error: err
        });
    });

    return promise;
};

/**
 * Checks that a downloaded package is ok.
 *
 * @param {Component} that The gpii.iod.installer instance.
 * @param {Installation} installation The installation state.
 * @param {PackageData} packageData The package data.
 * @return {Promise} Resolves when complete.
 */
gpii.iod.checkPackage = function (that, installation, packageData) {
    var promise;
    fluid.log("IoD: Checking downloaded package file " + packageData.filename);
    if (packageData.installCommands.check) {
        promise = that.executeCommand(packageData.installCommands.check);
    } else {
        // TODO: It shouldn't be checked here - another process may over-write it before the high privilege executes it.
        // Instead, take ownership then check the integrity in the same context as it's being ran.
        var matches = packageData.installerHash === installation.installerFileHash;
        promise = fluid.promise();
        if (matches) {
            promise.resolve();
        } else {
            promise.reject({
                isError: true,
                message: "The downloaded installation file is wrong"
            });
        }
    }
    return promise;
};

/**
 * Generate the installation instructions.
 *
 * @param {Component} that The gpii.iod.installer instance.
 * @param {Installation} installation The installation state.
 * @param {PackageData} packageData The package data.
 * @return {Promise} Resolves when complete.
 */
gpii.iod.prepareInstall = function (that, installation, packageData) {
    var promise;
    fluid.log("IoD: Preparing installation for " + packageData.name);
    if (packageData.installCommands.prepareInstall) {
        promise = that.executeCommand(packageData.installCommands.prepareInstall);
    } else {
        // TODO: remove
        if (installation.packageData.elevate) {
            packageData.installerArgs = Object.assign({
                elevate: true
            }, packageData.installerArgs);
            packageData.uninstallerArgs = Object.assign({
                elevate: true
            }, packageData.uninstallerArgs);
        }
        promise = fluid.promise().resolve();
    }
    return promise;
};

/**
 * Cleans up things that are no longer required.
 *
 * @param {Component} that The gpii.iod.installer instance.
 * @param {Installation} installation The installation state.
 * @param {PackageData} packageData The package data.
 * @return {Promise} Resolves when complete.
 */
gpii.iod.cleanup = function (that, installation, packageData) {
    var promise;
    if (that.currentAction === "install") {
        promise = packageData.installCommands.cleanup && that.executeCommand(packageData.installCommands.cleanup);
    } else {
        promise = packageData.uninstallCommands.cleanup && that.executeCommand(packageData.uninstallCommands.cleanup);
    }

    if (!promise) {
        if (!packageData.keepInstaller || that.currentAction === "uninstall") {
            // TODO
            fluid.log("IoD: Cleaning installation of " + packageData.name);
        }
        promise = fluid.promise().resolve();
    }
    return promise;
};

/**
 * Called when the installation has completed.
 * @param {Component} that The gpii.iod.installer instance.
 * @param {Installation} installation The installation state.
 * @param {PackageData} packageData The package data.
 * @return {Promise} Resolves when complete.
 */
gpii.iod.installComplete = function (that, installation, packageData) {
    var promise;
    fluid.log("IoD: Completed installation of " + packageData.name);
    if (packageData.installCommands.complete) {
        promise = that.executeCommand(packageData.installCommands.complete);
    } else {
        promise = fluid.promise().resolve();
    }
    return promise;
};

/**
 * Starts the application.
 *
 * @param {Component} that The gpii.iod.installer instance.
 * @param {Installation} installation The installation state.
 * @param {PackageData} packageData The package data.
 * @return {Promise} Resolves when the application has been started.
 */
gpii.iod.startApplication = function (that, installation, packageData) {
    var promise = fluid.promise();
    fluid.log("IoD: Starting application " + packageData.name);
    if (packageData.start) {
        child_process.exec(packageData.start, function (err, stdout, stderr) {
            if (err) {
                fluid.log("IoD: startApplication error: ", err);
            }
            fluid.log("IoD: startApplication: ", { stdout: stdout, stderr: stderr });
        });
    }
    promise.resolve();
    return promise;
};

/**
 * Stops the application (for uninstallation).
 *
 * @param {Component} that The gpii.iod.installer instance.
 * @param {Installation} installation The installation state.
 * @param {PackageData} packageData The package data.
 * @return {Promise} Resolves when the command has completed.
 */
gpii.iod.stopApplication = function (that, installation, packageData) {
    var promise = fluid.promise();
    fluid.log("IoD: Stopping application " + packageData.name);
    if (packageData.start) {
        child_process.exec(packageData.start, function (err, stdout, stderr) {
            if (err) {
                fluid.log("IoD: stopApplication error: ", err);
            }
            fluid.log("IoD: stopApplication: ", { stdout: stdout, stderr: stderr });
            promise.resolve();
        });
    } else {
        promise.resolve();
    }
    return promise;
};

/**
 * Expands "$(expanders)" in a string, whose content is a path to a field in the given object.
 *
 * Expanders are in the format of $(path) or $(path?default).
 * Examples:
 *  "${a.b.c}", {a:{b:{c:"result"}}} returns "result".
 *  "${a.x?no}", {a:{b:{c:"result"}}} returns "no".
 *
 * @param {String|Object} unexpanded The input string, containing zero or more expanders. If an object, then string
 *  values within the object are worked on.
 * @param {Object} sourceObject The object which the paths in the expanders refer to.
 * @param {String} alwaysExpand `true` to make expanders that resolve to null/undefined resolve to an empty
 *  string, otherwise the function returns null.
 * @return {String} The input string, with the expanders replaced by the value of the field they refer to.
 */
gpii.iod.expand = function (unexpanded, sourceObject, alwaysExpand) {
    var unresolved = false;
    var result;

    if (typeof(unexpanded) === "string") {
        // Replace all occurences of "$(...)"
        result = unexpanded.replace(/\$\(([^?}]*)(\?([^}]*))?\)/g, function (match, expression, defaultGroup, defaultValue) {
            if (expression === "debug") {
                fluid.log("expand object: ", sourceObject);
            }
            // Resolve the path to a field, deep in the object.
            var value = expression.split(".").reduce(function (parent, property) {
                return (parent && parent.hasOwnProperty(property)) ? parent[property] : undefined;
            }, sourceObject);

            if (value === undefined || (typeof (value) === "object")) {
                if (defaultGroup) {
                    value = defaultValue;
                }
                if (value === undefined || value === null) {
                    if (!alwaysExpand) {
                        unresolved = true;
                    }
                    value = "";
                }
            }
            return value;
        });
    } else if (unexpanded === null || unexpanded === undefined) {
        result = null;
    } else if (fluid.isPlainObject(unexpanded)) {
        result = fluid.transform(unexpanded, function (field) {
            return gpii.iod.expand(field, sourceObject, alwaysExpand);
        });
    } else {
        result = unexpanded;
    }

    return unresolved ? null : result;
};

/**
 * Starts a process, and waits for it to exit.
 * @param {String} command The command to run.
 * @param {Array<String>} args [optional] The arguments to pass.
 * @return {Promise} Resolves when the process terminates.
 */
gpii.iod.startProcess = function (command, args) {
    args = fluid.makeArray(args);
    var promise = fluid.promise();
    fluid.log("spawning: " + command + " ", args);
    var child = child_process.spawn(command, fluid.makeArray(args), {
        stdio: "inherit"
    });

    child.on("error", function (err) {
        if (!promise.disposition) {
            promise.reject({
                isError: true,
                error: err,
                message: "Error running command",
                command: command,
                args: args
            });
        }
    });
    child.on("exit", function (code) {
        if (code) {
            if (!promise.disposition) {
                promise.reject({
                    isError: true,
                    exitCode: code,
                    message: "Error running command",
                    command: command,
                    args: args
                });
            }
        } else {
            promise.resolve();
        }
    });
    return promise;
};

/**
 * Executes a command, which was specified in the package data.
 *
 * @param {Component} that The gpii.iod.installer instance.
 * @param {PackageCommand} execOptions How the command is invoked.
 * @param {String} command The command (overrides `execOptions.command`.
 * @param {Array<String>|String} args [optional] The arguments (overrides `execOptions.args`).
 * @return {Promise} Resolves when complete.
 */
gpii.iod.executeCommand = function (that, execOptions, command, args) {
    // Take a copy to modify.
    execOptions = Object.assign({}, execOptions);

    if (command) {
        execOptions.command = command;
    }

    execOptions.args = fluid.makeArray(args || execOptions.args);
    execOptions = gpii.iod.expand(execOptions, that.installation);

    var promise;
    if (!execOptions.command) {
        promise = fluid.promise().reject({
            isError: true,
            message: "executeCommand called without a command"
        });
    } else if (execOptions.elevate && that.startElevatedProcess) {
        promise = that.startElevatedProcess(execOptions.command, execOptions.args, {desktop: execOptions.desktop});
    } else {
        if (execOptions.elevate) {
            fluid.log(fluid.logLevel.WARN, "Running elevated commands is not supported on this system.");
        }

        promise = that.startProcess(execOptions.command, execOptions.args);
    }

    return promise;
};
