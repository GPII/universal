/*
 * Install on Demand packages.
 *
 * Copyright 2019 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion"),
    fs = require("fs");

require("kettle");

var gpii = fluid.registerNamespace("gpii");
fluid.registerNamespace("gpii.iod.packages");
fluid.registerNamespace("gpii.iod.packages.resolvers");

fluid.require("%lifecycleManager");
require("./packageInstaller.js");
require("./iodSettingsHandler.js");
require("./multiDataSource.js");

/**
 * Information about a package.
 * @typedef {Object} PackageData
 * @property {String} name The package name.
 * @property {String} packageType Type of installer to use.
 *
 * @property {String} publicKey Public key used to verify the package data.
 *
 * @property {String} installer Original filename of the installer file.
 * @property {String} installerSize Size of installer.
 * @property {String} installerHash Installer sha512 hash.
 * @property {String} installerSource The installer location (where to download/copy it from).
 *
 * @property {Boolean} keepInstaller `true` to keep the installer file after installing (removes after uninstall).
 *
 * @property {PackageCommand|String} installerArgs Additional options used when executing the installer.
 * @property {PackageCommand|String} uninstallerArgs Additional options used when executing the uninstaller.
 *
 * @property {String} uninstallTime When to uninstall this package, after it's no longer required: "immediate", "idle",
 *   "never".
 *
 * @property {String} uiLevel How much is displayed (if possible): "none" (default), "progress" (non-interactive),
 *   "progress-cancel" (progress, can be cancelled), "full" (fully interactive, asks questions).
 *
 * @property {Object} installCommands Commands to execute at certain points in the installation, rather than
 *  perform the default action (if any).
 * @property {PackageCommand} installCommands.initialise The initialise command.
 * @property {PackageCommand} installCommands.download The download command.
 * @property {PackageCommand} installCommands.check The check command.
 * @property {PackageCommand} installCommands.prepareInstall The prepareInstall command.
 * @property {PackageCommand} installCommands.install The install command.
 * @property {PackageCommand} installCommands.cleanup The cleanup command.
 * @property {PackageCommand} installCommands.complete The installation is complete.
 *
 * @property {Object} uninstallCommands Commands to execute at certain points in the installation, rather than
 *  perform the default action (if any).
 * @property {PackageCommand} uninstallCommands.uninstall The initialise command.
 * @property {PackageCommand} uninstallCommands.cleanup The download command.
 * @property {PackageCommand} uninstallCommands.complete The check command.
 *
 */

/**
 * Describes how something is invoked.
 * @typedef {Object} PackageCommand
 * @property {String} command The command to invoke.
 * @property {String|Array<String>} args arguments passed to the command.
 * @property {Number|Array<Number>} success Exit code(s) to assume success (mutually exclusive with failure).
 * @property {Number|Array<Number>} failure Exit code(s) to assume failure (mutually exclusive with success).
 * @property {Boolean} elevate true to run as administrator.
 * @property {Boolean} desktop true to run in the context of the desktop, if elevate is true.
 */

gpii.iod.resolvers = {};

fluid.defaults("gpii.iod.packages", {
    gradeNames: ["fluid.component"],
    components: {
        dataSource: {
            type: "gpii.iod.multiDataSource",
            options: {
                invokers: {
                    "checkPackageSignature": {
                        funcName: "gpii.iod.checkPackageSignature",
                        args: ["{arguments}.0", "{gpii.iod.packages}.options.trustedKeys"]
                    }
                },
                listeners: {
                    "onRead.checkSignature": {
                        func: "{that}.checkPackageSignature",
                        args: "{arguments}.0" // packageResponse
                    }
                }
            }
        },
        variableResolver: {
            type: "gpii.lifecycleManager.variableResolver"
        }
    },
    invokers: {
        getPackageData: {
            funcName: "gpii.iod.getPackageData",
            args: ["{that}", "{arguments}.0"] // packageRequest
        },
        checkInstalled: {
            funcName: "gpii.iod.checkInstalled",
            args: ["{that}", "{arguments}.0"] // packageData
        },
        resolvePackage: {
            funcName: "gpii.iod.resolvePackage",
            args: ["{that}", "{arguments}.0"] // packageData
        }
    },
    listeners: {
        onCreate: "fluid.identity",
        "onServerFound.dataSource": {
            listener: "{that}.dataSource.events.onNewDataSource",
            args: ["gpii.iod.packageDataSource.remote", "{arguments}.0", 20] // endpoint
        },
        "onLocalPackagesFound.dataSource": {
            listener: "{that}.dataSource.events.onNewDataSource",
            args: ["gpii.iod.packageDataSource.local", "{arguments}.0", 10] // path
        }
    },
    members: {
        resolvers: {
            expander: {
                func: "fluid.transform",
                args: [ "{that}.options.resolvers", fluid.getGlobalValue ]
            }
        },
        fetcher: {
            expander: {
                func: "gpii.resolversToFetcher",
                args: "{that}.resolvers"
            }
        },
        // The IoD server, set from onServerFound
        endpoint: null
    },
    resolvers: {
        exists: "gpii.iod.existsResolver"
    }
});

/**
 * Resolver for ${{exists}.path}, determines if a filesystem path exists. The path can include environment variables,
 * named between two '%' symbols (like %this%), to work around the resolvers not supporting nested expressions.
 *
 * @param {String} path The path to test. Environment variables within two '%' symbols are expanded.
 * @return {Boolean} true if the path exists.
 */
gpii.iod.existsResolver = function (path) {
    var expandedPath = path.replace(/%([^% ]+)%/g, function (match, name) {
        return process.env[name];
    });
    return fs.existsSync(expandedPath);
};

/**
 * Resolves ${} variables of fields in a packageData.
 *
 * @param {Component} that The gpii.iod.packages instance.
 * @param {PackageData} packageData The package.
 * @return {PackageData} A copy of the package data, with resolved fields.
 */
gpii.iod.resolvePackage = function (that, packageData) {
    var result;

    if (packageData._original) {
        // This package has already been resolved; work on the original copy.
        result = gpii.iod.resolvePackage(that, packageData._original);
    } else {
        result = fluid.copy(packageData);

        // Allow references to the package itself via "${{this}.field}".
        var fetchers = gpii.combineFetchers(that.fetcher, gpii.resolversToFetcher({"this": result}));
        // Run the resolvers first, so the real values can be used in the transforms
        result = that.variableResolver.resolve(result, fetchers);

        // Transform the package data. Because the same object is being used as the rules, just transform each field which
        // have a transform rule, to avoid using malformed rules.
        fluid.each(result, function (value, key) {
            if (value && (value.transform || value.literalValue) && key !== "_original") {
                var newValue = value;
                var count = 0;
                // Transform the field, until it's no longer a transform rule. Meaning, if the output is another field
                // which has yet to be transformed, then transform it.
                do {
                    if (++count > fluid.strategyRecursionBailout) {
                        fluid.log(fluid.logLevel.WARN, "ERROR: resolvePackage transform got too deep");
                        newValue = undefined;
                        break;
                    } else {
                        newValue = fluid.model.transformWithRules(result, {out: newValue}).out;
                    }
                } while (newValue && (newValue.transform || newValue.literalValue));
                result[key] = newValue;
            }
        });

        // Stash the original, so it can be re-resolved.
        result._original = fluid.freezeRecursive(packageData);
    }

    return result;
};

/**
 * Retrieve the package metadata.
 *
 * @param {Component} that The gpii.iod.packages instance.
 * @param {Object} packageRequest Containing packageName, language, version.
 * @param {String} packageRequest.packageName Name of the package.
 * @param {String} packageRequest.version [optional] Version.
 * @param {String} packageRequest.language [optional] Language code with optional country code (en, en-US, es-ES).
 * @return {Promise} Resolves to an object containing package information.
 */
gpii.iod.getPackageData = function (that, packageRequest) {
    fluid.log("IoD: Getting package info for " + packageRequest.packageName);

    var promise = fluid.promise();

    that.dataSource.get({
        packageName: packageRequest.packageName,
        language: packageRequest.language,
        version: packageRequest.version
    }).then(function (packageResponse) {
        fluid.log("IoD: Package response: ", packageResponse);
        /** @type {PackageData} */
        var packageData = packageResponse.packageData;

        if (packageData.name === packageRequest.packageName) {
            if (packageResponse.installer) {
                if (packageResponse.baseUrl && !packageResponse.installer.includes("://")) {
                    packageData.installerSource = gpii.iod.joinUrl(packageResponse.baseUrl, packageResponse.installer);
                } else {
                    packageData.installerSource = packageResponse.installer;
                }
            }

            if (packageRequest.language && packageData.languages) {
                // Merge the language-specific info.
                var lang = gpii.iod.matchLanguage(Object.keys(packageData.languages), packageRequest.language);
                if (lang) {
                    Object.assign(packageData, packageData.languages[lang]);
                    packageData.language = lang;
                }
            }

            var resolvedPackageData = that.resolvePackage(packageData);
            promise.resolve(resolvedPackageData);
        } else {
            promise.reject({
                isError: true,
                message: "Unable to get package " + packageRequest.packageName
                    + ": Incorrect package name '" + packageData.name + "'"
            });
        }
    }, function (err) {
        promise.reject({
            isError: true,
            message: "Unable to get package " + packageRequest.packageName + ": " + (err.message || "unknown error"),
            error: err
        });
    });

    return promise;
};

/**
 * Finds the best language from a list of available languages, using the following priority:
 * - Exact match with country code
 * - Exact match without country code
 * - First language, ignoring country code.
 *
 * @param {Array<String>} languages The list of available languages, with optional country code (en, en-US, es-ES)
 * @param {String} language The preferred language.
 * @return {String} The closest matching item from languages.
 */
gpii.iod.matchLanguage = function (languages, language) {
    languages = fluid.makeArray(languages);

    // Exact match.
    var index = languages.indexOf(language);
    var match = index >= 0 && languages[index];

    if (!match) {
        var langCode = language.substr(0, 2);
        // Language without country.
        if (language.length > 2) {
            index = languages.indexOf(language);
            match = index >= 0 && languages[index];
        }

        if (!match) {
            // Ignore the country.
            match = languages.find(function (lang) {
                return lang.substr(0, 2) === langCode;
            });
        }
    }

    return match;
};

/**
 * Determines if a package is installed.
 *
 * @param {Component} that The gpii.iod.packages instance.
 * @param {PackageData} packageData The package data.
 * @return {Boolean} true if the package is installed.
 */
gpii.iod.checkInstalled = function (that, packageData) {

    // Update the isInstalled, to reflect the current situation.
    packageData = that.resolvePackage(packageData);

    var isInstalled = packageData.isInstalled;
    if (fluid.isPlainObject(isInstalled)) {
        isInstalled = isInstalled.isInstalled || isInstalled.value;
    }

    return isInstalled === undefined || !!fluid.coerceToPrimitive(isInstalled);
};
