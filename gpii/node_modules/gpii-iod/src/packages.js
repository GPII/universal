/*
 * Install on Demand packages.
 *
 * Copyright 2019 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion"),
    fs = require("fs");

require("kettle");

var gpii = fluid.registerNamespace("gpii");
fluid.registerNamespace("gpii.iod.packages");
fluid.registerNamespace("gpii.iod.packages.resolvers");

fluid.require("%lifecycleManager");
require("./packageInstaller.js");
require("./iodSettingsHandler.js");

/**
 * Information about a package.
 * @typedef {Object} PackageData
 * @property {String} name The package name.
 * @property {String} url The package location.
 * @property {String} filename The package filename.
 * @property {String} packageType Type of installer to use.
 *
 * @property {String} installerFilename Original filename of the installer file.
 * @property {String} installerSize Size of installer.
 * @property {String} installerHash Installer sha512 hash.
 * @property {String} publicKey Public key used to verify the package data.
 *
 */

gpii.iod.resolvers = {};

fluid.defaults("gpii.iod.packages", {
    gradeNames: ["fluid.component"],
    components: {
        packageDataSource: {
            type: "kettle.dataSource.file",
            options: {
                gradeNames: ["kettle.dataSource.file.moduleTerms", "kettle.dataSource.encoding.JSON5"],
                path: "%gpii-universal/testData/installOnDemand/%packageName.json5",
                termMap: {
                    "packageName": "%packageName"
                },
                components: {
                    encoding: {
                        type: "kettle.dataSource.encoding.JSON5"
                    }
                }
            }
        },
        remotePackageDataSource: {
            createOnEvent: "onServiceFound",
            type: "kettle.dataSource.URL"
        },
        variableResolver: {
            type: "gpii.lifecycleManager.variableResolver"
        }
    },
    invokers: {
        getPackageData: {
            funcName: "gpii.iod.getPackageData",
            args: ["{that}", "{arguments}.0"] // packageRequest
        },
        checkInstalled: {
            funcName: "gpii.iod.checkInstalled",
            args: ["{that}", "{arguments}.0"] // packageData
        },
        resolvePackage: {
            funcName: "gpii.iod.resolvePackage",
            args: ["{that}", "{arguments}.0"] // packageData
        }
    },
    listeners: {
        onCreate: "fluid.identity"
    },
    members: {
        resolvers: {
            expander: {
                func: "fluid.transform",
                args: [ "{that}.options.resolvers", fluid.getGlobalValue ]
            }
        },
        fetcher: {
            expander: {
                func: "gpii.resolversToFetcher",
                args: "{that}.resolvers"
            }
        }
    },
    resolvers: {
        exists: "gpii.iod.existsResolver"
    }

});

/**
 * Resolver for ${{exists}.path}, determines if a filesystem path exists. The path can include environment variables,
 * named between two '%' symbols (like %this%), to work around the resolvers not supporting nested expressions.
 *
 * @param {String} path The path to test. Environment variables within two '%' symbols are expanded.
 * @return {Boolean} true if the path exists.
 */
gpii.iod.existsResolver = function (path) {
    var expandedPath = path.replace(/%([^% ]+)%/g, function (match, name) {
        return process.env[name];
    });
    return fs.existsSync(expandedPath);
};

/**
 * Resolves ${} variables of fields in a packageData.
 *
 * @param {Component} that The gpii.iod.packages instance.
 * @param {PackageData} packageData The package.
 * @return {PackageData} A copy of the package data, with resolved fields.
 */
gpii.iod.resolvePackage = function (that, packageData) {
    var result;

    if (packageData._original) {
        // This package has already been resolved; work on the original copy.
        result = gpii.iod.resolvePackage(that, packageData._original);
    } else {
        result = fluid.copy(packageData);

        // Allow references to the package itself via "${{this}.field}".
        var fetchers = gpii.combineFetchers(that.fetcher, gpii.resolversToFetcher({"this": result}));
        // Run the resolvers first, so the real values can be used in the transforms
        result = that.variableResolver.resolve(result, fetchers);

        // Transform the package data. Because the same object is being used as the rules, just transform each field which
        // have a transform rule, to avoid using malformed rules.
        fluid.each(result, function (value, key) {
            if (value && (value.transform || value.literalValue) && key !== "_original") {
                var newValue = value;
                var count = 0;
                // Transform the field, until it's no longer a transform rule. Meaning, if the output is another field
                // which has yet to be transformed, then transform it.
                do {
                    if (++count > fluid.strategyRecursionBailout) {
                        fluid.log(fluid.logLevel.WARN, "ERROR: resolvePackage transform got too deep");
                        newValue = undefined;
                        break;
                    } else {
                        newValue = fluid.model.transformWithRules(result, {out: newValue}).out;
                    }
                } while (newValue && (newValue.transform || newValue.literalValue));
                result[key] = newValue;
            }
        });

        // Stash the original, so it can be re-resolved.
        result._original = fluid.freezeRecursive(packageData);
    }

    return result;
};

/**
 * Retrieve the package metadata.
 *
 * @param {Component} that The gpii.iod.packages instance.
 * @param {Object} packageRequest Containing packageName, language, version.
 * @param {String} packageRequest.packageName Name of the package.
 * @param {String} packageRequest.version [optional] Version.
 * @param {String} packageRequest.language [optional] Language code with optional country code (en, en-US, es-ES).
 * @return {Promise} Resolves to an object containing package information.
 */
gpii.iod.getPackageData = function (that, packageRequest) {
    fluid.log("IoD: Getting package info for " + packageRequest.packageName);

    var promise = fluid.promise();

    var dataSource = that.remotepackageDataSource || that.packageDataSource;

    if (dataSource) {
        dataSource.get({
            packageName: packageRequest.packageName,
            language: packageRequest.language,
            version: packageRequest.version,
            server: that.remoteServer
        }).then(function (packageData) {
            if (packageRequest.language && packageData.languages) {
                // Merge the language-specific info.
                var lang = gpii.iod.matchLanguage(Object.keys(packageData.languages), packageRequest.language);
                if (lang) {
                    Object.assign(packageData, packageData.languages[lang]);
                    packageData.language = lang;
                }
            }

            var resolvedPackageData = that.resolvePackage(packageData);
            promise.resolve(resolvedPackageData);
        }, function (err) {
            promise.reject({
                isError: true,
                message: "Unknown package " + packageRequest.packageName,
                error: err
            });
        });
    } else {
        promise.reject({
            isError: true,
            message: "No package data source for IoD"
        });
    }

    return promise;
};

/**
 * Finds the best language from a list of available languages, using the following priority:
 * - Exact match with country code
 * - Exact match without country code
 * - First language, ignoring country code.
 *
 * @param {Array<String>} languages The list of available languages, with optional country code (en, en-US, es-ES)
 * @param {String} language The preferred language.
 * @return {String} The closest matching item from languages.
 */
gpii.iod.matchLanguage = function (languages, language) {
    languages = fluid.makeArray(languages);

    // Exact match.
    var index = languages.indexOf(language);
    var match = index >= 0 && languages[index];

    if (!match) {
        var langCode = language.substr(0, 2);
        // Language without country.
        if (language.length > 2) {
            index = languages.indexOf(language);
            match = index >= 0 && languages[index];
        }

        if (!match) {
            // Ignore the country.
            match = languages.find(function (lang) {
                return lang.substr(0, 2) === langCode;
            });
        }
    }

    return match;
};

/**
 * Determines if a package is installed.
 *
 * @param {Component} that The gpii.iod.packages instance.
 * @param {PackageData} packageData The package data.
 * @return {Boolean} true if the package is installed.
 */
gpii.iod.checkInstalled = function (that, packageData) {

    // Update the isInstalled, to reflect the current situation.
    packageData = that.resolvePackage(packageData);

    var isInstalled = packageData.isInstalled;
    if (fluid.isPlainObject(isInstalled)) {
        isInstalled = isInstalled.isInstalled || isInstalled.value;
    }

    return !!fluid.coerceToPrimitive(isInstalled);
};
