/*
 * Install on Demand packages.
 *
 * Copyright 2019 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion"),
    fs = require("fs");

require("kettle");

var gpii = fluid.registerNamespace("gpii");
fluid.registerNamespace("gpii.iod.packages");
fluid.registerNamespace("gpii.iod.packages.resolvers");

fluid.require("%lifecycleManager");
require("./packageInstaller.js");
require("./iodSettingsHandler.js");

/**
 * Information about a package.
 * @typedef {Object} PackageData
 * @property {String} name The package name.
 * @property {String} packageType Type of installer to use.
 *
 * @property {String} publicKey Public key used to verify the package data.
 *
 * @property {String} installer Original filename of the installer file.
 * @property {String} installerSize Size of installer.
 * @property {String} installerHash Installer sha512 hash.
 * @property {String} installerSource The installer location (where to download/copy it from).
 *
 * @property {Boolean} keepInstaller `true` to keep the installer file after installing (removes after uninstall).
 *
 * @property {PackageInvocation|String} installerArgs Additional options used when executing the installer.
 * @property {PackageInvocation|String} uninstallerArgs Additional options used when executing the uninstaller.
 *
 * @property {String} uninstallTime When to uninstall this package, after it's no longer required: "immediate", "idle",
 *   "never".
 *
 * @property {String} uiLevel How much is displayed (if possible): "none" (default), "progress" (non-interactive),
 *   "progress-cancel" (progress, can be cancelled), "full" (fully interactive, asks questions).
 *
 * @property {Object} installCommands Commands to execute at certain points in the installation, rather than
 *  perform the default action (if any).
 * @property {PackageCommand} installCommands.initialise The initialise command.
 * @property {PackageCommand} installCommands.download The download command.
 * @property {PackageCommand} installCommands.check The check command.
 * @property {PackageCommand} installCommands.prepareInstall The prepareInstall command.
 * @property {PackageCommand} installCommands.install The install command.
 * @property {PackageCommand} installCommands.cleanup The cleanup command.
 * @property {PackageCommand} installCommands.complete The installation is complete.
 *
 */

/**
 * Describes how something is invoked.
 * @typedef {Object} PackageInvocation
 * @property {String|Array<String>} args arguments passed to the command.
 * @property {Boolean} elevate true to run as administrator.
 * @property {Boolean} desktop true to run in the context of the desktop, if elevate is true.
 */

/**
 * A command
 * @typedef {PackageInvocation} PackageCommand
 * @property {String} command The command to invoke.
 */

gpii.iod.resolvers = {};

fluid.defaults("gpii.iod.packages", {
    gradeNames: ["fluid.component"],
    components: {
        packageDataSource: {
            type: "kettle.dataSource.file",
            options: {
                gradeNames: ["kettle.dataSource.file.moduleTerms", "kettle.dataSource.encoding.JSON5"],
                path: "%gpii-universal/testData/installOnDemand/%packageName.json5",
                termMap: {
                    "packageName": "%packageName"
                },
                components: {
                    encoding: {
                        type: "kettle.dataSource.encoding.JSON5"
                    }
                }
            }
        },
        remotePackageDataSource: {
            createOnEvent: "onServerFound",
            type: "gpii.iod.remotePackageDataSource",
            options: {
                url: "@expand:gpii.iod.joinUrl({arguments}.0, {that}.options.urlPath)",
                urlPath: "/packages/%packageName",
                termMap: {
                    packageName: "%packageName"
                }
            }
        },
        variableResolver: {
            type: "gpii.lifecycleManager.variableResolver"
        }
    },
    invokers: {
        getPackageData: {
            funcName: "gpii.iod.getPackageData",
            args: ["{that}", "{arguments}.0"] // packageRequest
        },
        checkInstalled: {
            funcName: "gpii.iod.checkInstalled",
            args: ["{that}", "{arguments}.0"] // packageData
        },
        resolvePackage: {
            funcName: "gpii.iod.resolvePackage",
            args: ["{that}", "{arguments}.0"] // packageData
        }
    },
    listeners: {
        onCreate: "fluid.identity",
        onServerFound: {
            funcName: "fluid.set",
            args: [ "{that}", "endpoint", "{arguments}.0"]
        }
    },
    members: {
        resolvers: {
            expander: {
                func: "fluid.transform",
                args: [ "{that}.options.resolvers", fluid.getGlobalValue ]
            }
        },
        fetcher: {
            expander: {
                func: "gpii.resolversToFetcher",
                args: "{that}.resolvers"
            }
        },
        // The IoD server, set from onServerFound
        endpoint: null
    },
    resolvers: {
        exists: "gpii.iod.existsResolver"
    }

});

/**
 * Convenience function to concatenate two parts of a URL together, ensuring there's a single '/' between each part
 * (like `path.join`, but performs no normalisation and always uses slash).
 *
 * @param {String} front The first part of the URL
 * @param {String} end The final part of the URL
 * @return {String} `font` and `end` combined.
 */
gpii.iod.joinUrl = function (front, end) {
    return front.replace(/\/+$/, "") + "/" + end.replace(/^\/+/, "");
};

/**
 * Resolver for ${{exists}.path}, determines if a filesystem path exists. The path can include environment variables,
 * named between two '%' symbols (like %this%), to work around the resolvers not supporting nested expressions.
 *
 * @param {String} path The path to test. Environment variables within two '%' symbols are expanded.
 * @return {Boolean} true if the path exists.
 */
gpii.iod.existsResolver = function (path) {
    var expandedPath = path.replace(/%([^% ]+)%/g, function (match, name) {
        return process.env[name];
    });
    return fs.existsSync(expandedPath);
};

/**
 * Resolves ${} variables of fields in a packageData.
 *
 * @param {Component} that The gpii.iod.packages instance.
 * @param {PackageData} packageData The package.
 * @return {PackageData} A copy of the package data, with resolved fields.
 */
gpii.iod.resolvePackage = function (that, packageData) {
    var result;

    if (packageData._original) {
        // This package has already been resolved; work on the original copy.
        result = gpii.iod.resolvePackage(that, packageData._original);
    } else {
        result = fluid.copy(packageData);

        // Allow references to the package itself via "${{this}.field}".
        var fetchers = gpii.combineFetchers(that.fetcher, gpii.resolversToFetcher({"this": result}));
        // Run the resolvers first, so the real values can be used in the transforms
        result = that.variableResolver.resolve(result, fetchers);

        // Transform the package data. Because the same object is being used as the rules, just transform each field which
        // have a transform rule, to avoid using malformed rules.
        fluid.each(result, function (value, key) {
            if (value && (value.transform || value.literalValue) && key !== "_original") {
                var newValue = value;
                var count = 0;
                // Transform the field, until it's no longer a transform rule. Meaning, if the output is another field
                // which has yet to be transformed, then transform it.
                do {
                    if (++count > fluid.strategyRecursionBailout) {
                        fluid.log(fluid.logLevel.WARN, "ERROR: resolvePackage transform got too deep");
                        newValue = undefined;
                        break;
                    } else {
                        newValue = fluid.model.transformWithRules(result, {out: newValue}).out;
                    }
                } while (newValue && (newValue.transform || newValue.literalValue));
                result[key] = newValue;
            }
        });

        // Stash the original, so it can be re-resolved.
        result._original = fluid.freezeRecursive(packageData);
    }

    return result;
};

/**
 * Retrieve the package metadata.
 *
 * @param {Component} that The gpii.iod.packages instance.
 * @param {Object} packageRequest Containing packageName, language, version.
 * @param {String} packageRequest.packageName Name of the package.
 * @param {String} packageRequest.version [optional] Version.
 * @param {String} packageRequest.language [optional] Language code with optional country code (en, en-US, es-ES).
 * @return {Promise} Resolves to an object containing package information.
 */
gpii.iod.getPackageData = function (that, packageRequest) {
    fluid.log("IoD: Getting package info for " + packageRequest.packageName);

    var promise = fluid.promise();

    var remote = !!that.remotePackageDataSource;
    var dataSource = remote ? that.remotePackageDataSource : that.packageDataSource;

    if (dataSource) {
        dataSource.get({
            packageName: packageRequest.packageName,
            language: packageRequest.language,
            version: packageRequest.version
        }).then(function (packageResponse) {
            fluid.log("IoD: Package response: ", packageResponse);
            // Remote datasource wraps the packageData, local doesn't.
            /** @type PackageData */
            var packageData = remote ? packageResponse.packageData : packageResponse;

            if (remote && packageResponse.installer) {
                packageData.installerSource = gpii.iod.joinUrl(that.endpoint, packageResponse.installer);
            }

            if (packageRequest.language && packageData.languages)
            {
                // Merge the language-specific info.
                var lang = gpii.iod.matchLanguage(Object.keys(packageData.languages), packageRequest.language);
                if (lang) {
                    Object.assign(packageData, packageData.languages[lang]);
                    packageData.language = lang;
                }
            }

            var resolvedPackageData = that.resolvePackage(packageData);
            promise.resolve(resolvedPackageData);
        }, function (err) {
            promise.reject({
                isError: true,
                message: "Unknown package " + packageRequest.packageName,
                error: err
            });
        });
    } else {
        promise.reject({
            isError: true,
            message: "No package data source for IoD"
        });
    }

    return promise;
};

/**
 * Finds the best language from a list of available languages, using the following priority:
 * - Exact match with country code
 * - Exact match without country code
 * - First language, ignoring country code.
 *
 * @param {Array<String>} languages The list of available languages, with optional country code (en, en-US, es-ES)
 * @param {String} language The preferred language.
 * @return {String} The closest matching item from languages.
 */
gpii.iod.matchLanguage = function (languages, language) {
    languages = fluid.makeArray(languages);

    // Exact match.
    var index = languages.indexOf(language);
    var match = index >= 0 && languages[index];

    if (!match) {
        var langCode = language.substr(0, 2);
        // Language without country.
        if (language.length > 2) {
            index = languages.indexOf(language);
            match = index >= 0 && languages[index];
        }

        if (!match) {
            // Ignore the country.
            match = languages.find(function (lang) {
                return lang.substr(0, 2) === langCode;
            });
        }
    }

    return match;
};

/**
 * Determines if a package is installed.
 *
 * @param {Component} that The gpii.iod.packages instance.
 * @param {PackageData} packageData The package data.
 * @return {Boolean} true if the package is installed.
 */
gpii.iod.checkInstalled = function (that, packageData) {

    // Update the isInstalled, to reflect the current situation.
    packageData = that.resolvePackage(packageData);

    var isInstalled = packageData.isInstalled;
    if (fluid.isPlainObject(isInstalled)) {
        isInstalled = isInstalled.isInstalled || isInstalled.value;
    }

    return !!fluid.coerceToPrimitive(isInstalled);
};
