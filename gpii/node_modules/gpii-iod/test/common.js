/*
 * IoD Tests - package data source.
 *
 * Copyright 2020 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion");
fluid.require("kettle");

var crypto = require("crypto"),
    path = require("path"),
    fs = require("fs"),
    mkdirp = require("mkdirp"),
    json5 = require("json5");

var gpii = fluid.registerNamespace("gpii");
fluid.registerNamespace("gpii.tests.iod");

require("gpii-iodServer");

/**
 * Signs `data` with the private key from `keyPair`.
 * @param {Object} data The object to sign.
 * @param {Object} keyPair The key to sign it with.
 * @return {Object} The `string` and `signature` of the data.
 */
gpii.tests.iod.generateSignedData = function (data, keyPair) {
    var signedData = gpii.iodServer.packageFile.signPackageData(data, keyPair);

    return {
        string: signedData.buffer.toString("utf8"),
        signature: signedData.signature
    };
};

gpii.tests.iod.keyPair = null;

/**
 * Generates a key pair.
 * @param {String} passphrase [optional] The passphrase for the private key [default: "test"].
 * @return {Object} Object containing the private `key`, the corresponding `publicKey` and its `fingerprint`.
 */
gpii.tests.iod.generateKeyPair = function (passphrase) {
    if (!gpii.tests.iod.keyPair) {
        if (!passphrase) {
            passphrase = "test";
        }

        var keyPair = crypto.generateKeyPairSync("rsa", {
            modulusLength: 4096,
            publicKeyEncoding: {
                type: "spki",
                format: "pem"
            },
            privateKeyEncoding: {
                type: "pkcs1",
                format: "pem",
                cipher: "aes-128-cbc",
                passphrase: passphrase
            }
        });

        // Include the passphrase
        keyPair.passphrase = passphrase;
        // signPackageData expects the private key to be `key`.
        keyPair.key = keyPair.privateKey;
        delete keyPair.privateKey;

        // Get the key (without the PEM header+trailer)
        var keyBinary = gpii.iodServer.packageFile.readPEM(keyPair.publicKey);
        // Generate the finger print
        keyPair.fingerprint = crypto.createHash("sha256").update(keyBinary).digest("base64");
        keyPair.passphrase = passphrase;
        gpii.tests.iod.keyPair = keyPair;
    }
    return gpii.tests.iod.keyPair;
};

/**
 * Creates the .morphic-packages file, from local-packages.json5 and the contents of ./packageData/.
 *
 * @param {String} inputFile The local-packages.json5 file.
 * @param {String} outputFile The output file, .morphic-packages.
 * @param {Object} keyPair The private and public key object.
 */
gpii.tests.iod.generateLocalPackages = function (inputFile, outputFile, keyPair) {
    var localPackages = json5.parse(fs.readFileSync(path.resolve(__dirname, inputFile)));

    // Add the files in the packageData directory
    var dir = path.join(__dirname, "packageData");
    fluid.each(fs.readdirSync(dir), function (packageDataFile) {
        var packageData = json5.parse(fs.readFileSync(path.join(dir, packageDataFile)));
        localPackages.packages[packageData.name] = {
            packageData: packageData
        };
    });

    // Replace the packageData objects with a serialised string with signature
    fluid.each(localPackages.packages, function (localPackage) {
        // If it's already a string, leave as-is
        if (typeof(localPackage.packageData) !== "string") {
            var signed = gpii.tests.iod.generateSignedData(localPackage.packageData, keyPair);
            localPackage.packageData = signed.string;
            if (!localPackage.packageDataSignature) {
                localPackage.packageDataSignature = signed.signature.toString("base64");
            }
        }
    });

    var outputPath = path.resolve(__dirname, outputFile);
    fs.writeFileSync(outputPath, json5.stringify(localPackages, null, "  "));

    // Create a file that exists.
    var packagesDir = path.join(path.dirname(outputPath), "packages");
    mkdirp.sync(packagesDir);
    fs.writeFileSync(path.join(packagesDir, "existing-file"), "this file exists");
};
