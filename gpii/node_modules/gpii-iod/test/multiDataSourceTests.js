/*
 * Tests for the multiDataSource component.
 *
 * Copyright 2019 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion");
var kettle = fluid.require("kettle");
kettle.loadTestingSupport();

var gpii = fluid.registerNamespace("gpii");

fluid.registerNamespace("gpii.tests.multiDataSource");

require("../src/multiDataSource.js");


fluid.defaults("gpii.tests.multiDataSource.dataSource", {
    gradeNames: ["kettle.dataSource"],
    readOnlyGrade: "gpii.tests.multiDataSource",

    components: {
        encoding: {
            type: "kettle.dataSource.encoding.none"
        }
    },
    invokers: {
        getImpl: {
            funcName: "gpii.tests.multiDataSource.getImpl",
            args: ["{that}", "{arguments}.0", "{arguments}.1"]
        }
    }
});

gpii.tests.multiDataSource.getImpl = function (that, options, directModel) {
    var result;
    var req = fluid.makeArray(directModel.request);

    if (req.indexOf(that.options.path) > -1 || directModel.request === "any") {
        result = {
            from: that.options.path
        };
    }

    return result ? fluid.toPromise(result) : fluid.promise().reject({notFound: that.options.path});
};


fluid.defaults("gpii.tests.multiDataSource.tests", {
    gradeNames: ["fluid.test.testEnvironment"],

    components: {
        multiDataSource: {
            type: "gpii.iod.multiDataSource"
        },
        tester: {
            type: "gpii.tests.multiDataSource.testCaseHolder"
        }
    }
});

fluid.defaults("gpii.tests.multiDataSource.testCaseHolder", {
    gradeNames: ["fluid.test.testCaseHolder"],
    modules: [{
        name: "multiDataSource",
        tests: [{
            expect: 1,
            name: "testing empty multiDataSource",
            sequence: [{
                task: "{multiDataSource}.get",
                args: [{request: "value"}],
                reject: "jqUnit.assert",
                rejectArgs: [
                    "multiDataSource.get() with no root data sources should reject"
                ]
            }]
        }, {
            expect: 3,
            name: "adding to multiDataSource",
            sequence: [{
                func: "jqUnit.assertEquals",
                args: [
                    "sortedDataSources member should be empty before adding one",
                    0,
                    "{multiDataSource}.sortedDataSources.length"
                ]
            }, {
                func: "{multiDataSource}.events.onNewDataSource.fire",
                args: ["gpii.tests.multiDataSource.dataSource", "first", 1]
            }, {
                func: "jqUnit.assertEquals",
                args: [
                    "sortedDataSources member should contain one item after adding it",
                    1,
                    "{multiDataSource}.sortedDataSources.length"
                ]
            }, {
                func: "{multiDataSource}.events.onNewDataSource.fire",
                // 3rd is added before the 2nd, to prove the priorities work
                args: ["gpii.tests.multiDataSource.dataSource", "third", 3]
            }, {
                func: "{multiDataSource}.events.onNewDataSource.fire",
                args: ["gpii.tests.multiDataSource.dataSource", "second", 2]
            }, {
                func: "jqUnit.assertEquals",
                args: [
                    "sortedDataSources member should contain two more items after adding the second and third",
                    3,
                    "{multiDataSource}.sortedDataSources.length"
                ]
            }]
        }, {
            expect: 12,
            name: "getting from multiDataSource",
            sequence: [{
                func: "jqUnit.assertEquals",
                args: [
                    "sortedDataSources member should be contain the items from the last test",
                    3,
                    "{multiDataSource}.sortedDataSources.length"
                ]
            }, {
                task: "{multiDataSource}.get",
                args: [{request: "first"}],
                resolve: "jqUnit.assertDeepEq",
                resolveArgs: [
                    "result from first source should be received for 'first'", {from: "first"}, "{arguments}.0"
                ]
            }, {
                task: "{multiDataSource}.get",
                args: [{request: "second"}],
                resolve: "jqUnit.assertDeepEq",
                resolveArgs: [
                    "result from second source should be received for 'second'", {from: "second"}, "{arguments}.0"
                ]
            }, {
                task: "{multiDataSource}.get",
                args: [{request: "third"}],
                resolve: "jqUnit.assertDeepEq",
                resolveArgs: [
                    "result from third source should be received for 'third'", {from: "third"}, "{arguments}.0"
                ]
            }, {
                task: "{multiDataSource}.get",
                args: [{request: "any"}],
                resolve: "jqUnit.assertDeepEq",
                resolveArgs: [
                    "result from first source should be received for 'any'", {from: "first"}, "{arguments}.0"
                ]
            }, {
                task: "{multiDataSource}.get",
                args: [{request: "none"}],
                reject: "jqUnit.assertDeepEq",
                rejectArgs: [
                    "reject from first source should be received for 'none'", {notFound: "first"}, "{arguments}.0"
                ]
            }, {
                // tests ordering
                task: "{multiDataSource}.get",
                args: [{request: ["first", "third"]}],
                resolve: "jqUnit.assertDeepEq",
                resolveArgs: [
                    "result from first source should be received for 'first or third'", {from: "first"}, "{arguments}.0"
                ]
            }, {
                // tests ordering, even if added later.
                task: "{multiDataSource}.get",
                args: [{request: ["second", "third"]}],
                resolve: "jqUnit.assertDeepEq",
                resolveArgs: [
                    "result from second source should be received for 'second or third'",
                    {from: "second"},
                    "{arguments}.0"
                ]
            }, {
                // Add a higher priority source
                func: "{multiDataSource}.events.onNewDataSource.fire",
                args: ["gpii.tests.multiDataSource.dataSource", "zeroth", 0]
            }, {
                // Check the newly added source is used first
                task: "{multiDataSource}.get",
                args: [{request: "any"}],
                resolve: "jqUnit.assertDeepEq",
                resolveArgs: [
                    "result from zeroth should be received for 'any'", {from: "zeroth"}, "{arguments}.0"
                ]
            }, {
                // Add a new source at the same priority as 'second'
                func: "{multiDataSource}.events.onNewDataSource.fire",
                args: ["gpii.tests.multiDataSource.dataSource", "new-second", 2]
            }, {
                // Check the newly added source is used - the same priority, but it's newer.
                task: "{multiDataSource}.get",
                args: [{request: ["new-second", "second", "third"]}],
                resolve: "jqUnit.assertDeepEq",
                resolveArgs: [
                    "result from before-second should be received for 'before-second or second'",
                    {from: "new-second"},
                    "{arguments}.0"
                ]
            }, {
                // Check the new source didn't break the higher priority source
                task: "{multiDataSource}.get",
                args: [{request: "any"}],
                resolve: "jqUnit.assertDeepEq",
                resolveArgs: [
                    "result from zeroth should be received for 'any' #2", {from: "zeroth"}, "{arguments}.0"
                ]
            }, {
                // Check the sorted list is in the right order
                func: "jqUnit.assertDeepEq",
                args: [
                    "Sorted data sources should be in the expected order",
                    [
                        "zeroth",
                        "first",
                        "new-second",
                        "second",
                        "third"
                    ],
                    "@expand:fluid.getMembers({multiDataSource}.sortedDataSources, options.path)"
                ]
            }]
        }, {
            name: "Removing data sources",
            expect: 2,
            sequence: [{
                func: "{multiDataSource}.sortedDataSources.2.destroy"
            }, {
                // Check the destroyed source isn't in the list.
                func: "jqUnit.assertDeepEq",
                args: [
                    "Destroyed data source should have been removed",
                    [
                        "zeroth",
                        "first",
                        // removed: "new-second",
                        "second",
                        "third"
                    ],
                    "@expand:fluid.getMembers({multiDataSource}.sortedDataSources, options.path)"
                ]
            }, {
                // Check things still work as expected, and no results from the removed source.
                task: "{multiDataSource}.get",
                args: [{request: ["new-second", "second", "third"]}],
                resolve: "jqUnit.assertDeepEq",
                resolveArgs: [
                    "result from second should be received for 'before-second or second', after removing before-second",
                    {from: "second"},
                    "{arguments}.0"
                ]
            }]
        }]
    }]
});

module.exports = kettle.test.bootstrap("gpii.tests.multiDataSource.tests");
