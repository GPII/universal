/*
 * IoD Tests - packages.
 *
 * Copyright 2019 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion");
var kettle = fluid.require("kettle");
kettle.loadTestingSupport();

var JSON5 = require("json5"),
    fs = require("fs"),
    path = require("path"),
    os = require("os");

var jqUnit = fluid.require("node-jqunit");
var gpii = fluid.registerNamespace("gpii");

fluid.registerNamespace("gpii.tests.iodPackages");

require("../index.js");

var teardowns = [];

jqUnit.module("gpii.tests.iodPackages", {
    teardown: function () {
        while (teardowns.length) {
            teardowns.pop()();
        }
    }
});

gpii.tests.iodPackages.getPackageDataTests = fluid.freezeRecursive([
    {
        id: "No matching package",
        request: {
            packageName: "package-not-exists"
        },
        expect: "reject"
    },
    {
        id: "variables resolved",
        request: {
            packageName: "env"
        },
        expect: {
            name: "env",
            test: process.env.PATH,
            packageType: "testPackageType1"
        }
    },
    {
        id: "Single language package",
        request: {
            packageName: "package1"
        },
        expect: JSON5.parse(fs.readFileSync(__dirname + "/packageData/package1.json5", "utf8"))
    },
    {
        id: "Single language package, with language specified",
        request: {
            packageName: "package1",
            language: "fr-FR"
        },
        expect: JSON5.parse(fs.readFileSync(__dirname + "/packageData/package1.json5", "utf8"))
    },
    {
        id: "Multi-language package, language not specified",
        request: {
            packageName: "languages"
        },
        expect: {
            "name": "languages",
            "packageType": "testPackageType1",
            "filename": "example.filename"
        }
    },
    {
        id: "Multi-language package, unknown language specified",
        request: {
            packageName: "languages",
            language: "xx-YY"
        },
        expect: {
            "name": "languages",
            "packageType": "testPackageType1",
            "filename": "example.filename"
        }
    },
    {
        id: "Multi-language package, unknown language, no country specified",
        request: {
            packageName: "languages",
            language: "xx"
        },
        expect: {
            "name": "languages",
            "packageType": "testPackageType1",
            "filename": "example.filename"
        }
    },
    {
        id: "Multi-language package, full language specified",
        request: {
            packageName: "languages",
            language: "es-ES"
        },
        expect: {
            "name": "languages",
            "packageType": "testPackageType1",
            "filename": "file.es-es",
            "language": "es-ES"
        }
    },
    {
        id: "Multi-language package, full language specified 2",
        request: {
            packageName: "languages",
            language: "es-MX"
        },
        expect: {
            "name": "languages",
            "packageType": "testPackageType1",
            "filename": "file.es-mx",
            "language": "es-MX"
        }
    },
    {
        id: "Multi-language package, no country specified",
        request: {
            packageName: "languages",
            language: "es"
        },
        expect: {
            "name": "languages",
            "packageType": "testPackageType1",
            "filename": "file.es",
            "language": "es"
        }
    },
    {
        id: "Multi-language package, unknown country specified",
        request: {
            packageName: "languages",
            language: "es-YY"
        },
        expect: {
            "name": "languages",
            "packageType": "testPackageType1",
            "filename": "file.es",
            "language": "es"
        }
    },
    {
        id: "Multi-language package, no country specified, no non-country package",
        request: {
            packageName: "languages",
            language: "zh"
        },
        expect: {
            "name": "languages",
            "packageType": "testPackageType1",
            "filename": "file.zh-cn",
            "language": "zh-CN"
        }
    },
    {
        id: "Multi-language package, unknown country specified, no non-country package",
        request: {
            packageName: "languages",
            language: "zh-YY"
        },
        expect: {
            "name": "languages",
            "packageType": "testPackageType1",
            "filename": "file.zh-cn",
            "language": "zh-CN"
        }
    }
]);

gpii.tests.iodPackages.resolvePackageTests = fluid.freezeRecursive([
    // Resolver
    {
        name: "environment",
        result: "${{environment}.PATH",
        expect: process.PATH
    },
    {
        name: "exists",
        result: "${{exists}./}",
        expect: true
    },
    {
        name: "exists (not)",
        result: "${{exists}./gpii-test/not/exist}",
        expect: false
    },
    {
        name: "this",
        anotherValue: "it works",
        result: "${{this}.anotherValue}",
        expect: "it works"
    },
    {
        name: "this (object)",
        anotherValue: {
            deepValue: "it works"
        },
        result: "${{this}.anotherValue}",
        expect: {
            deepValue: "it works"
        }
    },
    {
        name: "this (deep field)",
        anotherValue: {
            deepValue: "it works"
        },
        result: "${{this}.anotherValue.deepValue}",
        expect: "it works"
    },
    {
        name: "this (multiple)",
        first: "it works",
        second: "${{this}.first}",
        result: "${{this}.second}",
        expect: "it works"
    },
    {
        name: "this (multiple, reverse order)",
        result: "${{this}.second}",
        second: "${{this}.first}",
        first: "it works",
        expect: "it works"
    },
    {
        name: "unknown resolver",
        result: "${{stupid}}",
        expect: undefined
    },
    // Transforms
    {
        name: "basic transform",
        result: {
            transform: {
                type: "fluid.transforms.literalValue",
                input: "it works"
            }
        },
        expect: "it works"
    },
    {
        name: "basic transform, object result",
        result: {
            transform: {
                type: "fluid.transforms.literalValue",
                input: "it works",
                outputPath: "nested"
            }
        },
        expect: {
            nested: "it works"
        }
    },
    {
        name: "basic transform, null result",
        result: {
            transform: {
                type: "fluid.transforms.literalValue",
                input: null
            }
        },
        expect: null
    },
    {
        name: "literal transform",
        result: {
            literalValue: "it works"
        },
        expect: "it works"
    },
    {
        name: "transform, outer reference",
        otherValue: "it works",
        result: {
            transform: {
                type: "fluid.transforms.value",
                inputPath: "otherValue"
            }
        },
        expect: "it works"
    },
    {
        name: "transform, outer deep reference",
        otherValue: {
            nested: "it works"
        },
        result: {
            transform: {
                type: "fluid.transforms.value",
                inputPath: "otherValue.nested"
            }
        },
        expect: "it works"
    },
    {
        name: "transform, reference to transformed",
        otherValue: {
            transform: {
                type: "fluid.transforms.value",
                input: "it works"
            }
        },
        result: {
            transform: {
                type: "fluid.transforms.value",
                inputPath: "otherValue"
            }
        },
        expect: "it works"
    },
    {
        name: "transform, reference to transformed (looking ahead)",
        result: {
            transform: {
                type: "fluid.transforms.value",
                inputPath: "otherValue"
            }
        },
        otherValue: {
            transform: {
                type: "fluid.transforms.value",
                input: "it works"
            }
        },
        expect: "it works"
    },
    {
        name: "transform, self reference",
        result: {
            transform: {
                type: "fluid.transforms.value",
                inputPath: "value"
            }
        },
        expect: undefined
    },
    {
        name: "transform, circular reference",
        result: {
            transform: {
                type: "fluid.transforms.value",
                inputPath: "value2"
            }
        },
        value2: {
            transform: {
                type: "fluid.transforms.value",
                inputPath: "value3"
            }
        },
        value3: {
            transform: {
                type: "fluid.transforms.value",
                inputPath: "value"
            }
        },
        expect: undefined
    },
    {
        name: "resolving transformed value",
        result: "${{this}.value2}",
        value2: {
            transform: {
                type: "fluid.transforms.value",
                input: "it works"
            }
        },
        expect: "it works"
    },
    {
        name: "transforms operate on the resolved variables",
        result: {
            transform: {
                type: "fluid.transforms.condition",
                // will be true if it's not resolved
                condition: "${{exists}./does/not/exist1}",
                false: "it works",
                true: "hide the evidence"
            }
        },
        expect: "it works"
    }
]);

gpii.tests.iodPackages.checkInstalledTests = fluid.freezeRecursive([
    {
        name: "literal true",
        isInstalled: true,
        expect: true
    },
    {
        name: "literal false",
        isInstalled: false,
        expect: false
    },
    {
        name: "string true",
        isInstalled: "true",
        expect: true
    },
    {
        name: "string false",
        isInstalled: "false",
        expect: false
    },
    {
        name: "literal 1",
        isInstalled: 1,
        expect: true
    },
    {
        name: "literal 0",
        isInstalled: 0,
        expect: false
    },
    {
        name: "string 1",
        isInstalled: "1",
        expect: true
    },
    {
        name: "string 0",
        isInstalled: "0",
        expect: false
    },
    {
        name: "word string",
        isInstalled: "hello",
        expect: true
    },
    {
        name: "empty string",
        isInstalled: "",
        expect: false
    },
    {
        name: "null",
        isInstalled: null,
        expect: false
    },
    {
        name: "undefined",
        isInstalled: undefined,
        expect: false
    },
    {
        name: "no value",
        expect: false
    },
    {
        name: "empty object",
        isInstalled: {},
        expect: false
    },
    {
        name: "object",
        isInstalled: {something: "hello"},
        expect: false
    },
    {
        name: "object containing isInstalled:true",
        isInstalled: {isInstalled: true},
        expect: true
    },
    {
        name: "object containing isInstalled:0",
        isInstalled: {isInstalled: "0"},
        expect: false
    }
]);

fluid.defaults("gpii.tests.iodPackages", {
    gradeNames: [ "gpii.iod" ],
    distributeOptions: {
        packageDataSource: {
            record: {
                gradeNames: ["kettle.dataSource.file.moduleTerms"],
                path: __dirname + "/packageData/%packageName.json5",
                termMap: {
                    "packageName": "%packageName"
                }
            },
            target: "{that packages packageDataSource}.options"
        }
    },
    invokers: {
        readInstallations: "fluid.identity",
        writeInstallation: "fluid.identity"
    }
});

jqUnit.test("test the 'exists' resolver function", function () {

    // Test it works on a non-existent file
    var result = gpii.iod.existsResolver(path.join(os.tmpdir(), "not-exist" + Math.random()));
    jqUnit.assertFalse("existsResolver should return false for a non-existing file", result);

    // Test it works on an existing file
    var result2 = gpii.iod.existsResolver(__filename);
    jqUnit.assertTrue("existsResolver should return true for an existing file", result2);

    // Test it works on an existing directory
    var result3 = gpii.iod.existsResolver(__dirname);
    jqUnit.assertTrue("existsResolver should return true for an existing directory", result3);

    // Test environment variables are expanded
    var result4 = gpii.iod.existsResolver("%HOME%");
    jqUnit.assertTrue("existsResolver should return true, with an environment variable", result4);
    process.env.GPII_TEST_RESOLVER1 = __dirname;
    process.env.GPII_TEST_RESOLVER2 = path.basename(__filename, "js");
    var result5 = gpii.iod.existsResolver("%GPII_TEST_RESOLVER1%/%GPII_TEST_RESOLVER2%js");
    jqUnit.assertTrue("existsResolver should return true, with multiple environment variables", result5);
});

jqUnit.test("test the package resolver", function () {

    var iod = gpii.tests.iodPackages();

    fluid.each(gpii.tests.iodPackages.resolvePackageTests, function (test) {

        var current = test;
        // Resolve the package more than once, to show it can be re-resolved.
        for (var i = 1; i <= 3; i++) {
            var resolved = iod.packages.resolvePackage(current);
            var suffix = " - " + test.name + " (pass " + i + ")";

            jqUnit.assertDeepEq("return of resolvePackage should contain the original package" + suffix,
                test, resolved._original);

            jqUnit.assertDeepEq("resolvePackage should return the expected value" + suffix,
                test.expect, resolved.result);

            current = resolved;
        }
    });

    iod.destroy();
});

// Test getPackageData returns correct information
jqUnit.asyncTest("test getPackageData", function () {

    var tests = gpii.tests.iodPackages.getPackageDataTests;
    jqUnit.expect(tests.length * 2);

    var iod = gpii.tests.iodPackages();

    var testIndex = -1;
    var nextTest = function () {
        if (++testIndex >= tests.length) {
            jqUnit.start();
            return;
        }

        var test = tests[testIndex];
        var suffix = " - test:" + test.id;

        fluid.log("getPackage: " + test.request.packageName + ", " + test.request.language);

        var p = iod.packages.getPackageData(test.request);

        jqUnit.assertTrue("getPackageData must return a promise" + suffix, fluid.isPromise(p));

        p.then(function (packageData) {
            delete packageData.languages;
            delete packageData._original;
            jqUnit.assertDeepEq("packageData must match expected" + suffix, test.expect, packageData);
            nextTest();
        }, function (e) {
            if (test.expect !== "reject") {
                fluid.log(e);
            }
            jqUnit.assertEquals("packageData must only reject if expected" + suffix, test.expect, "reject");
            nextTest();
        });

    };

    nextTest();
});

// Test checkInstalled works
jqUnit.test("test checkInstalled", function () {
    var iod = gpii.tests.iodPackages();

    fluid.each(gpii.tests.iodPackages.checkInstalledTests, function (test) {
        var result = iod.packages.checkInstalled(test);
        jqUnit.assertEquals("checkInstalled should return the expected result - " + test.name, test.expect, result);
    });

    // Ensure the same package can return a different result - ie, the result is live.
    var testEnv = "_gpii_test_checkInstalled";
    var testPackage = iod.packages.resolvePackage({
        name: "checkInstalledTest",
        isInstalled: "${{environment}." + testEnv + "}"
    });

    var testValues = [ false, true, false, false, true, true, false ];
    fluid.each(testValues, function (value, index) {
        // Change what isInstalled resolves to.
        process.env[testEnv] = value.toString();

        var result = iod.packages.checkInstalled(testPackage);

        jqUnit.assertEquals("checkInstalled should return the expected result - index=" + index, value, result);
    });

    delete process.env[testEnv];
});
