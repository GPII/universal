/*
 * IoD Tests - packages.
 *
 * Copyright 2019 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion");
var kettle = fluid.require("kettle");
kettle.loadTestingSupport();

var json5 = require("json5"),
    fs = require("fs"),
    path = require("path"),
    os = require("os");

var jqUnit = fluid.require("node-jqunit");
var gpii = fluid.registerNamespace("gpii");

fluid.registerNamespace("gpii.tests.iodPackages");

require("./common.js");
require("../index.js");

fluid.defaults("gpii.tests.iodPackages.tests", {
    gradeNames: ["fluid.test.testEnvironment"],

    components: {
        packages: {
            type: "gpii.iod.packages",
            options: {
                events: {
                    onServerFound: null,
                    onLocalPackagesFound: null
                },
                trustedKeys: {
                    packagesTest: "{tests}.options.keyPair.fingerprint"
                },
                listeners: {
                    "onCreate.generateData": {
                        funcName: "gpii.tests.iod.generateLocalPackages",
                        args: [
                            "local-packages.json5",
                            "localPackages/.morphic-packages",
                            "{tests}.options.keyPair"
                        ]
                    }
                }
            }
        },
        tester: {
            type: "gpii.tests.iodPackages.testCaseHolder"
        }
    },
    keyPair: "@expand:gpii.tests.iod.generateKeyPair()"
});

fluid.defaults("gpii.tests.iodPackages.testCaseHolder", {
    gradeNames: ["fluid.test.testCaseHolder"],
    modules: [{
        name: "exists resolver tests",
        tests: [{
            expect: 5,
            name: "testExistsResolver",
            sequence: [{
                func: "gpii.tests.iodPackages.testExistsResolver"
            }]
        }]
    }, {
        name: "resolvePackage() tests",
        tests: [{
            name: "testing resolvePackage()",
            sequence: [{
                func: "gpii.tests.iodPackages.testResolvePackage",
                args: ["{packages}", "@expand:fluid.getGlobalValue(gpii.tests.iodPackages.resolvePackageTests)"]
            }]
        }]
    }, {
        name: "checkInstalled() tests",
        tests: [{
            name: "testing checkInstalled()",
            sequence: [{
                func: "gpii.tests.iodPackages.testCheckInstalled",
                args: ["{packages}", "{that}.options.testData.checkInstalledTests"]
            }]
        }]
    }, {
        name: "PackageData tests",
        tests: [{
            name: "testing with no data source",
            expect: 1,
            sequence: [{
                task: "{packages}.getPackageData",
                args: [{
                    packageName: "some-package"
                }],
                reject: "jqUnit.assertEquals",
                rejectArgs: [
                    "Should reject with the expected error",
                    "no root data sources",
                    "{arguments}.0.error.message"
                ]
            }]
        }, {
            name: "adding a data source",
            expect: 1,
            sequence: [{
                func: "{packages}.events.onLocalPackagesFound.fire",
                args: [path.join(__dirname, "localPackages")]
            }, {
                func: "jqUnit.assertEquals",
                args: [
                    "Packages should have a data source",
                    1,
                    "{packages}.dataSource.sortedDataSources.length"
                ]
            }]
        }, {
            name: "testing getPackageData()",
            expect: 1,
            sequence: [{
                task: "gpii.tests.iodPackages.testGetPackageData",
                args: ["{packages}", "{that}.options.testData.getPackageDataTests"],
                resolve: "jqUnit.assert"
            }]
        }]
    }],
    testData: {
        checkInstalledTests: [
            {
                name: "literal true",
                isInstalled: true,
                expect: true
            },
            {
                name: "literal false",
                isInstalled: false,
                expect: false
            },
            {
                name: "string true",
                isInstalled: "true",
                expect: true
            },
            {
                name: "string false",
                isInstalled: "false",
                expect: false
            },
            {
                name: "literal 1",
                isInstalled: 1,
                expect: true
            },
            {
                name: "literal 0",
                isInstalled: 0,
                expect: false
            },
            {
                name: "string 1",
                isInstalled: "1",
                expect: true
            },
            {
                name: "string 0",
                isInstalled: "0",
                expect: false
            },
            {
                name: "word string",
                isInstalled: "hello",
                expect: true
            },
            {
                name: "empty string",
                isInstalled: "",
                expect: false
            },
            {
                name: "null",
                isInstalled: null,
                expect: false
            },
            {
                name: "undefined",
                isInstalled: undefined,
                expect: false
            },
            {
                name: "no value",
                expect: false
            },
            {
                name: "empty object",
                isInstalled: {},
                expect: false
            },
            {
                name: "object",
                isInstalled: {something: "hello"},
                expect: false
            },
            {
                name: "object containing isInstalled:true",
                isInstalled: {isInstalled: true},
                expect: true
            },
            {
                name: "object containing isInstalled:0",
                isInstalled: {isInstalled: "0"},
                expect: false
            }
        ],
        getPackageDataTests: [
            {
                id: "No matching package",
                request: {
                    packageName: "package-not-exists"
                },
                expect: "reject"
            },
            {
                id: "variables resolved",
                request: {
                    packageName: "env"
                },
                expect: {
                    name: "env",
                    test: process.env.PATH,
                    packageType: "testPackageType1"
                }
            },
            {
                id: "Single language package",
                request: {
                    packageName: "package1"
                },
                expect: json5.parse(fs.readFileSync(__dirname + "/packageData/package1.json5", "utf8"))
            },
            {
                id: "Single language package, with language specified",
                request: {
                    packageName: "package1",
                    language: "fr-FR"
                },
                expect: json5.parse(fs.readFileSync(__dirname + "/packageData/package1.json5", "utf8"))
            },
            {
                id: "Multi-language package, language not specified",
                request: {
                    packageName: "languages"
                },
                expect: {
                    "name": "languages",
                    "packageType": "testPackageType1",
                    "filename": "example.filename"
                }
            },
            {
                id: "Multi-language package, unknown language specified",
                request: {
                    packageName: "languages",
                    language: "xx-YY"
                },
                expect: {
                    "name": "languages",
                    "packageType": "testPackageType1",
                    "filename": "example.filename"
                }
            },
            {
                id: "Multi-language package, unknown language, no country specified",
                request: {
                    packageName: "languages",
                    language: "xx"
                },
                expect: {
                    "name": "languages",
                    "packageType": "testPackageType1",
                    "filename": "example.filename"
                }
            },
            {
                id: "Multi-language package, full language specified",
                request: {
                    packageName: "languages",
                    language: "es-ES"
                },
                expect: {
                    "name": "languages",
                    "packageType": "testPackageType1",
                    "filename": "file.es-es",
                    "language": "es-ES"
                }
            },
            {
                id: "Multi-language package, full language specified 2",
                request: {
                    packageName: "languages",
                    language: "es-MX"
                },
                expect: {
                    "name": "languages",
                    "packageType": "testPackageType1",
                    "filename": "file.es-mx",
                    "language": "es-MX"
                }
            },
            {
                id: "Multi-language package, no country specified",
                request: {
                    packageName: "languages",
                    language: "es"
                },
                expect: {
                    "name": "languages",
                    "packageType": "testPackageType1",
                    "filename": "file.es",
                    "language": "es"
                }
            },
            {
                id: "Multi-language package, unknown country specified",
                request: {
                    packageName: "languages",
                    language: "es-YY"
                },
                expect: {
                    "name": "languages",
                    "packageType": "testPackageType1",
                    "filename": "file.es",
                    "language": "es"
                }
            },
            {
                id: "Multi-language package, no country specified, no non-country package",
                request: {
                    packageName: "languages",
                    language: "zh"
                },
                expect: {
                    "name": "languages",
                    "packageType": "testPackageType1",
                    "filename": "file.zh-cn",
                    "language": "zh-CN"
                }
            },
            {
                id: "Multi-language package, unknown country specified, no non-country package",
                request: {
                    packageName: "languages",
                    language: "zh-YY"
                },
                expect: {
                    "name": "languages",
                    "packageType": "testPackageType1",
                    "filename": "file.zh-cn",
                    "language": "zh-CN"
                }
            }
        ]
    }
});

// This test data needs to be declared outside a component, to avoid resolving the `${{values}}` don't get resolved.
gpii.tests.iodPackages.resolvePackageTests = [
    // Resolver
    {
        name: "environment",
        result: "${{environment}.PATH}",
        expect: process.env.PATH
    },
    {
        name: "exists",
        result: "${{exists}./}",
        expect: true
    },
    {
        name: "exists (not)",
        result: "${{exists}./gpii-test/not/exist}",
        expect: false
    },
    {
        name: "this",
        anotherValue: "it works",
        result: "${{this}.anotherValue}",
        expect: "it works"
    },
    {
        name: "this (object)",
        anotherValue: {
            deepValue: "it works"
        },
        result: "${{this}.anotherValue}",
        expect: {
            deepValue: "it works"
        }
    },
    {
        name: "this (deep field)",
        anotherValue: {
            deepValue: "it works"
        },
        result: "${{this}.anotherValue.deepValue}",
        expect: "it works"
    },
    {
        name: "this (multiple)",
        first: "it works",
        second: "${{this}.first}",
        result: "${{this}.second}",
        expect: "it works"
    },
    {
        name: "this (multiple, reverse order)",
        result: "${{this}.second}",
        second: "${{this}.first}",
        first: "it works",
        expect: "it works"
    },
    {
        name: "unknown resolver",
        result: "${{stupid}}",
        expect: undefined
    },
    // Transforms
    {
        name: "basic transform",
        result: {
            transform: {
                type: "fluid.transforms.literalValue",
                input: "it works"
            }
        },
        expect: "it works"
    },
    {
        name: "basic transform, object result",
        result: {
            transform: {
                type: "fluid.transforms.literalValue",
                input: "it works",
                outputPath: "nested"
            }
        },
        expect: {
            nested: "it works"
        }
    },
    {
        name: "basic transform, null result",
        result: {
            transform: {
                type: "fluid.transforms.literalValue",
                input: null
            }
        },
        expect: null
    },
    {
        name: "literal transform",
        result: {
            literalValue: "it works"
        },
        expect: "it works"
    },
    {
        name: "transform, outer reference",
        otherValue: "it works",
        result: {
            transform: {
                type: "fluid.transforms.value",
                inputPath: "otherValue"
            }
        },
        expect: "it works"
    },
    {
        name: "transform, outer deep reference",
        otherValue: {
            nested: "it works"
        },
        result: {
            transform: {
                type: "fluid.transforms.value",
                inputPath: "otherValue.nested"
            }
        },
        expect: "it works"
    },
    {
        name: "transform, reference to transformed",
        otherValue: {
            transform: {
                type: "fluid.transforms.value",
                input: "it works"
            }
        },
        result: {
            transform: {
                type: "fluid.transforms.value",
                inputPath: "otherValue"
            }
        },
        expect: "it works"
    },
    {
        name: "transform, reference to transformed (looking ahead)",
        result: {
            transform: {
                type: "fluid.transforms.value",
                inputPath: "otherValue"
            }
        },
        otherValue: {
            transform: {
                type: "fluid.transforms.value",
                input: "it works"
            }
        },
        expect: "it works"
    },
    {
        name: "transform, self reference",
        result: {
            transform: {
                type: "fluid.transforms.value",
                inputPath: "value"
            }
        },
        expect: undefined
    },
    {
        name: "transform, circular reference",
        result: {
            transform: {
                type: "fluid.transforms.value",
                inputPath: "value2"
            }
        },
        value2: {
            transform: {
                type: "fluid.transforms.value",
                inputPath: "value3"
            }
        },
        value3: {
            transform: {
                type: "fluid.transforms.value",
                inputPath: "value"
            }
        },
        expect: undefined
    },
    {
        name: "resolving transformed value",
        result: "${{this}.value2}",
        value2: {
            transform: {
                type: "fluid.transforms.value",
                input: "it works"
            }
        },
        expect: "it works"
    },
    {
        name: "transforms operate on the resolved variables",
        result: {
            transform: {
                type: "fluid.transforms.condition",
                // will be true if it's not resolved
                condition: "${{exists}./does/not/exist1}",
                false: "it works",
                true: "hide the evidence"
            }
        },
        expect: "it works"
    }
];

/**
 * Tests for existsResolver().
 */
gpii.tests.iodPackages.testExistsResolver = function () {

    // Test it works on a non-existent file
    var result = gpii.iod.existsResolver(path.join(os.tmpdir(), "not-exist" + Math.random()));
    jqUnit.assertFalse("existsResolver should return false for a non-existing file", result);

    // Test it works on an existing file
    var result2 = gpii.iod.existsResolver(__filename);
    jqUnit.assertTrue("existsResolver should return true for an existing file", result2);

    // Test it works on an existing directory
    var result3 = gpii.iod.existsResolver(__dirname);
    jqUnit.assertTrue("existsResolver should return true for an existing directory", result3);

    // Test environment variables are expanded
    var result4 = gpii.iod.existsResolver("%HOME%");
    jqUnit.assertTrue("existsResolver should return true, with an environment variable", result4);
    process.env.GPII_TEST_RESOLVER1 = __dirname;
    process.env.GPII_TEST_RESOLVER2 = path.basename(__filename, "js");
    var result5 = gpii.iod.existsResolver("%GPII_TEST_RESOLVER1%/%GPII_TEST_RESOLVER2%js");
    jqUnit.assertTrue("existsResolver should return true, with multiple environment variables", result5);
};

/**
 * Tests that the resovlers and tranformations within a packageData object get applied.
 * @param {Component} packages The gpii.iod.packages instance.
 * @param {Array<Object>} resolvePackageTests The tests.
 */
gpii.tests.iodPackages.testResolvePackage = function (packages, resolvePackageTests) {
    jqUnit.expect(resolvePackageTests.length * 2 * 3);
    fluid.each(resolvePackageTests, function (test) {

        var current = test;
        // Resolve the package more than once, to show it can be re-resolved.
        for (var i = 1; i <= 3; i++) {
            var resolved = packages.resolvePackage(current);
            var suffix = " - " + test.name + " (pass " + i + ")";

            jqUnit.assertDeepEq("return of resolvePackage should contain the original package" + suffix,
                test, resolved._original);

            jqUnit.assertDeepEq("resolvePackage should return the expected value" + suffix,
                test.expect, resolved.result);

            current = resolved;
        }
    });
};

/**
 * Tests the checkInstalled() function.
 * @param {Component} packages The gpii.iod.packages instance.
 * @param {Array<Object>} checkInstalledTests The tests.
 */
gpii.tests.iodPackages.testCheckInstalled = function (packages, checkInstalledTests) {
    // Run the canned tests.
    jqUnit.expect(checkInstalledTests.length);
    fluid.each(checkInstalledTests, function (test) {
        var result = packages.checkInstalled(test);
        jqUnit.assertEquals("checkInstalled should return the expected result - " + test.name, test.expect, result);
    });

    // Create a package which uses an environment variable to determine if it's installed.
    var testEnv = "_gpii_test_checkInstalled";
    var testPackage = packages.resolvePackage({
        name: "checkInstalledTest",
        isInstalled: "${{environment}." + testEnv + "}"
    });

    // Ensure the same package can return a different result - ie, the result is live.
    var testValues = [ false, true, false, false, true, true, false ];
    jqUnit.expect(testValues.length);
    fluid.each(testValues, function (value, index) {
        // Change what isInstalled should resolve to.
        process.env[testEnv] = value.toString();

        var result = packages.checkInstalled(testPackage);

        jqUnit.assertEquals("checkInstalled should return the expected result - index=" + index, value, result);
    });

    delete process.env[testEnv];
};

gpii.tests.iodPackages.testGetPackageData = function (packages, tests) {

    var promise = fluid.promise();

    jqUnit.expect(tests.length * 2);

    var testIndex = -1;
    var nextTest = function () {
        if (++testIndex >= tests.length) {
            promise.resolve();
            return;
        }

        var test = tests[testIndex];
        var suffix = " - test:" + test.id;

        fluid.log("getPackage: " + test.request.packageName + ", " + test.request.language);

        var p = packages.getPackageData(test.request);

        jqUnit.assertTrue("getPackageData must return a promise" + suffix, fluid.isPromise(p));

        p.then(function (packageData) {
            // Remove some fields that were added, so it can be compared directly with the file it came from.
            delete packageData.languages;
            delete packageData._original;
            delete packageData.publicKey;

            jqUnit.assertDeepEq("packageData must match expected" + suffix, test.expect, packageData);

            nextTest();
        }, function (e) {
            if (test.expect !== "reject") {
                fluid.log(e);
            }
            jqUnit.assertEquals("packageData must only reject if expected" + suffix, test.expect, "reject");
            nextTest();
        });

    };

    nextTest();
    return promise;
};

module.exports = kettle.test.bootstrap("gpii.tests.iodPackages.tests");
