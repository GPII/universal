/*
 * IoD Tests.
 *
 * Copyright 2018 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var os = require("os"),
    fs = require("fs"),
    path = require("path"),
    crypto = require("crypto");

var fluid = require("infusion");
var kettle = fluid.require("kettle");
kettle.loadTestingSupport();
var jqUnit = fluid.require("node-jqunit");
var gpii = fluid.registerNamespace("gpii");

fluid.registerNamespace("gpii.tests.iodInstaller");

require("../index.js");

gpii.tests.iodInstaller.teardowns = [];

jqUnit.module("gpii.tests.iodInstaller", {
    teardown: function () {
        while (gpii.tests.iodInstaller.teardowns.length) {
            gpii.tests.iodInstaller.teardowns.pop()();
        }
    }
});

gpii.tests.iodInstaller.executeCommandTests = fluid.freezeRecursive([
    {
        id: "command only",
        command: "command",
        expect: {
            funcName: "startProcess",
            command: "command",
            args: [],
            options: undefined
        }
    },
    {
        id: "command + args",
        command: "command",
        args: ["arg1", "arg2", "arg3"],
        expect: {
            funcName: "startProcess",
            command: "command",
            args: ["arg1", "arg2", "arg3"],
            options: undefined
        }
    },
    {
        id: "args in options",
        command: "command",
        args: undefined,
        execOptions: {
            args: ["arg1", "arg2", "arg3"]
        },
        expect: {
            funcName: "startProcess",
            command: "command",
            args: ["arg1", "arg2", "arg3"],
            options: undefined
        }
    },
    {
        id: "command in options",
        command: undefined,
        args: undefined,
        execOptions: {
            command: "command",
            args: ["arg1", "arg2", "arg3"]
        },
        expect: {
            funcName: "startProcess",
            command: "command",
            args: ["arg1", "arg2", "arg3"],
            options: undefined
        }
    },
    {
        id: "command + args in options, overridden",
        command: "command",
        args: ["arg1", "arg2", "arg3"],
        execOptions: {
            command: "unexpected",
            args: ["unexpected1"]
        },
        expect: {
            funcName: "startProcess",
            command: "command",
            args: ["arg1", "arg2", "arg3"],
            options: undefined
        }
    },
    {
        id: "no command",
        command: undefined,
        args: ["arg1", "arg2", "arg3"],
        execOptions: {
            command: undefined,
            args: ["unexpected1"]
        },
        expect: {
            reject: true
        }
    },
    {
        id: "expand",
        command: "$(value)",
        args: ["a$(value)", "$(value2.value3)", "$(nothing?expected3)", "x $(nothing)", "y $(nothing?)"],
        execOptions: {
        },
        installation: {
            value: "expected",
            value2: {
                value3: "expected2"
            }
        },
        expect: {
            funcName: "startProcess",
            command: "expected",
            args: ["aexpected", "expected2", "expected3", null, "y "],
            options: undefined
        }
    },
    {
        id: "expand (options)",
        command: undefined,
        args: undefined,
        execOptions: {
            command: "$(value)",
            args: ["a$(value)", "$(value2.value3)", "$(nothing?expected3)", "x $(nothing)", "y $(nothing?)"]
        },
        installation: {
            value: "expected",
            value2: {
                value3: "expected2"
            }
        },
        expect: {
            funcName: "startProcess",
            command: "expected",
            args: ["aexpected", "expected2", "expected3", null, "y "],
            options: undefined
        }
    },
    {
        id: "elevated",
        command: "command $(value)",
        args: undefined,
        execOptions: {
            args: ["$(value)", "arg2"],
            elevate: true
        },
        installation: {
            value: "expected"
        },
        expect: {
            funcName: "startElevatedProcess",
            command: "command expected",
            args: ["expected", "arg2"],
            options: {desktop: undefined}
        }
    },
    {
        id: "elevated (desktop)",
        command: "command $(value)",
        args: undefined,
        execOptions: {
            args: ["$(value)", "arg2"],
            elevate: true,
            desktop: true
        },
        installation: {
            value: "expected"
        },
        expect: {
            funcName: "startElevatedProcess",
            command: "command expected",
            args: ["expected", "arg2"],
            options: {desktop: true}
        }
    }
]);

fluid.defaults("gpii.tests.iodInstaller.dummyInstaller", {
    gradeNames: ["fluid.component", "gpii.iod.packageInstaller"],

    invokers: {
        initialise: "fluid.identity",
        downloadInstaller: "fluid.identity",
        checkPackage: "fluid.identity",
        prepareInstall: "fluid.identity",
        installPackage: "fluid.identity",
        cleanup: "fluid.identity",
        startApplication: "fluid.identity",
        uninstallPackage: "fluid.identity",
        stopApplication: "fluid.identity",
        installComplete: "fluid.identity",
        uninstallComplete: "fluid.identity",
        executeCommand: "fluid.identity"
    }
});
fluid.defaults("gpii.tests.iodInstaller.loggingInstaller", {
    gradeNames: ["fluid.component", "gpii.iod.packageInstaller"],

    invokers: {
        initialise: "gpii.tests.iodInstaller.stage({that}, initialise)",
        downloadInstaller: "gpii.tests.iodInstaller.stage({that}, downloadInstaller)",
        checkPackage: "gpii.tests.iodInstaller.stage({that}, checkPackage)",
        prepareInstall: "gpii.tests.iodInstaller.stage({that}, prepareInstall)",
        installPackage: "gpii.tests.iodInstaller.stage({that}, installPackage)",
        cleanup: "gpii.tests.iodInstaller.stage({that}, cleanup)",
        startApplication: "gpii.tests.iodInstaller.stage({that}, startApplication)",
        uninstallPackage: "gpii.tests.iodInstaller.stage({that}, uninstallPackage)",
        stopApplication: "gpii.tests.iodInstaller.stage({that}, stopApplication)",
        installComplete: "gpii.tests.iodInstaller.stage({that}, installComplete)",
        uninstallComplete: "gpii.tests.iodInstaller.stage({that}, uninstallComplete)",
        executeCommand: "gpii.tests.iodInstaller.stage({that}, execute, {arguments}.0.command, {arguments}.0.args.0, {arguments}.0.args.1)"
    }
});

gpii.tests.iodInstaller.stage = function (that) {
    that.stages.push(fluid.makeArray(arguments).splice(1).join(","));
};

gpii.tests.iodInstaller.installStages = [
    "initialise",
    "downloadInstaller",
    "checkPackage",
    "prepareInstall",
    "installPackage",
    "cleanup",
    "installComplete",
    "startApplication"
];

gpii.tests.iodInstaller.uninstallStages = [
    "stopApplication",
    "uninstallPackage",
    "cleanup",
    "uninstallComplete"
];

// Test startInstaller starts the installation pipe-line.
jqUnit.asyncTest("test installation pipe-line", function () {
    var testStages = function (packageData, expectInstall, expectUninstall) {
        jqUnit.expect(2);

        var installer = gpii.tests.iodInstaller.loggingInstaller();
        installer.stages = [];
        installer.packageData = packageData;
        installer.installation = {
            packageData: packageData
        };

        var promise = fluid.promise();

        installer.startInstaller({}).then(function () {
            var expect = expectInstall;

            jqUnit.assertDeepEq("All stages of the installation should be called in order.", expect, installer.stages);

            installer.stages = [];
            installer.startUninstaller().then(function () {
                var expect = expectUninstall;

                jqUnit.assertDeepEq("All stages of the uninstallation should be called in order.", expect, installer.stages);
                promise.resolve();
            });
        }, promise.reject);

        promise.then(function () {
            installer.destroy();
        });

        return promise;
    };

    var work = [
        function () {
            fluid.log("Testing stages");
            return testStages({}, gpii.tests.iodInstaller.installStages, gpii.tests.iodInstaller.uninstallStages);
        },
        function () {
            // Test that the "packageData.installCommands.XX:before" and "XX:after" commands (installation) get invoked.
            fluid.log("Testing stages with :before and :after commands");
            var packageData = {
                installCommands: {},
                uninstallCommands: {}
            };
            // install commands
            fluid.each(gpii.tests.iodInstaller.installStages, function (stage) {
                packageData.installCommands[stage + ":before"] = {
                    command: "install",
                    args: ["before", stage]
                };
                packageData.installCommands[stage + ":after"] = {
                    command: "install",
                    args: ["after", stage]
                };
            });
            var expectInstall = [
                "execute,install,before,initialise",
                "initialise",
                "execute,install,after,initialise",
                "downloadInstaller",
                "checkPackage",
                "execute,install,before,prepareInstall",
                "prepareInstall",
                "execute,install,after,prepareInstall",
                "installPackage",
                "execute,install,before,cleanup",
                "cleanup",
                "execute,install,after,cleanup",
                "installComplete",
                "execute,install,before,startApplication",
                "startApplication",
                "execute,install,after,startApplication"
            ];
            return testStages(packageData, expectInstall, gpii.tests.iodInstaller.uninstallStages);
        },
        function () {
            // ":before" and ":after commands (uninstallation)
            fluid.log("Testing stages with :before and :after commands - uninstallation");
            var packageData = {
                installCommands: {},
                uninstallCommands: {}
            };

            // uninstall commands
            fluid.each(gpii.tests.iodInstaller.uninstallStages, function (stage) {
                packageData.uninstallCommands[stage + ":before"] = {
                    command: "uninstall",
                    args: ["before", stage]
                };
                packageData.uninstallCommands[stage + ":after"] = {
                    command: "uninstall",
                    args: ["after", stage]
                };
            });
            var expectUninstall = [
                "execute,uninstall,before,stopApplication",
                "stopApplication",
                "execute,uninstall,after,stopApplication",
                "execute,uninstall,before,uninstallPackage",
                "uninstallPackage",
                "execute,uninstall,after,uninstallPackage",
                "execute,uninstall,before,cleanup",
                "cleanup",
                "execute,uninstall,after,cleanup",
                "execute,uninstall,before,uninstallComplete",
                "uninstallComplete",
                "execute,uninstall,after,uninstallComplete"
            ];
            return testStages(packageData, gpii.tests.iodInstaller.installStages, expectUninstall);
        }
    ];

    fluid.promise.sequence(work).then(function () {
        jqUnit.start();
    }, jqUnit.fail);
});

gpii.tests.iodInstaller.sha512 = function (content) {
    return crypto.createHash("sha512").update(content).digest("hex");
};

// Test the file download
jqUnit.asyncTest("test file download", function () {

    var skipSSL = !!process.env.GPII_QUICKTEST;

    gpii.tests.iodInstaller.downloadTests = fluid.freezeRecursive([
        {
            url: "https://raw.githubusercontent.com/GPII/universal/108be0f5f0377eaec9100c1926647e7550efc2ea/gpii.js",
            expect: "969125ff55aac6237549f04d0f0307a54bbfbec1d9d9c742ff2129c16aef44f471a406c9ba8dcc28bf9d5855166384819c728d375ba0a03167c2eb45fbd9e3c0"
        },
        {
            url: "https://gpii-test.invalid",
            expect: "reject"
        },
        // Certificate problems
        {
            url: "https://badssl.com",
            expect: "resolve"
        },
        {
            url: "https://expired.badssl.com/",
            expect: "reject"
        },
        {
            url: "https://wrong.host.badssl.com/",
            expect: "reject"
        },
        {
            url: "https://self-signed.badssl.com/",
            expect: "reject"
        },
        {
            url: "https://untrusted-root.badssl.com/",
            expect: "reject"
        },
        // Prohibited ciphers
        {
            url: "https://rc4-md5.badssl.com/",
            expect: "reject"
        },
        {
            url: "https://rc4.badssl.com/",
            expect: "reject"
        },
        {
            url: "https://3des.badssl.com/",
            expect: "reject"
        },
        {
            url: "https://null.badssl.com/",
            expect: "reject"
        },
        {
            // Unopened port (hopefully)
            url: "https://127.0.0.1:51749",
            expect: "reject"
        },
        // Local file tests
        {
            url: "file://" + __filename,
            expect: gpii.tests.iodInstaller.sha512(fs.readFileSync(__filename))
        },
        {
            url: "file://" + __filename + "?offset=20",
            expect: gpii.tests.iodInstaller.sha512(fs.readFileSync(__filename, "utf8").substr(20))
        },
        {
            url: "file://" + __dirname + "/no-such-file",
            expect: "reject"
        }

    ]);

    var filePrefix = path.join(os.tmpdir(), "gpii-test-download" + Math.random().toString(36) + "-");

    var files = [];
    // Remove all temporary files.
    gpii.tests.iodInstaller.teardowns.push(function () {
        fluid.each(files, function (file) {
            try {
                fs.unlinkSync(file);
            } catch (e) {
                // ignore.
            }
        });
    });

    var tests = gpii.tests.iodInstaller.downloadTests;


    jqUnit.expect(tests.length * 4);


    var testIndex = -1;
    var nextTest = function () {
        if (++testIndex >= tests.length) {
            jqUnit.start();
            return;
        }

        var test = tests[testIndex];
        var suffix = " - test " + testIndex + "(" + test.url + ")";

        if (skipSSL && test.url.indexOf("badssl.com") > -1) {
            fluid.log("Skipping SSL test" + suffix);
            jqUnit.expect(-4);
            nextTest();
        } else {

            var outFile = filePrefix + testIndex;
            files.push(outFile);

            var p = gpii.iod.fileDownload(test.url, outFile);

            jqUnit.assertTrue("fileDownload must return a promise" + suffix, fluid.isPromise(p));

            p.then(function (result) {
                jqUnit.assertNotEquals("fileDownload must only succeed if expected" + suffix, test.expect, "reject");

                if (test.expect === "resolve") {
                    jqUnit.assert("resolved");
                    jqUnit.assert("resolved");
                } else if (test.expect !== "reject") {
                    var digest = gpii.tests.iodInstaller.sha512(fs.readFileSync(outFile));
                    jqUnit.assertEquals("Hash in result must be correct", test.expect, result);
                    jqUnit.assertEquals("Hash of download must be correct", test.expect, digest);
                }
                nextTest();
            }, function (err) {
                jqUnit.assertEquals("fileDownload must only reject if expected" + suffix, test.expect, "reject");
                jqUnit.expect(-2); // the resolve block as 2 more asserts
                if (test.expects !== "reject") {
                    fluid.log(err);
                }
                nextTest();
            });
        }

    };

    nextTest();
});

jqUnit.asyncTest("test executeCommand", function () {

    var tests = gpii.tests.iodInstaller.executeCommandTests;

    jqUnit.expect(tests.length * 2);

    var currentTest, messageSuffix;

    var installer = gpii.tests.iodInstaller.dummyInstaller({
        invokers: {
            startProcess: {
                func: function (args) {
                    jqUnit.assertDeepEq("startProcess should be called correctly" + messageSuffix,
                        currentTest.expect, args);
                    return fluid.promise().resolve();
                },
                args: [{
                    funcName: "startProcess",
                    command: "{arguments}.0",
                    args: "{arguments}.1",
                    options: "{arguments}2"
                }]
            },
            startElevatedProcess: {
                func: function (args) {
                    jqUnit.assertDeepEq("startElevatedProcess should be called correctly" + messageSuffix,
                        currentTest.expect, args);
                    return fluid.promise().resolve();
                },
                args: [{
                    funcName: "startElevatedProcess",
                    command: "{arguments}.0",
                    args: "{arguments}.1",
                    options: "{arguments}2"
                }]
            }
        }
    });


    var doTest = function (testIndex) {
        currentTest = tests[testIndex];
        if (currentTest) {
            messageSuffix = " - test:" + currentTest.id;
            installer.installation = currentTest.installation;
            var p = gpii.iod.executeCommand(installer, currentTest.execOptions, currentTest.command, currentTest.args);
            jqUnit.assertTrue("executeCommand must return a promise" + messageSuffix, fluid.isPromise(p));

            p.then(function () {
                doTest(testIndex + 1);
            }, function () {
                jqUnit.assertTrue("executeCommand should reject if expected" + messageSuffix,
                    currentTest.expect.reject);
                doTest(testIndex + 1);
            });

        } else {
            jqUnit.start();
        }
    };

    doTest(0);

});
