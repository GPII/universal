/*
 * IoD Tests - package data source.
 *
 * Copyright 2019 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion");
var kettle = fluid.require("kettle");
kettle.loadTestingSupport();

var path = require("path"),
    fs = require("fs"),
    url = require("url"),
    json5 = require("json5"),
    jqUnit = fluid.require("node-jqunit", require, "jqUnit");

var gpii = fluid.registerNamespace("gpii");

fluid.registerNamespace("gpii.tests.iodPackageData");

require("./common.js");
require("../index.js");

require("gpii-iodServer");

fluid.defaults("gpii.tests.iodPackageData.tests", {
    gradeNames: ["fluid.test.testEnvironment"],

    components: {
        packages: {
            type: "gpii.iod.packages",
            options: {
                events: {
                    onServerFound: null,
                    onLocalPackagesFound: null
                }
            }
        },
        iodServer: {
            type: "kettle.server",
            options: {
                port: 51286,
                components: {
                    packageServer: {
                        type: "kettle.app",
                        options: {
                            requestHandlers: {
                                packages: {
                                    route: "/iod/packages/:packageName",
                                    method: "get",
                                    type: "gpii.tests.iodPackageData.packagesRequest"
                                }
                            }
                        }
                    }
                }
            }
        },
        tester: {
            type: "gpii.tests.iodPackageData.testCaseHolder",
            options: {
                testData: "{tests}.options.testData"
            }
        },
        localTester: {
            type: "gpii.tests.iodPackageData.testCaseHolder.packageSource",
            options: {
                isLocal: true,
                testData: "{tests}.options.testData",
                installerSource: url.pathToFileURL(path.join(__dirname, "localPackages/packages/existing-file")).toString(),
                invokers: {
                    "createDataSource": {
                        func: "{packages}.events.onLocalPackagesFound.fire",
                        args: [path.join(__dirname, "localPackages")]
                    }
                }
            }
        },
        localTester2: {
            type: "gpii.tests.iodPackageData.testCaseHolder.packageSource",
            options: {
                isRemote: true,
                testData: "{tests}.options.testData",
                expect: {
                    installerSource: "/installer/location-exists"
                },
                invokers: {
                    "createDataSource": {
                        func: "{packages}.events.onServerFound.fire",
                        args: ["http://127.0.0.1:51286/iod"]
                    }
                }
            }
        }
    },
    testData: {
        signing: {
            keyPair: "@expand:gpii.tests.iod.generateKeyPair()",
            testData: {
                testField: "test value",
                publicKey: "{that}.options.testData.signing.keyPair.publicKey"
            },
            testDataNoKey: {
                testField: "test value"
            },
            signed: {
                expander: {
                    funcName: "gpii.tests.iod.generateSignedData",
                    args: ["{that}.options.testData.signing.testData", "{that}.options.testData.signing.keyPair"]
                }
            },
            wrong: {
                expander: {
                    funcName: "gpii.tests.iod.generateSignedData",
                    args: [{value: "wrong"}, "{that}.options.testData.signing.keyPair"]
                }
            }
        },
        localPackages: {
            packageA: {
                packageData: {
                    name: "packageA"
                }
            },
            packageB: {
                packageData: {
                    name: "packageB"
                },
                installer: "packageDataSourceTests.js"
            },
            packageC: {
                packageData: {
                    name: "packageC"
                },
                installer: "packageDataSourceTests.js",
                offset: 42
            },
            packageD: {
                packageData: {
                    name: "packageD"
                },
                installer: "not/exist"
            }
        }
    }
});

fluid.defaults("gpii.tests.iodPackageData.packagesRequest", {
    gradeNames: ["kettle.request.http"],
    invokers: {
        handleRequest: {
            funcName: "gpii.tests.iodPackageData.handleRequest",
            args: [
                "{packageServer}", "{request}", "{request}.req.params.packageName", "{request}.req.params.lang"
            ]
        }
    }
});


/**
 * Handles /packages requests. Responds with a {PackageResponse} for the given package.
 *
 * @param {Component} packages The gpii.iodServer.packageServer instance.
 * @param {Component} request The gpii.iodServer.packageServer.packagesRequest for this request.
 * @param {String} packageName Name of the requested package.
 */
gpii.tests.iodPackageData.handleRequest = function (packages, request, packageName) {
    fluid.log("package requested: " + packageName);
    var localPackages;
    try {
        localPackages = json5.parse(fs.readFileSync(path.join(__dirname, "localPackages/.morphic-packages")));
    } catch (e) {
        fluid.log("Error loading local package data (probably expected): ", e.message);
        localPackages = {};
    }

    var result = fluid.copy(localPackages.packages[packageName]);
    if (result) {
        if (result.installer) {
            result.installer = "/installer/" + packageName;
            delete result.location;
        }
        request.events.onSuccess.fire(result);
    } else {
        request.events.onError.fire({
            message: "No such package",
            statusCode: 404
        });
    }
};


gpii.tests.iodPackageData.assertContains = function (msg, expected, actual) {
    var contains = (actual || "").toString().includes(expected);
    if (contains) {
        jqUnit.assert(msg);
    } else {
        jqUnit.assertEquals(msg, expected, actual);
    }
};

fluid.defaults("gpii.tests.iodPackageData.testCaseHolder", {
    gradeNames: ["fluid.test.testCaseHolder"],
    modules: [{
        name: "verifySignedJSON tests",
        tests: [{
            expect: 1,
            name: "valid data",
            sequence: [{
                task: "gpii.iod.verifySignedJSON",
                args: [
                    "{that}.options.testData.signing.signed.string",
                    "{that}.options.testData.signing.signed.signature",
                    {key1: "{that}.options.testData.signing.keyPair.fingerprint"}
                ],
                resolve: "jqUnit.assertDeepEq",
                resolveArgs: [
                    "verifySignedJSON with valid data should resolve with parsed data",
                    "@expand:JSON.parse({that}.options.testData.signing.signed.string)",
                    "{arguments}.0"
                ]
            }]
        }, {
            expect: 1,
            name: "verifySignedJSON with invalid signed string should reject",
            sequence: [{
                task: "gpii.iod.verifySignedJSON",
                args: [
                    "{that}.options.testData.signing.wrong.string",
                    "{that}.options.testData.signing.signed.signature",
                    {key1: "{that}.options.testData.signing.keyPair.fingerprint"}
                ],
                reject: "jqUnit.assertEquals",
                rejectArgs: [
                    "Reject reason should be the expected value",
                    "Signed JSON data failed verification: Signature could not be verified.",
                    "{arguments}.0.message"
                ]
            }]
        }, {
            expect: 1,
            name: "verifySignedJSON with the wrong signature should reject",
            sequence: [{
                task: "gpii.iod.verifySignedJSON",
                args: [
                    "{that}.options.testData.signing.signed.string",
                    "{that}.options.testData.signing.wrong.signature",
                    {key1: "{that}.options.testData.signing.keyPair.fingerprint"}
                ],
                reject: "jqUnit.assertEquals",
                rejectArgs: [
                    "Reject reason should be the expected value",
                    "Signed JSON data failed verification: Signature could not be verified.",
                    "{arguments}.0.message"
                ]
            }]
        }, {
            expect: 1,
            name: "verifySignedJSON with a bad signature should reject",
            sequence: [{
                task: "gpii.iod.verifySignedJSON",
                args: [
                    "{that}.options.testData.signing.signed.string",
                    Buffer.from("bad signature"),
                    {key1: "{that}.options.testData.signing.keyPair.fingerprint"}
                ],
                reject: "jqUnit.assertEquals",
                rejectArgs: [
                    "Reject reason should be the expected value",
                    "Signed JSON data failed verification: Signature could not be verified.",
                    "{arguments}.0.message"
                ]
            }]
        }, {
            expect: 1,
            name: "verifySignedJSON with an empty signature should reject",
            sequence: [{
                task: "gpii.iod.verifySignedJSON",
                args: [
                    "{that}.options.testData.signing.signed.string",
                    Buffer.from([]),
                    {key1: "{that}.options.testData.signing.keyPair.fingerprint"}
                ],
                reject: "jqUnit.assertEquals",
                rejectArgs: [
                    "Reject reason should be the expected value",
                    "Signed JSON data failed verification: Signature could not be verified.",
                    "{arguments}.0.message"
                ]
            }]
        }, {
            expect: 1,
            name: "verifySignedJSON with unknown fingerprint should reject",
            sequence: [{
                task: "gpii.iod.verifySignedJSON",
                args: [
                    "{that}.options.testData.signing.signed.string",
                    "{that}.options.testData.signing.signed.signature",
                    {key1: "another-fingerprint"}
                ],
                reject: "jqUnit.assertEquals",
                rejectArgs: [
                    "Reject reason should be the expected value",
                    "Signed JSON data failed verification: Signed by an unknown key.",
                    "{arguments}.0.message"
                ]
            }]
        }, {
            expect: 1,
            name: "verifySignedJSON with no known fingerprints should reject",
            sequence: [{
                task: "gpii.iod.verifySignedJSON",
                args: [
                    "{that}.options.testData.signing.signed.string",
                    "{that}.options.testData.signing.signed.signature",
                    {}
                ],
                reject: "jqUnit.assertEquals",
                rejectArgs: [
                    "Reject reason should be the expected value",
                    "Signed JSON data failed verification: Signed by an unknown key.",
                    "{arguments}.0.message"
                ]
            }]
        }, {
            expect: 1,
            name: "verifySignedJSON with no public key in object should reject",
            sequence: [{
                task: "gpii.iod.verifySignedJSON",
                args: [
                    "@expand:JSON.stringify({that}.options.testData.signing.testDataNoKey)",
                    "{that}.options.testData.signing.signed.signature",
                    {key1: "{that}.options.testData.signing.keyPair.fingerprint"}
                ],
                reject: "jqUnit.assertEquals",
                rejectArgs: [
                    "Reject reason should be the expected value",
                    "Signed JSON data failed verification: JSON object did not contain a publicKey field.",
                    "{arguments}.0.message"
                ]
            }]
        }, {
            expect: 1,
            name: "verifySignedJSON with invalid JSON should reject",
            sequence: [{
                task: "gpii.iod.verifySignedJSON",
                args: [
                    "} invalid json:",
                    "{that}.options.testData.signing.signed.signature",
                    {key1: "{that}.options.testData.signing.keyPair.fingerprint"}
                ],
                reject: "jqUnit.assertEquals",
                rejectArgs: [
                    "Reject reason should be the expected value",
                    "Error while verifying signed JSON data: Unexpected token } in JSON at position 0",
                    "{arguments}.0.message"
                ]
            }]
        }]
    }, {
        name: "checkPackageSignature tests",
        tests: [{
            expect: 1,
            name: "valid data",
            sequence: [{
                task: "gpii.iod.checkPackageSignature",
                args: [
                    {
                        packageData: "{that}.options.testData.signing.signed.string",
                        packageDataSignature: "{that}.options.testData.signing.signed.signature"
                    },
                    {key1: "{that}.options.testData.signing.keyPair.fingerprint"}
                ],
                resolve: "jqUnit.assertDeepEq",
                resolveArgs: [
                    "checkPackageSignature with valid data should resolve with parsed packageData",
                    {
                        packageData: "@expand:JSON.parse({that}.options.testData.signing.signed.string)",
                        packageDataSignature: "{that}.options.testData.signing.signed.signature"
                    },
                    "{arguments}.0"
                ]
            }]
        }, {
            expect: 1,
            name: "invalid data",
            sequence: [{
                task: "gpii.iod.checkPackageSignature",
                args: [
                    {
                        packageData: "{that}.options.testData.signing.signed.string",
                        packageDataSignature: "{that}.options.testData.signing.wrong.signature"
                    },
                    {key1: "{that}.options.testData.signing.keyPair.fingerprint"}
                ],
                reject: "jqUnit.assertDeepEq",
                rejectArgs: [
                    "checkPackageSignature with invalid data should reject",
                    "Signed JSON data failed verification: Signature could not be verified.",
                    "{arguments}.0.message"
                ]
            }]
        }]
    }, {
        name: "getLocal tests",
        tests: [{
            expect: 5,
            name: "local package source",
            sequence: [{
                task: "gpii.iod.packageDataSource.getLocal",
                args: [
                    "@expand:fluid.toPromise({that}.options.testData.localPackages)",
                    {
                        packageName: "unknown-package"
                    },
                    ""
                ],
                reject: "jqUnit.assertDeepEq",
                rejectArgs: [
                    "getLocal should reject with an unknown package",
                    "Package unknown-package not found",
                    "{arguments}.0.message"
                ]
            }, {
                task: "gpii.iod.packageDataSource.getLocal",
                args: [
                    "@expand:fluid.toPromise({that}.options.testData.localPackages)",
                    {
                        packageName: "packageA"
                    },
                    ""
                ],
                resolve: "jqUnit.assertDeepEq",
                resolveArgs: [
                    "getLocal should resolve with the requested package",
                    "{that}.options.testData.localPackages.packageA",
                    "{arguments}.0"
                ]
            }, {
                task: "gpii.iod.packageDataSource.getLocal",
                args: [
                    "@expand:fluid.toPromise({that}.options.testData.localPackages)",
                    {
                        packageName: "packageB"
                    },
                    __dirname
                ],
                resolve: "jqUnit.assertDeepEq",
                resolveArgs: [
                    "getLocal should resolve with the correct location",
                    {
                        packageData: {
                            name: "packageB"
                        },
                        installer: "file://" + __filename
                    },
                    "{arguments}.0"
                ]
            }, {
                task: "gpii.iod.packageDataSource.getLocal",
                args: [
                    "@expand:fluid.toPromise({that}.options.testData.localPackages)",
                    {
                        packageName: "packageC"
                    },
                    __dirname
                ],
                resolve: "jqUnit.assertDeepEq",
                resolveArgs: [
                    "getLocal should resolve with the correct location and offset",
                    {
                        packageData: {
                            name: "packageC"
                        },
                        installer: "file://" + __filename + "?offset=42",
                        offset: 42
                    },
                    "{arguments}.0"
                ]
            }, {
                task: "gpii.iod.packageDataSource.getLocal",
                args: [
                    "@expand:fluid.toPromise({that}.options.testData.localPackages)",
                    {
                        packageName: "packageD"
                    },
                    __dirname
                ],
                reject: "jqUnit.assertDeepEq",
                rejectArgs: [
                    "getLocal should reject with a non-existing installer",
                    "File for packageD not found",
                    "{arguments}.0.message"
                ]
            }]
        }]
    }]
});

fluid.defaults("gpii.tests.iodPackageData.testCaseHolder.packageSource", {
    gradeNames: ["fluid.test.testCaseHolder"],
    modules: [{
        name: "packageSource tests",
        tests: [{
            expect: 0,
            name: "Generating .morphic-packages",
            sequence: [{
                func: "gpii.tests.iod.generateLocalPackages",
                args: [
                    "local-packages.json5",
                    "localPackages/.morphic-packages",
                    "{that}.options.testData.signing.keyPair"
                ]
            }, {
                func: "fluid.set",
                args: [
                    "{packages}.options",
                    "trustedKeys.testkey1",
                    "{that}.options.testData.signing.keyPair.fingerprint"
                ]
            }]
        }, {
            expect: 0,
            name: "Add local package source",
            sequence: [{
                func: "{that}.createDataSource",
                args: [path.join(__dirname, "localPackages")]
            }]
        }]
    }, {
        name: "package tests",
        tests: [{
            expect: 1,
            name: "Testing successful package",
            sequence: [{
                task: "{packages}.getPackageData",
                args: [
                    {packageName: "working"}
                ],
                resolve: "jqUnit.assertEquals",
                resolveArgs: [
                    "getPackageData should resolve with the requested package",
                    "working",
                    "{arguments}.0.name"
                ]
            }]
        }, {
            expect: 1,
            name: "Testing unknown package",
            sequence: [{
                task: "{packages}.getPackageData",
                args: [
                    {packageName: "unknown-package"}
                ],
                reject: "gpii.tests.iodPackageData.assertContains",
                rejectArgs: [
                    "getPackageData should reject for unknown package",
                    "Unable to get package unknown-package:",
                    "{arguments}.0.message"
                ]
            }]
        }, {
            expect: 1,
            name: "Testing wrong named package",
            sequence: [{
                task: "{packages}.getPackageData",
                args: [
                    {packageName: "renamed"}
                ],
                reject: "jqUnit.assertEquals",
                rejectArgs: [
                    "getPackageData should reject for renamed package",
                    "Unable to get package renamed: Incorrect package name 'real-name'",
                    "{arguments}.0.message"
                ]
            }]
        }, {
            expect: 1,
            name: "Testing untrusted package",
            sequence: [{
                task: "{packages}.getPackageData",
                args: [
                    {packageName: "untrusted"}
                ],
                reject: "jqUnit.assertEquals",
                rejectArgs: [
                    "getPackageData should reject for untrusted package",
                    "Unable to get package untrusted: Signed JSON data failed verification: Signed by an unknown key.",
                    "{arguments}.0.message"
                ]
            }]
        }, {
            expect: 1,
            name: "Testing unsigned package",
            sequence: [{
                task: "{packages}.getPackageData",
                args: [
                    {packageName: "unsigned"}
                ],
                reject: "jqUnit.assertEquals",
                rejectArgs: [
                    "getPackageData should reject for unsigned package",
                    "Unable to get package unsigned: Signed JSON data failed verification: JSON object did not contain a publicKey field.",
                    "{arguments}.0.message"
                ]
            }]
        }, {
            expect: 1,
            name: "Testing package with installer location",
            sequence: [{
                task: "{packages}.getPackageData",
                args: [
                    {packageName: "location-exists"}
                ],
                resolve: "jqUnit.assertEquals",
                resolveArgs: [
                    "getPackageData should resolve location-exists, with the correct installerSource",
                    "{that}.options.expect.installerSource",
                    "{arguments}.0.installerSource"
                ]
            }]
        }, {
            expect: 2,
            name: "Testing package with installer location, which doesn't exist",
            sequence: [{
                task: "gpii.tests.iodPackageData.testInstallerNotExist",
                args: [ "{packages}", {packageName: "location-not-exists"}, "{that}.options.isRemote" ],
                resolve: "jqUnit.assert"
            }]
        }, {
            expect: 1,
            name: "Removing the packages file should disable the source",
            sequence: [{
                func: "gpii.tests.iodPackageData.renamePackageFile",
                args: ["localPackages/.morphic-packages", "localPackages/.morphic-packages-removed"]
            }, {
                // Request a package that did exist.
                task: "{packages}.getPackageData",
                args: [
                    {packageName: "working"}
                ],
                reject: "jqUnit.assertTrue",
                rejectArgs: [
                    "getPackageData should reject for package after removing the local packages file",
                    "{arguments}.0.message"
                ]
            }, {
                // Put the file back again.
                func: "gpii.tests.iodPackageData.renamePackageFile",
                args: ["localPackages/.morphic-packages-removed", "localPackages/.morphic-packages"]
            }]
        }]
    }]
});

/**
 * Renames the packages file.
 * @param {String} from The current name.
 * @param {String} to The new name.
 */
gpii.tests.iodPackageData.renamePackageFile = function (from, to) {
    fs.renameSync(path.resolve(__dirname, from), path.resolve(__dirname, to));
};

gpii.tests.iodPackageData.testInstallerNotExist = function (packages, packageRequest, isRemote) {
    var result = packages.getPackageData(packageRequest);
    var promise;

    if (isRemote) {
        promise = result.then(jqUnit.assert);
    } else {
        promise = fluid.promise();
        result.then(promise.reject, function (reason) {
            jqUnit.assertEquals("getPackageData should reject for location-not-exists package",
                "Unable to get package location-not-exists: File for location-not-exists not found", reason.message);
            promise.resolve();
        });
    }

    return promise;
};

module.exports = kettle.test.bootstrap("gpii.tests.iodPackageData.tests");
