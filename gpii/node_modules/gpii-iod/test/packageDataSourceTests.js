/*
 * IoD Tests - package data source.
 *
 * Copyright 2019 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion");
var kettle = fluid.require("kettle");
kettle.loadTestingSupport();

var crypto = require("crypto");

var jqUnit = fluid.require("node-jqunit");
var gpii = fluid.registerNamespace("gpii");

fluid.registerNamespace("gpii.tests.iodPackageData");

require("../index.js");

require("gpii-iodServer");

gpii.tests.iodPackageData.verifySignedJSONTests = [
    {
        id: "correctly signed",
        input: {
            data: {
                testField: "testValue",
                publicKey: "$key"
            },
            signature: "$signature",
            allowedKeys: "$fingerprint"
        },
        expect: "resolve"
    }
];



gpii.tests.iodPackageData.generateKey = function (passphrase) {
    var keyPair = crypto.generateKeyPairSync("rsa", {
        modulusLength: 4096,
        publicKeyEncoding: {
            type: "spki",
            format: "pem"
        },
        privateKeyEncoding: {
            type: "pkcs1",
            format: "pem",
            cipher: "aes-128-cbc",
            passphrase: passphrase || "test"
        }
    });

    // Include the passphrase
    keyPair.passphrase = passphrase;
    // signPackageData expects the private key to be `key`.
    keyPair.key = keyPair.privateKey;
    delete keyPair.privateKey;

    // Get the key (without the PEM header+trailer)
    var keyBinary = gpii.iodServer.packageFile.readPEM(keyPair.publicKey);
    // Generate the finger print
    keyPair.fingerprint = crypto.createHash("sha256").update(keyBinary).digest("base64");

    return keyPair;
};



gpii.tests.iodPackageData.createPackage = function (packageData, key, packageFile) {
    return gpii.iodServer.packageFile.create(packageData, null, key, packageFile);
};


gpii.tests.iodPackageData.assertReject = function (msg, promise) {
    var promiseTogo = fluid.promise();
    promise.then(function () {
        jqUnit.assertEquals(msg, "reject", "resolve");
        promiseTogo.resolve();
    }, function (reason) {
        fluid.log("rejection result: ", reason);
        jqUnit.assert("promise rejected");
        promiseTogo.resolve();
    });
    return promiseTogo;
};

jqUnit.asyncTest("test verifySignedJSON", function () {

    var pair = gpii.tests.iodPackageData.generateKey("test pass");

    var data = {
        testField: "test value",
        publicKey: pair.publicKey
    };

    var signedData = gpii.iodServer.packageFile.signPackageData(data, pair);
    var signedString = signedData.buffer.toString("utf8");

    // The signature is well formed, but for the wrong thing
    var wrongSignature = crypto.createSign("RSA-SHA512").update("something else").sign(pair);
    // The signature isn't a signature
    var badSignature = Buffer.from("bad signature");


    var promises = [
        gpii.iod.verifySignedJSON(signedString, signedData.signature, {key1: pair.fingerprint}).then(function (result) {
            var expect = JSON.parse(signedString);
            jqUnit.assertDeepEq("verifySignedJSON with valid data should resolve with the expected result",
                expect, result);
        }, function (e) {
            fluid.log("reject reason: ", e);
            jqUnit.fail("verifySignedJSON with valid data should resolve");
        }),

        gpii.tests.iodPackageData.assertReject("verifySignedJSON with invalid signedString should reject",
            gpii.iod.verifySignedJSON(signedString.replace("test", "TEST"), signedData.signature, {key1: pair.fingerprint})),

        gpii.tests.iodPackageData.assertReject("verifySignedJSON with the wrong signature should reject",
            gpii.iod.verifySignedJSON(signedString, wrongSignature, {key1: pair.fingerprint})),

        gpii.tests.iodPackageData.assertReject("verifySignedJSON with a bad signature should reject",
            gpii.iod.verifySignedJSON(signedString, badSignature, {key1: pair.fingerprint})),

        gpii.tests.iodPackageData.assertReject("verifySignedJSON with an empty signature should reject",
            gpii.iod.verifySignedJSON(signedString, Buffer.from([]), {key1: pair.fingerprint})),

        gpii.tests.iodPackageData.assertReject("verifySignedJSON with unknown fingerprint should reject",
            gpii.iod.verifySignedJSON(signedString, signedData.signature, {key1: "wrong fingerprint"})),

        gpii.tests.iodPackageData.assertReject("verifySignedJSON with no known fingerprints should reject",
            gpii.iod.verifySignedJSON(signedString, signedData.signature, {})),

        gpii.tests.iodPackageData.assertReject("verifySignedJSON with no public key in object should reject",
            gpii.iod.verifySignedJSON("{\"testField\":123}", signedData.signature, {key1: pair.fingerprint})),

        gpii.tests.iodPackageData.assertReject("verifySignedJSON with invalid json should reject",
            gpii.iod.verifySignedJSON("} invalid json:", signedData.signature, {key1: pair.fingerprint})),

        function () {
            // test checkPackageSignature with valid data
            var packageResponse = {
                packageData: signedString,
                packageDataSignature: signedData.signature
            };
            // The packageData should return as an object.
            var expect = {
                packageData: JSON.parse(signedString),
                packageDataSignature: signedData.signature
            };

            return gpii.iod.checkPackageSignature(packageResponse, {key1: pair.fingerprint}).then(function (result) {
                jqUnit.assertDeepEq("checkPackageSignature with valid data should resolve with the expected result",
                    expect, result);
            }, function (reason) {
                jqUnit.assertEquals("checkPackageSignature with valid data should have resolved", "resolve", reason);
            });
        },

        gpii.tests.iodPackageData.assertReject("checkPackageSignature with invalid data should reject",
            gpii.iod.checkPackageSignature(
                {packageData: signedString, packageDataSignature: "wrong"}, {key1: pair.fingerprint}))

    ];

    fluid.promise.sequence(promises).then(jqUnit.start, jqUnit.fail);

});

