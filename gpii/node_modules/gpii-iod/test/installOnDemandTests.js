/*
 * IoD Tests.
 *
 * Copyright 2018 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var os = require("os"),
    fs = require("fs"),
    path = require("path"),
    rimraf = require("rimraf");

var fluid = require("infusion");
var kettle = fluid.require("kettle");
kettle.loadTestingSupport();

var jqUnit = fluid.require("node-jqunit");
var gpii = fluid.registerNamespace("gpii");

fluid.registerNamespace("gpii.tests.iod");

require("../index.js");

var teardowns = [];

jqUnit.module("gpii.tests.iod", {
    teardown: function () {
        while (teardowns.length) {
            teardowns.pop()();
        }
    }
});


gpii.tests.iod.getInstallerTests = fluid.freezeRecursive([
    {
        packageType: "testPackageType1",
        expect: "gpii.tests.iod.testInstaller1"
    },
    {
        packageType: "testPackageType2a",
        expect: "gpii.tests.iod.testInstaller2"
    },
    {
        packageType: "testPackageType2b",
        expect: "gpii.tests.iod.testInstaller2"
    },
    {
        // Fails at installation, not during initialisation.
        packageType: "testFailPackageType",
        expect: "gpii.tests.iod.testInstallerFail"
    },
    {
        packageType: "testPackageType-not-exist",
        expect: undefined
    }
]);

gpii.tests.iod.startInstallerTests = fluid.freezeRecursive([
    {
        packageRequest: "no-such-package",
        expect: "reject"
    },
    {
        packageRequest: "unknownType",
        expect: "reject"
    },
    {
        packageRequest: "package1",
        expect: {
            installer: "gpii.tests.iod.testInstaller1",
            packageName: "package1"
        },
        resolveValue: true
    },
    {
        packageRequest: {
            packageName: "package1"
        },
        expect: null,
        resolveValue: false
    },
    {
        packageRequest: {
            packageName: "package2"
        },
        expect: {
            installer: "gpii.tests.iod.testInstaller2",
            packageName: "package2"
        },
        resolveValue: true
    },
    {
        packageRequest: {
            packageName: "languages",
            language: "es-ES"
        },
        expect: {
            installer: "gpii.tests.iod.testInstaller1",
            packageName: "languages"
        },
        resolveValue: true
    },
    {
        packageRequest: {
            packageName: "languages",
            language: "nl-NL"
        },
        expect: null,
        resolveValue: false
    },
    {
        packageRequest: "failInstall",
        expect: "reject"
    }
]);

fluid.defaults("gpii.tests.iod", {
    gradeNames: [ "gpii.iod", "gpii.lifecycleManager" ],

    listeners: {
        "onCreate.discoverServer": null,
        "onCreate.readInstallations": null
    },
    distributeOptions: {
        packageDataSource: {
            record: {
                gradeNames: ["kettle.dataSource.file.moduleTerms"],
                path: __dirname + "/testPackages/%packageName.json5",
                termMap: {
                    "packageName": "%packageName"
                }
            },
            target: "{that packages packageDataSource}.options"
        }
    },
    components: {
        "testInstaller1": {
            type: "gpii.tests.iod.testInstaller1"
        },
        "testInstaller2": {
            type: "gpii.tests.iod.testInstaller2"
        },
        "testInstallerFail": {
            type: "gpii.tests.iod.testInstallerFail"
        }
    },
    invokers: {
        readInstallations: "fluid.identity",
        writeInstallation: "fluid.identity"
    },
    model: {
        loginChange: null
    },
    members: {
        funcCalled: {}
    }
});

fluid.defaults("gpii.tests.iod.testInstaller1", {
    gradeNames: ["fluid.component", "gpii.iod.packageInstaller"],

    invokers: {
        installPackage: "fluid.identity",
        uninstallPackage: {
            funcName: "gpii.tests.iod.testInstaller1.testFunctionCalled",
            args: ["{that}", "{iod}", "uninstallPackage"]
        },
        startInstaller: {
            funcName: "gpii.tests.iod.testInstaller1.testFunctionCalled",
            args: ["{that}", "{iod}", "startInstaller"]
        }
    },

    packageTypes: "testPackageType1"
});

fluid.defaults("gpii.tests.iod.testInstaller2", {
    gradeNames: [ "gpii.tests.iod.testInstaller1"],
    packageTypes: ["testPackageType2a", "testPackageType2b"]
});

fluid.defaults("gpii.tests.iod.testInstallerFail", {
    gradeNames: ["gpii.tests.iod.testInstaller1"],
    testReject: "startInstaller",
    packageTypes: "testFailPackageType"
});

/**
 * Test function for packageInstaller, to check if a certain function has been called.
 * @param {Component} that The gpii.tests.iod.testInstaller1 instance.
 * @param {Component} iod The gpii.test.iod instance.
 * @param {String} funcName Name of the function that id being tests.
 * @return {Promise} A resolved promise.
 */
gpii.tests.iod.testInstaller1.testFunctionCalled = function (that, iod, funcName) {
    if (iod.funcCalled[funcName]) {
        jqUnit.fail(funcName + " called twice");
    }
    iod.funcCalled[funcName] = {
        installer: that.typeName,
        packageName: that.installation && that.installation.packageName
    };

    var promise = fluid.promise();
    if (that.options.testReject === funcName || iod.options.testReject === funcName) {
        promise.reject({
            isError: true,
            error: "Test failure"
        });
    } else {
        promise.resolve();
    }

    return promise;
};

///*
jqUnit.test("test getWorkingPath", function () {

    var safeToRemove = false;
    var packageName = "test" + Math.random().toString(36).substring(2);
    var result = gpii.iod.getWorkingPath(packageName);

    jqUnit.assertTrue("getWorkingPath must return something", !!result);
    jqUnit.assertEquals("fullPath must be a string", "string", typeof result.fullPath);
    jqUnit.assertEquals("createdPath must be a string", "string", typeof result.createdPath);

    try {
        jqUnit.assertNotEquals("fullPath must contain the package name", result.fullPath.indexOf(packageName));

        var isParent = result.fullPath.startsWith(result.createdPath + path.sep);
        jqUnit.assertTrue("The first created directory must be a parent of the full path", isParent);

        safeToRemove = isParent;

        var isTempDirParent = result.fullPath.startsWith(os.tmpdir());
        jqUnit.assertTrue("The path must be a subdirectory of the system's temporary directory", isTempDirParent);

        safeToRemove = safeToRemove && isTempDirParent;


        // These two aren't supposed to be guaranteed, however using a random package name should have ensured this.
        jqUnit.assertNotEquals("The first created directory must not be the full path",
            result.createdPath, result.fullPath);
        jqUnit.assertNotEquals("fullPath must contain the package name", result.fullPath.indexOf(packageName));

        try {
            var stats = fs.lstatSync(result.fullPath);
            jqUnit.assertTrue("fullPath must be a directory", stats.isDirectory());
        } catch (e) {
            fluid.log("Error checking the existence of result.fullPath");
            jqUnit.fail(e);
        }

        var fullPathContents = fs.readdirSync(result.fullPath);
        jqUnit.assertEquals("fullPath must be an empty directory", 0, fullPathContents.length);

        var createdPathContents = fs.readdirSync(result.createdPath);
        jqUnit.assertEquals("createdPath must only contain a single file", 1, createdPathContents.length);

    } finally {
        // Remove directories. If the test failed, the paths could point to anything. So, rimraf is not used which will
        // ensure only the directories are removed, and any other content remain.
        if (safeToRemove) {
            var parts = result.fullPath.split(path.sep);
            var tmpDir = os.tmpdir();
            while (parts.length > 0) {
                var dir = parts.join(path.sep);
                parts.pop();
                if ((dir === result.createdPath) || (dir === tmpDir)) {
                    break;
                } else {
                    fs.rmdirSync(dir);
                }
            }
        }
    }
});

// Test getInstaller returns the correct installer
jqUnit.test("test getInstaller", function () {

    var tests = gpii.tests.iod.getInstallerTests;

    var iod = gpii.tests.iod();

    fluid.each(tests, function (test) {

        var installer = iod.getInstaller(test.packageType);

        if (test.expect) {
            jqUnit.assertEquals("getInstaller should return the correct installer for packageType=" + test.packageType,
                test.expect, installer);
        } else {
            jqUnit.assertFalse("getInstaller should return nothing for packageType=" + test.packageType, !!installer);
        }
    });
});

// Test requirePackage correctly starts the installer.
jqUnit.asyncTest("test requirePackage", function () {
    var tests = gpii.tests.iod.startInstallerTests;
    jqUnit.expect(tests.length * 3);
    var iod = gpii.tests.iod();

    var testIndex = -1;
    var nextTest = function () {
        if (++testIndex >= tests.length) {
            iod.destroy();
            jqUnit.start();
            return;
        }

        var test = tests[testIndex];
        var suffix = " - test:" + test.id;

        iod.funcCalled.startInstaller = null;
        var p = iod.requirePackage(test.packageRequest);

        jqUnit.assertTrue("requirePackage must return a promise" + suffix, fluid.isPromise(p));

        p.then(function (value) {
            jqUnit.assertDeepEq("requirePackage must resolve with the expected value" + suffix,
                test.resolveValue, value);
            jqUnit.assertDeepEq("startInstaller must have been called correctly" + suffix,
                test.expect, iod.funcCalled.startInstaller);
            process.nextTick(nextTest);
        }, function () {
            jqUnit.assertEquals("packageData must only reject if expected" + suffix, test.expect, "reject");
            jqUnit.assert("balance the assert count");
            process.nextTick(nextTest);
        });
    };

    nextTest();
});

jqUnit.asyncTest("test installation storage", function () {

    var dir = path.join(os.tmpdir(), "gpii-test" + Math.random());

    fs.mkdirSync(dir);
    teardowns.push(function () {
        rimraf.sync(dir);
    });

    var iod = gpii.tests.iod({
        invokers: {
            uninstallPackage: {
                funcName: "gpii.tests.iod.testInstaller1.testFunctionCalled",
                args: ["{that}", "{iod}", "uninstallPackage"]
            }
        }
    });

    var testData = {
        existingInst: {
            input: {
                id: "existing-installation"
            },
            expect: {
                id: "existing-installation"
            }
        },
        newInst: {
            input: {
                id: "new-installation"
            },
            expectFile: {
                id: "new-installation"
            },
            expectRead: {
                id: "new-installation",
                required: false,
                uninstalling: false
            }
        },
        updatedInst: {
            input: {
                id: "new-installation",
                test1: "something"
            },
            expectFile: {
                id: "new-installation",
                test1: "something"
            },
            expectRead: {
                id: "new-installation",
                test1: "something",
                required: false,
                uninstalling: false
            }
        }
    };

    iod.installations = {};
    iod.installations[testData.existingInst.input.id] = testData.existingInst.input;

    var origInstallations = Object.assign({}, iod.installations);

    // No files exist - check the data is the same.
    var p = gpii.iod.readInstallations(iod, dir);

    jqUnit.assertTrue("readInstallations should return a promise", fluid.isPromise(p));

    p.then(function () {
        jqUnit.assertDeepEq("readInstallation on an empty directory shouldn't change anything",
            origInstallations, iod.installations);

        jqUnit.assertFalse("uninstallPackage should not have been called", iod.funcCalled.uninstallPackage);

        // Write the installation data.
        var file = gpii.iod.writeInstallation(iod, dir, testData.newInst.input);

        jqUnit.assertEquals("writeInstallation should write to the correct file",
            path.join(dir, "iod-installation." + testData.newInst.input.id + ".json"), file);

        // Check it was written correctly.
        var writtenContent = fs.readFileSync(file);
        var writtenObject = JSON.parse(writtenContent);

        jqUnit.assertDeepEq("writeInstallation should write the correct data",
            testData.newInst.expectFile, writtenObject);

        // Check it gets loaded.
        gpii.iod.readInstallations(iod, dir).then(function () {
            jqUnit.assertDeepEq("readInstallations should read the correct data",
                testData.newInst.expectRead, iod.installations[testData.newInst.input.id]);

            // jqUnit.assertTrue("uninstallPackage should have been called", !!iod.funcCalled.uninstallPackage);
            // iod.funcCalled.uninstallPackage = null;

            // Overwrite the existing file.
            var file = gpii.iod.writeInstallation(iod, dir, testData.updatedInst.input);

            // Check it was written correctly.
            var writtenContent = fs.readFileSync(file);
            var writtenObject = JSON.parse(writtenContent);
            jqUnit.assertDeepEq("writeInstallation should overwrite with the correct data",
                testData.updatedInst.expectFile, writtenObject);

            // Check the updated file gets loaded.
            gpii.iod.readInstallations(iod, dir).then(function () {
                jqUnit.assertDeepEq("readInstallations should update with the correct data",
                    testData.updatedInst.expectRead, iod.installations[testData.newInst.input.id]);

                // jqUnit.assertTrue("uninstallPackage should have been called again",
                //     !!iod.funcCalled.uninstallPackage);

                jqUnit.start();
            });
        });
    });
});

// Tests package gets uninstalled after unrequirePackage is called.
jqUnit.asyncTest("test uninstallation", function () {

    jqUnit.expect(4);

    var iod = gpii.tests.iod();

    var packageName = "package1";

    iod.requirePackage(packageName).then(function () {
        var installation = fluid.find(iod.installations, function (inst) {
            return inst.packageName === packageName ? inst : undefined;
        });

        jqUnit.assertTrue("Package should have installed", installation && installation.installed);
        jqUnit.assertTrue("Package should have been added to the list", !!iod.installations[installation.id]);

        iod.unrequirePackage(packageName);

        jqUnit.assertTrue("Package should have been set to be not required", !installation.require);

        var promise = iod.uninstallPackage(packageName);

        promise.then(function () {
            // There's no promise or event, so just poll.
            if (iod.installations[installation.id]) {
                fluid.fail("Package was not removed");
            } else {
                jqUnit.assertTrue("packageInstaller.uninstallPackage should have been called",
                    !!iod.funcCalled.uninstallPackage);
                jqUnit.start();
            }
        }, jqUnit.fail);

    }, jqUnit.fail);
});


// Tests package whose uninstallation fails gets uninstalled after a restart.
jqUnit.asyncTest("test uninstallation after restart", function () {

    var dir = path.join(os.tmpdir(), "gpii-test" + Math.random());
    fs.mkdirSync(dir);
    teardowns.push(function () {
        rimraf.sync(dir);
    });

    var iodOptions = {
        invokers: {
            readInstallations: {
                funcName: "gpii.iod.readInstallations",
                args: ["{that}", dir ]
            },
            writeInstallation: {
                funcName: "gpii.iod.writeInstallation",
                args: ["{that}", dir, "{arguments}.0"]
            }
        },
        testReject: "uninstallPackage"
    };

    var iod = gpii.tests.iod(iodOptions);

    var packageName = "package1";

    // Wait for uninstallPackage to be called (should be called instantly)
    var waitForUninstall = function () {
        var promise = fluid.promise();
        var retries = 50;
        var retry = function () {
            if (iod.funcCalled.uninstallPackage) {
                promise.resolve();
            } else {
                if (--retries > 0) {
                    setTimeout(retry, 100);
                } else {
                    promise.reject("Package was not removed");
                }
            }
        };
        retry();

        return promise;
    };

    // Install the package, and fail uninstall.
    iod.requirePackage(packageName).then(function () {
        var installation = fluid.find(iod.installations, function (inst) {
            return inst.packageName === packageName ? inst : undefined;
        });

        jqUnit.assertTrue("Package should have installed", installation && installation.installed);
        jqUnit.assertTrue("Package should have been added to the list", !!iod.installations[installation.id]);

        iod.unrequirePackage(packageName);

        jqUnit.assertTrue("Package should have been set to be not required", !installation.require);

        process.nextTick(function () {
            // Fake a restart by creating a new instance of iod.
            iod.destroy();
            iodOptions.testReject = null;
            iod = gpii.tests.iod(iodOptions);
            iod.readInstallations();
        });

        waitForUninstall().then(jqUnit.start, jqUnit.fail);
    }, jqUnit.fail);
});
