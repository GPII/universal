/*
* Flat Match Maker
*
* Copyright 2014 Raising the Floor - International
*
* Licensed under the New BSD license. You may not use this file except in
* compliance with this License.
*
* The research leading to these results has received funding from the European Union's
* Seventh Framework Programme (FP7/2007-2013)
* under grant agreement no. 289016.
*
* You may obtain a copy of the License at
* https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

/* global require */
(function () {
    "use strict";

    var fluid = fluid || require("infusion"),
        gpii = fluid.registerNamespace("gpii"),
        $ = fluid.registerNamespace("jQuery");

    fluid.require("kettle", require);
    fluid.registerNamespace("gpii.flatMatchMaker");

    fluid.defaults("gpii.flatMatchMaker", {
        gradeNames: ["kettle.app", "autoInit"],
        components: {
            ontologyHandler: {
                "type": "gpii.ontologyHandler"
            }
        },
        handlers: {
            matchPost: {
                route: "/match",
                type: "post"
            }
        },
        invokers: {
            match: {
                funcName: "gpii.flatMatchMaker.match",
                args: [ "{ontologyHandler}", "{arguments}.0", "{flatMatchMaker}.disposeStrategy"]
            },
            disposeStrategy: {
                funcName: "gpii.flatMatchMaker.disposeStrategy",
                args: [ "{arguments}.0", "{arguments}.1"]
            }
        }
    });

    fluid.defaults("kettle.requests.request.handler.matchPost", {
        gradeNames: ["autoInit", "fluid.littleComponent"],
        invokers: {
            handle: {
                funcName: "gpii.flatMatchMaker.matchPost",
                args: [ "{gpii.flatMatchMaker}", "{requestProxy}", "{request}.req.body" ],
                dynamic: true
            }
        }
    });

    /*
     * Initial function to be called when the user hits the /match URL. Simply calls the
     *  gpii.flatMatchMaker.match function and fires the 'onSuccess' event when it returns
     */
    gpii.flatMatchMaker.matchPost = function (flatMatchMaker, requestProxy, body) {
        var matchedSolutions = flatMatchMaker.match(body);
        requestProxy.events.onSuccess.fire(matchedSolutions);
    };

    /*
     * Merges the inferredCommon terms from the MM input payload with the already existing
     * common terms. This obviously happens for all the context blocks (for which inferred
     * common terms exist). Existing common terms take priority over the inferred terms
     */
    gpii.flatMatchMaker.addInferredCommon = function (preferences, inferred) {
        var togo = fluid.copy(preferences);
        fluid.each(inferred, function (context, contextId) {
            var tcont = togo.contexts[contextId];
            fluid.each(context, function (settings) {
                tcont.preferences = $.extend(true, settings, tcont.preferences);
            });
        });
        return togo;
    };

    /*
     * Main function of the flat matchmaker. Ensures that the inferred common terms are taken
     * into account and that the preferences are stored in a hierarchical format, needed by
     * the flat MM, and then runs the frameworks 'disposeSolutions' function with the
     * flatMatchMaker.disposeStrategy strategy. The correct output format is ensured by the
     * buildReturnPayload function of the MM framework.
     */
    gpii.flatMatchMaker.match = function (ontologyHandler, payload, disposeStrategy) {
        payload.preferences = gpii.flatMatchMaker.addInferredCommon(payload.preferences, payload.inferredCommonTerms);
        payload.hierarchicalPrefs = ontologyHandler.prefsToOntology(payload.preferences, "flat", "ISO24751");

        var transformSpec = gpii.ontologyHandler.getTransformSpec(ontologyHandler.options.ontologyTransformSpecs, "flat", "ISO24751");
        var disposed = gpii.matchMakerFramework.utils.disposeSolutions(payload, disposeStrategy, transformSpec);
        return  gpii.matchMakerFramework.utils.buildReturnPayload(payload, disposed);
    };

    /*
     * Very simple strategy that accepts any solution for which any preference el-path matches
     * a one of the solutions capabilities (inferred from the capabilities transformations and
     * capabilities block of that solution)
     */
    gpii.flatMatchMaker.disposeStrategy = function (leaves, solrecs) {
        fluid.each(solrecs, function (solrec) {
            var accepted = fluid.find(leaves, function (leaf) {
                return fluid.get(solrec.skeleton, leaf, fluid.model.escapedGetConfig);
            });
            solrec.disposition = accepted ? "accept" : "reject";
        });
        return solrecs;
    };
})();