"use strict";
var fluid  = require("infusion");
var gpii   = fluid.registerNamespace("gpii");
var jqUnit = require("node-jqunit");

require("json5/lib/register");

// TODO: reenable once we're ready to fill in missing schema data in other platforms.
//var fs   = require("fs");
var path = require("path");

require("gpii-json-schema");

require("./lib/validation");
require("../../transformer/src/js/Transformer");

var solutionSchema = require("../src/schemas/solution-schema.json5");

jqUnit.module("Sanity checks for Solutions Registry files.");

fluid.registerNamespace("gpii.tests.universal.solutionsRegistry.srFiles");

gpii.tests.universal.solutionsRegistry.srFiles.checkSolutionsFiles = function (that, globalValidator) {
    var resolvedGenericTermsPath = fluid.module.resolvePath(that.options.genericPreferenceTermsPath);
    var genericTerms  = require(resolvedGenericTermsPath);

    var resolvedSrPath = fluid.module.resolvePath(that.options.solutionsRegistryPath);

    // TODO: reenable once we're ready to fill in missing schema data in other platforms.
    //var files = fs.readdirSync(resolvedSrPath);
    var files = ["win32.json5"];

    fluid.each(files, function (filename) {
        if (filename.match(/^.+\.json5?$/i)) {
            var filePath = path.resolve(resolvedSrPath, filename);
            var singleFileSolutions = require(filePath);

            fluid.each(singleFileSolutions, function (solutionDef, solutionKey) {
                gpii.tests.universal.solutionsRegistry.srFiles.checkSingleSolution(globalValidator, filename, solutionKey, solutionDef, genericTerms);
            });
        }
    });
};

gpii.tests.universal.solutionsRegistry.srFiles.checkSingleSolution = function (globalValidator, filename, solutionKey, solutionDef, genericTerms) {
    jqUnit.test("Sanity-checking solution '" + solutionKey + "' in file '" + filename + "'.", function () {
        var isSolutionValid = gpii.tests.universal.solutionsRegistry.validateSinglePayload(
            globalValidator,
            solutionDef,
            solutionSchema,
            "solution file '" + filename + "' -> solution '" + solutionKey + "'"
        );
        jqUnit.assertTrue("Solution '" + solutionKey + "' in file '" + filename + "' should have a valid schema.", isSolutionValid);

        gpii.tests.universal.solutionsRegistry.srFiles.checkDefaults(globalValidator, filename, solutionKey, solutionDef);
        gpii.tests.universal.solutionsRegistry.srFiles.checkCapabilities(filename, solutionKey, solutionDef, genericTerms);
        gpii.tests.universal.solutionsRegistry.srFiles.checkTransforms(filename, solutionKey, solutionDef, genericTerms);

        // TODO: Ensure that all forward and inverse transforms are sane, i.e. that they can at least be used with an empty object.
        // TODO: Ensure that all references to generic preference settings in transforms actually refer to generic preference settings that exist.
        // Discuss with Antranig how best to accomplish these checks, i.e. how much in the way of resolvers, etc. do we
        // actually need to meaningfully sanity check transforms?
    });

};

// Ensure that all "capabilities" refer to a generic preference setting.
gpii.tests.universal.solutionsRegistry.srFiles.checkCapabilities = function (filename, solutionKey, solutionDef, genericTerms) {
    var missingTermsCount = 0;
    if (solutionDef.capabilities && solutionDef.capabilities.length) {
        fluid.each(solutionDef.capabilities, function (capabilityKey) {
            var unescapedKey = capabilityKey.replace(/\\/g, "");
            var termDef  = genericTerms[unescapedKey];
            if (termDef === undefined) {
                missingTermsCount++;
                fluid.log("The capability '" + capabilityKey + "' specified in solution '" + solutionKey + "' does not exist.");
            }
        });

        jqUnit.assertEquals("There should be no missing capabilities in solution '" + solutionKey + "'.", 0, missingTermsCount);
    }
    else {
        jqUnit.assert("Entry '" + solutionKey + "' has no capabilities, which is fine.");
    }
};

// Ensure that all transforms involving common terms refer to common terms that actually exist.
gpii.tests.universal.solutionsRegistry.srFiles.checkTransforms = function (filename, solutionKey, solutionDef, genericTerms) {
    fluid.each(solutionDef.settingsHandlers, function (settingsHandlerDef, settingsHandlerKey) {
        var allTransformTerms = [];

        if (settingsHandlerDef.capabilitiesTransformations) {
            var forwardTransformTerms = gpii.tests.universal.solutionsRegistry.srFiles.extractCommonTerms(settingsHandlerDef.capabilitiesTransformations);
            if (forwardTransformTerms.length) {
                allTransformTerms = allTransformTerms.concat(forwardTransformTerms);
            }
        }

        if (settingsHandlerDef.inverseCapabilitiesTransformations) {
            var inverseTransformTerms = gpii.tests.universal.solutionsRegistry.srFiles.extractCommonTerms(settingsHandlerDef.inverseCapabilitiesTransformations);
            if (inverseTransformTerms.length) {
                allTransformTerms = allTransformTerms.concat(inverseTransformTerms);
            }
        }
        var missingTermsCount = 0;

        fluid.each(allTransformTerms, function (transformTerm) {
            var unescapedTermKey = transformTerm.replace(/\\\./g, ".");
            var termExists = (fluid.get(genericTerms, [unescapedTermKey]) !== undefined);

            if (!termExists) {
                missingTermsCount++;
                fluid.log(filename + " -> " + solutionKey + " -> " + settingsHandlerKey + " uses the common term '" + unescapedTermKey + "', which does not exist.");
            }
        });

        jqUnit.assertEquals("There should be no transforms that use missing common terms.", 0, missingTermsCount);
    });
};

gpii.tests.universal.solutionsRegistry.srFiles.extractCommonTerms = function (toInspect) {
    var foundTerms = [];

    if (typeof toInspect === "object") {
        fluid.each(toInspect, function (deepValue) {
            var subSegments = gpii.tests.universal.solutionsRegistry.srFiles.extractCommonTerms(deepValue);
            if (subSegments.length) {
                foundTerms = foundTerms.concat(subSegments);
            }
        });
    }
    else if (typeof toInspect === "string" && toInspect.startsWith("http://registry.gpii.net/common/")) {
        foundTerms.push(toInspect);
    }

    return foundTerms;
};


// If there are default values, test them against the schema.
gpii.tests.universal.solutionsRegistry.srFiles.checkDefaults = function (globalValidator, filename, solutionKey, solutionDef) {
    var fileErrors = 0;
    fluid.each(solutionDef.settingsHandlers, function (settingsHandler) {
        fluid.each(settingsHandler.supportedSettings, function (supportedSetting, settingKey) {
            // Check the specified default against its schema. This only works for simple settings, and not for
            // deeply nested objects.
            var defaultValue = fluid.get(supportedSetting, "schema.default");
            if (defaultValue !== undefined) {
                // Check the raw value
                var isValid = gpii.tests.universal.solutionsRegistry.validateSinglePayload(
                    globalValidator,
                    defaultValue,
                    supportedSetting.schema,
                    "Default value for " + filename + " -> " + solutionKey + " -> " + settingKey
                );
                if (!isValid) {
                    fileErrors++;
                }

                // Transform the default value to any "intra-application" variant we might expect to see and ensure that it's still valid.
                if (fluid.get(settingsHandler, ["capabilitiesTransformations", settingKey]) && settingsHandler.inverseCapabilitiesTransformations) {
                    var settingWrapper = {};
                    fluid.set(settingWrapper, [settingKey], defaultValue);
                    var invertedPayload = fluid.model.transformWithRules(settingWrapper, settingsHandler.inverseCapabilitiesTransformations);
                    if (Object.keys(invertedPayload).length > 0) {
                        var reinvertedPayload = fluid.model.transformWithRules(invertedPayload, settingsHandler.capabilitiesTransformations);
                        var reinvertedDefaultValue = fluid.get(reinvertedPayload, [settingKey]);

                        if (reinvertedDefaultValue !== defaultValue) {
                            // Warn on "softly equal" things like "truthy" and "falsy" values.
                            if (reinvertedDefaultValue != defaultValue) { // eslint-disable-line eqeqeq
                                fluid.log("ERROR: The capabilities transforms for " + solutionKey + " -> " + settingKey + " may result in data corruption.");
                                fileErrors++;
                            }
                            else {
                                fluid.log("WARNING: The capabilities transforms for " + solutionKey + " -> " + settingKey + " are only safe for truthy and falsy values.");
                            }
                        }
                    }
                }
            }
        });
    });
    jqUnit.assertEquals("There should be no validation errors in solutions registry file '" + filename + "'.", 0, fileErrors);
};

fluid.defaults("gpii.tests.universal.solutionsRegistry.srFiles", {
    gradeNames: ["fluid.component"],
    solutionsRegistryPath: "%gpii-universal/testData/solutions",
    genericPreferenceTermsPath: "%gpii-universal/testData/ontologies/flat.json5",
    settingsDataPath: "%gpii-universal/testData/preferences",
    listeners: {
        "onCreate.checkAll": {
            funcName: "gpii.tests.universal.solutionsRegistry.srFiles.checkSolutionsFiles",
            args:     ["{that}", "{gpii.schema.validator}"]
        }
    }
});

gpii.tests.universal.solutionsRegistry.srFiles();
