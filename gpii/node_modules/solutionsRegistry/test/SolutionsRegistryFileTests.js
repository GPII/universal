"use strict";
var fluid  = require("infusion");
var gpii   = fluid.registerNamespace("gpii");
var jqUnit = require("node-jqunit");

require("json5/lib/register");

// TODO: reenable once we're ready to fill in missing schema data in other platforms.
//var fs   = require("fs");
var path = require("path");

require("gpii-json-schema");

require("./lib/validation");

var solutionSchema = require("../src/schemas/solution-schema.json5");

jqUnit.module("Sanity checks for Solutions Registry files.");

fluid.registerNamespace("gpii.tests.universal.solutionsRegistry.srFiles");

gpii.tests.universal.solutionsRegistry.srFiles.checkSolutionsFiles = function (that) {
    var resolvedGenericTermsPath = fluid.module.resolvePath(that.options.genericPreferenceTermsPath);
    var genericTerms  = require(resolvedGenericTermsPath);

    var resolvedSrPath = fluid.module.resolvePath(that.options.solutionsRegistryPath);

    // TODO: reenable once we're ready to fill in missing schema data in other platforms.
    //var files = fs.readdirSync(resolvedSrPath);
    var files = ["win32.json5"];

    fluid.each(files, function (filename) {
        if (filename.match(/^.+\.json5?$/i)) {
            var filePath = path.resolve(resolvedSrPath, filename);
            var singleFileSolutions = require(filePath);

            fluid.each(singleFileSolutions, function (solutionDef, solutionKey) {
                gpii.tests.universal.solutionsRegistry.srFiles.checkSingleSolution(filename, solutionKey, solutionDef, genericTerms);
            });
        }
    });
};

gpii.tests.universal.solutionsRegistry.srFiles.checkSingleSolution = function (filename, solutionKey, solutionDef, genericTerms) {
    jqUnit.test("Sanity-checking solution '" + solutionKey + "' in file '" + filename + "'.", function () {
        var isSolutionValid = gpii.tests.universal.solutionsRegistry.validateSinglePayload(
            solutionDef,
            solutionSchema,
            "solution file '" + filename + "' -> solution '" + solutionKey + "'"
        );
        jqUnit.assertTrue("Solution '" + solutionKey + "' in file '" + filename + "' should have a valid schema.", isSolutionValid);

        gpii.tests.universal.solutionsRegistry.srFiles.checkDefaults(filename, solutionKey, solutionDef);
        gpii.tests.universal.solutionsRegistry.srFiles.checkCapabilities(filename, solutionKey, solutionDef, genericTerms);

        // TODO: Ensure that all forward and inverse transforms are sane, i.e. that they can at least be used with an empty object.
        // TODO: Ensure that all references to generic preference settings in transforms actually refer to generic preference settings that exist.
        // Discuss with Antranig how best to accomplish these checks, i.e. how much in the way of resolvers, etc. do we
        // actually need to meaningfully sanity check transforms?
    });

};

// Ensure that all "capabilities" refer to a generic preference setting.
gpii.tests.universal.solutionsRegistry.srFiles.checkCapabilities = function (filename, solutionKey, solutionDef, genericTerms) {
    if (solutionDef.capabilities && solutionDef.capabilities.length) {
        fluid.each(solutionDef.capabilities, function (capabilityKey) {
            var unescapedKey = capabilityKey.replace(/\\/g, "");
            var termDef  = genericTerms[unescapedKey];
            jqUnit.assertTrue("The capability '" + capabilityKey + "' specified in solution '" + solutionKey + "' should exist.", termDef !== undefined);
        });
    }
    else {
        jqUnit.assert("Entry '" + solutionKey + "' has no capabilities, which is fine.");
    }
};

// If there are default values, test them against the schema.
gpii.tests.universal.solutionsRegistry.srFiles.checkDefaults = function (filename, solutionKey, solutionDef) {
    var fileErrors = 0;
    fluid.each(solutionDef.settingsHandlers, function (settingsHandler) {
        fluid.each(settingsHandler.supportedSettings, function (supportedSetting, settingKey) {
            // Log a warning if a schema lacks a title and description.
            fluid.each(["title", "description"], function (keyword) {
                if (!fluid.get(supportedSetting, ["schema", keyword])) {
                    fluid.log("WARNING: Solution '" + solutionKey + "' lacks a " + keyword + " for setting '" + settingKey + "'.");
                }
            });

            // Check the specified default against its schema. This only works for simple settings, and not for
            // deeply nested objects.
            var defaultValue = fluid.get(supportedSetting, "schema.default");
            if (defaultValue !== undefined) {
                var isValid = gpii.tests.universal.solutionsRegistry.validateSinglePayload(
                    defaultValue,
                    supportedSetting.schema,
                    "default value for " + filename + " -> " + solutionKey + " -> " + settingKey
                );
                if (!isValid) {
                    fileErrors++;
                }
            }
        });
    });
    jqUnit.assertEquals("There should be no validation errors in solutions registry file '" + filename + "'.", 0, fileErrors);
};

fluid.defaults("gpii.tests.universal.solutionsRegistry.srFiles", {
    gradeNames: ["fluid.component"],
    solutionsRegistryPath: "%gpii-universal/testData/solutions",
    genericPreferenceTermsPath: "%gpii-universal/testData/ontologies/flat.json5",
    settingsDataPath: "%gpii-universal/testData/preferences",
    listeners: {
        "onCreate.checkAll": {
            funcName: "gpii.tests.universal.solutionsRegistry.srFiles.checkSolutionsFiles"
        }
    }
});

gpii.tests.universal.solutionsRegistry.srFiles();
