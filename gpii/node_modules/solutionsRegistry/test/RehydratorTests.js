/*

    Tests for the "rehydrator" that assembles the "live" solutions registry from a series of JSON(5) files.

*/
/* eslint-env node */
"use strict";
var fluid = require("infusion");
var gpii  = fluid.registerNamespace("gpii");

var jqUnit = require("node-jqunit");

require("../");
require("../src/js/liveSolutionsRegistry");
require("./lib/validation");

var solutionSchema = require("../src/schemas/solution-schema.json5");

// Common test fixtures to scan a specified directory, and then run tests when the scan is complete.
fluid.registerNamespace("gpii.tests.universal.solutionsRegistry.rehydrator");

gpii.tests.universal.solutionsRegistry.rehydrator.findSolution = function (lsrComponent, gradeName) {
    var matchingSolutions = fluid.queryIoCSelector(lsrComponent, gradeName);
    jqUnit.assertTrue("There should a single child of grade '" + gradeName + "'.", matchingSolutions.length === 1);

    var settingsHandlerComponents = fluid.queryIoCSelector(matchingSolutions[0], "gpii.solutionsRegistry.settingsHandlerHolder");
    jqUnit.assertTrue("There should be at least one settings handler.", settingsHandlerComponents.length > 0);

    fluid.each(settingsHandlerComponents, function (settingsHandlerComponent) {
        var settingsComponents = fluid.queryIoCSelector(settingsHandlerComponent, "gpii.solutionsRegistry.setting");
        jqUnit.assertTrue("There should be at least one setting.", settingsComponents.length > 0);
    });

    return matchingSolutions;
};

fluid.defaults("gpii.tests.universal.solutionsRegistry.rehydrator.testEnvironment", {
    gradeNames: ["fluid.test.testEnvironment"],
    events: {
        rehydrate: null,
        rehydrationComplete: null
    },
    components: {
        rehydrator: {
            createOnEvent: "rehydrate",
            type: "gpii.solutionsRegistry.live",
            options: {
                solutionDir: "{testEnvironment}.options.solutionDir",
                listeners: {
                    "registryCreated.notifyParent": {
                        func: "{testEnvironment}.events.rehydrationComplete.fire"
                    }
                }
            }
        }
    }
});

fluid.defaults("gpii.tests.universal.solutionsRegistry.rehydrator.startSequence", {
    gradeNames: "fluid.test.sequenceElement",
    sequence: [
        {
            func: "{testEnvironment}.events.rehydrate.fire"
        },
        {
            event: "{testEnvironment}.events.rehydrationComplete",
            listener: "fluid.log",
            args: ["Test fixture rehydration complete."]
        }
    ]
});

fluid.defaults("gpii.tests.universal.solutionsRegistry.rehydrator.sequenceGrade", {
    gradeNames: "fluid.test.sequence",
    sequenceElements: {
        warmup: {
            gradeNames: "gpii.tests.universal.solutionsRegistry.rehydrator.startSequence",
            priority: "before:sequence"
        }
    }
});

// Tests for the "short" form, where a lot of boilerplate is omitted.
fluid.defaults("gpii.tests.universal.solutionsRegistry.rehydrator.shortForm.caseHolder", {
    gradeNames: ["fluid.test.testCaseHolder"],
    modules: [{
        name: "LSR rehydration (short)",
        tests: [{
            name: "Testing rehydration of short-form LSR entries.",
            sequenceGrade: "gpii.tests.universal.solutionsRegistry.rehydrator.sequenceGrade",
            sequence: [{
                func: "gpii.tests.universal.solutionsRegistry.rehydrator.shortForm.caseHolder.checkResults",
                args: ["{gpii.solutionsRegistry.live}", "{gpii.schema.validator}"]
            }]
        }]
    }]
});

gpii.tests.universal.solutionsRegistry.rehydrator.shortForm.caseHolder.checkResults = function (lsrComponent, globalValidator) {
    var gradesToTest = [
        // Confirm that the top-level grade is scanned and namespaced properly.
        "my.namespaced.root.grade",
        // Confirm that a file within a subdir is scanned and namespaced properly.
        "my.namespaced.subdir.grade",
        // Confirm that namespace information in a filename is handled properly.
        "my.namespaced.subdir.deeper.grade",
        // Confirm that a plain JSON file is handled appropriately.
        "my.namespaced.subdir.argonaut"
    ];

    fluid.each(gradesToTest, function (gradeName) {
        var matchingComponents = gpii.tests.universal.solutionsRegistry.rehydrator.findSolution(lsrComponent, gradeName);
        var solutionComponent = matchingComponents[0];

        var solutionExportOptions = solutionComponent.exportOptions();
        var isSolutionValid = gpii.tests.universal.solutionsRegistry.validateSinglePayload(
            globalValidator,
            solutionExportOptions,
            solutionSchema,
            "Solution with key '" + gradeName + "'"
        );
        jqUnit.assertTrue("The solution export for solution '" + gradeName + "' should be valid according to the schema.", isSolutionValid);
    });
};

fluid.defaults("gpii.tests.universal.solutionsRegistry.rehydrator.shortForm.testEnvironment", {
    gradeNames: ["gpii.tests.universal.solutionsRegistry.rehydrator.testEnvironment"],
    solutionDir: "%solutionsRegistry/test/rehydrator-fixtures/short-form",
    components: {
        caseHolder: {
            type: "gpii.tests.universal.solutionsRegistry.rehydrator.shortForm.caseHolder"
        }
    }
});

fluid.test.runTests("gpii.tests.universal.solutionsRegistry.rehydrator.shortForm.testEnvironment");

// Tests for the "long" form, including multiple levels of inheritance.
fluid.defaults("gpii.tests.universal.solutionsRegistry.rehydrator.longForm.caseHolder", {
    gradeNames: ["fluid.test.testCaseHolder"],
    modules: [{
        name: "LSR rehydration (long)",
        tests: [{
            name: "Testing rehydration of long-form LSR entries.",
            sequenceGrade: "gpii.tests.universal.solutionsRegistry.rehydrator.sequenceGrade",
            sequence: [{
                func: "gpii.tests.universal.solutionsRegistry.rehydrator.longForm.caseHolder.checkResults",
                args: ["{gpii.solutionsRegistry.live}", "{gpii.schema.validator}"]
            }]
        }]
    }]
});

gpii.tests.universal.solutionsRegistry.rehydrator.longForm.caseHolder.checkResults = function (lsrComponent, globalValidator) {
    // Confirm that the expected solution grade and its children are present.
    var solutions = gpii.tests.universal.solutionsRegistry.rehydrator.findSolution(lsrComponent, "my.namespaced.solution");

    var solutionComponent = solutions[0];

    // Confirm that the requested type name is registered in our grades.
    jqUnit.assertTrue("The requested grade name should be found in the solution component's grades.", solutionComponent.options.gradeNames.indexOf("my.namespaced.solution") !== -1);

    // Confirm that the implied namespace is not found.
    jqUnit.assertTrue("The implied directory-derived grade should not be found in the solution component's grades.", solutionComponent.options.gradeNames.indexOf("my.ignored.namespaced.solution.grade") === -1);

    // Sanity-check the solution options.
    var expectedSolutionOptions = {
        "name": "My Solution",
        "isInstalled": [{
            "type": "gpii.deviceReporter.alwaysInstalled"
        }]
    };

    jqUnit.assertLeftHand("Solution export should be as expected.", expectedSolutionOptions, solutionComponent.exportOptions());

    // Inspect the settings handler.
    var settingsHandlerComponent = solutionComponent.settingsHandler;

    jqUnit.assertTrue("The requested grade name should be found in the settings handler's grades.", settingsHandlerComponent.options.gradeNames.indexOf("my.namespaced.solution.settingsHandlers.handler") !== -1);

    var expectedSettingsHandlerOptions = {
        "liveness": "live",
        "deepOption": "overridden",
        "type": "gpii.settingsHandlers.JSONSettingsHandler"
    };

    jqUnit.assertLeftHand("The settings handler export should be as expected.", expectedSettingsHandlerOptions, settingsHandlerComponent.exportOptions());

    // Inspect the setting.
    var settingComponent = settingsHandlerComponent.setting;

    jqUnit.assertTrue("The requested grade name should be found in the setting's grades.", settingComponent.options.gradeNames.indexOf("my.namespaced.solution.settings.mySetting") !== -1);

    var expectedSettingsOptions = {
        "schema": {
            "title": "My Overridden Title",
            "description": "A setting defined in an external JSON(5) file and brought in to the settings handler by grade reference.",
            // For whatever reason, assertLeftHand doesn't work if I leave these out.  Meh.
            "type": "integer",
            "minimum": 0,
            "maximum": 127,
            "default": 0
        }
    };
    jqUnit.assertLeftHand("The setting's export should be as expected.", expectedSettingsOptions, settingComponent.exportOptions());

    var solutionPayload = solutionComponent.exportOptions();
    var isSolutionValid = gpii.tests.universal.solutionsRegistry.validateSinglePayload(
        globalValidator,
        solutionPayload,
        solutionSchema,
        "Solution with key '" + solutionComponent.typeName + "'"
    );
    jqUnit.assertTrue("The solution export should be valid according to the schema.", isSolutionValid);
};


fluid.defaults("gpii.tests.universal.solutionsRegistry.rehydrator.longForm.testEnvironment", {
    gradeNames: ["gpii.tests.universal.solutionsRegistry.rehydrator.testEnvironment"],
    solutionDir: "%solutionsRegistry/test/rehydrator-fixtures/long-form",
    components: {
        caseHolder: {
            type: "gpii.tests.universal.solutionsRegistry.rehydrator.longForm.caseHolder"
        }
    }
});

fluid.test.runTests("gpii.tests.universal.solutionsRegistry.rehydrator.longForm.testEnvironment");
