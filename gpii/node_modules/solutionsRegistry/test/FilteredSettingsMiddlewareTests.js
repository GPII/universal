/* eslint-env node */
"use strict";
var fluid = require("infusion");
var gpii  = fluid.registerNamespace("gpii");

var jqUnit = require("node-jqunit");

// Add the ability to require JSON5 files.
require("json5/lib/register");

// Require universal so that we can resolve paths to it and any sub-modules.
fluid.require("%gpii-universal");

require("../src/js/filtered-settings-middleware");

// We reuse the fairly lightweight caseholder from gpii-json-schema to avoid having to perform our own mixing of
// sequenceGrades into each test sequence.
fluid.require("%gpii-json-schema/tests/js/node/lib/fixtures.js");

fluid.loadTestingSupport();

fluid.registerNamespace("gpii.tests.universal.solutionsRegistry.kettle.caseHolder");

gpii.tests.universal.solutionsRegistry.kettle.caseHolder.loadTestSetting = function (validPayloadPath) {
    var resolvedPayloadPath = fluid.module.resolvePath(validPayloadPath);
    var payload = require(resolvedPayloadPath);
    return payload;
};

gpii.tests.universal.solutionsRegistry.kettle.caseHolder.examineResponse = function (body, shouldBeValid) {
    if (shouldBeValid) {
        jqUnit.assertEquals("The response body should be correct.", "Payload accepted.", body.message);
    }
    else {
        jqUnit.assertEquals("The data should be flagged as invalid.", body.isValid, false);
        jqUnit.assertTrue("There should be at least one validation error", body.errors.length > 0);
    }
};

fluid.defaults("gpii.tests.universal.solutionsRegistry.kettle.caseHolder", {
    gradeNames: ["gpii.test.schema.caseHolder"],
    validPayloadPath: "%gpii-universal/testData/preferences/jaws.json5",
    inputs: {
        invalid: {},
        valid: "@expand:gpii.tests.universal.solutionsRegistry.kettle.caseHolder.loadTestSetting({that}.options.validPayloadPath)"
    },
    rawModules: [{
        name: "Filtered settings middleware tests.",
        tests: [
            {
                name: "Testing a valid settings payload.",
                type: "test",
                sequence: [
                    {
                        func: "{validRequest}.send",
                        args: ["{that}.options.inputs.valid"]
                    },
                    {
                        listener: "gpii.tests.universal.solutionsRegistry.kettle.caseHolder.examineResponse",
                        event: "{validRequest}.events.onComplete",
                        args: ["@expand:JSON.parse({arguments}.0)", true]
                    }
                ]
            },
            {
                name: "Testing an invalid settings payload.",
                type: "test",
                sequence: [
                    {
                        func: "{invalidRequest}.send",
                        args: ["{that}.options.inputs.invalid"]
                    },
                    {
                        listener: "gpii.tests.universal.solutionsRegistry.kettle.caseHolder.examineResponse",
                        event: "{invalidRequest}.events.onComplete",
                        args: ["@expand:JSON.parse({arguments}.0)", false]
                    }
                ]
            }
        ]
    }],
    components: {
        validRequest: {
            type: "gpii.tests.universal.solutionsRegistry.request",
            options: {
                method: "POST",
                path: "/gated"
            }
        },
        invalidRequest: {
            type: "gpii.tests.universal.solutionsRegistry.request",
            options: {
                method: "POST",
                path: "/gated"
            }
        }
    }
});

// A wrapper for `kettle.request.http` designed for use with the `testEnvironment` below.
fluid.defaults("gpii.tests.universal.solutionsRegistry.request", {
    gradeNames: ["kettle.test.request.http"],
    port: "{testEnvironment}.options.port",
    path: {
        expander: {
            funcName: "fluid.stringTemplate",
            args:     ["http://localhost:%port/%endpoint", { port: "{testEnvironment}.options.port", endpoint: "{that}.options.endpoint"}]
        }
    }
});

// A thin shim to just ensure a "success" response if the payload is valid.
fluid.defaults("gpii.tests.universal.solutionsRegistry.kettle.handler", {
    gradeNames: ["gpii.universal.solutionsRegistry.requestValidation.settings"],
    invokers: {
        handleRequest: {
            func: "{that}.events.onSuccess.fire",
            args: [{message: "Payload accepted."}]
        }
    }
});

fluid.defaults("gpii.tests.universal.solutionsRegistry.kettle.app", {
    gradeNames: ["kettle.app"],
    requestHandlers: {
        gated: {
            type: "gpii.tests.universal.solutionsRegistry.kettle.handler",
            route: "/gated",
            method: "post"
        }
    }
});

fluid.defaults("gpii.tests.universal.solutionsRegistry.testEnvironment", {
    gradeNames: ["fluid.test.testEnvironment"],
    port:       7734,
    events: {
        constructFixtures: null,
        onKettleReady: null,
        onFixturesConstructed: {
            events: {
                onKettleReady: "onKettleReady"
            }
        }
    },
    components: {
        kettle: {
            createOnEvent: "constructFixtures",
            type: "kettle.server",
            options: {
                port: "{testEnvironment}.options.port",
                listeners: {
                    "onListen.notifyEnvironment": {
                        func: "{testEnvironment}.events.onKettleReady.fire"
                    }
                },
                components: {
                    app: {
                        type: "gpii.tests.universal.solutionsRegistry.kettle.app"
                    }
                }
            }
        },
        caseHolder: {
            type: "gpii.tests.universal.solutionsRegistry.kettle.caseHolder"
        }
    }
});

fluid.test.runTests("gpii.tests.universal.solutionsRegistry.testEnvironment");
