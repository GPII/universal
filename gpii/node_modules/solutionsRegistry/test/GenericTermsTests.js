"use strict";
var fluid  = require("infusion");
var gpii   = fluid.registerNamespace("gpii");
var jqUnit = require("node-jqunit");

require("json5/lib/register");

require("gpii-json-schema");

jqUnit.module("Sanity checks for Generic Preference Terms data.");

fluid.registerNamespace("gpii.tests.universal.solutionsRegistry.genericTerms");

// Validate the generic preference settings to confirm that they're at least valid GSS schemas.
gpii.tests.universal.solutionsRegistry.genericTerms.validateSchemas = function (that) {
    var resolvedGenericTermsPath = fluid.module.resolvePath(that.options.genericPreferenceTermsPath);
    var genericTerms = require(resolvedGenericTermsPath);

    jqUnit.test("Validating generic preference terms.", function () {
        fluid.each(genericTerms, function (termDef, termKey) {
            if (termDef.schema) {
                var schemaAsGss = fluid.merge({}, { "$schema": "gss-v7-full#" }, termDef.schema);
                // Separate check here as we are only validating the schema itself.  In theory, this is already hit for
                // any settings in our test data set, but we do it explicitly for all schemas here.
                var validationResults = gpii.schema.validator.validateSchema(schemaAsGss);

                // We perform these checks a bit flipped so that only a particular value trips it, and not a missing value.
                jqUnit.assertFalse("There should be no validation errors in generic preference term '" + termKey + "'.", validationResults.isValid === false);
                jqUnit.assertFalse("There should be no low-level errors in generic preference term '" + termKey + "'.", validationResults.isError === true);

                if (!validationResults.isError && !validationResults.isValid) {
                    var localisedErrors = gpii.schema.validator.localiseErrors(validationResults.errors, schemaAsGss);

                    fluid.each(localisedErrors, function (singleError) {
                        fluid.log("Validation error is as folows:");
                        fluid.log("  - " + singleError.dataPath.join(".") + ": " + singleError.message);
                    });
                }
            }
            else {
                jqUnit.fail("Generic Preference Term '" + termKey + "' has no schema.");
            }
        });
    });
};

fluid.defaults("gpii.tests.universal.solutionsRegistry.genericTerms", {
    gradeNames: ["fluid.component"],
    genericPreferenceTermsPath: "%gpii-universal/testData/ontologies/flat.json5",
    listeners: {
        "onCreate.validateSchemas": {
            funcName: "gpii.tests.universal.solutionsRegistry.genericTerms.validateSchemas",
            args:     ["{that}"]
        }
    }
});

gpii.tests.universal.solutionsRegistry.genericTerms();
