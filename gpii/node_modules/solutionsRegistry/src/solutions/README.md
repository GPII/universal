## Solutions Registry Entries

This directory contains entries for all of the solutions that can be used with Morphic.  Each JSON file defines a single
piece of the larger puzzle (usually a whole solution), which is assembled by scripts in this repository into the data
used throughout the system to:

1. Detect, launch, and read and write settings changes for solutions.
2. Perform input validation on payloads passed to API endpoints.
3. Generate user interfaces for individual settings (the "presentation registry").

## Onboarding a Solution

The workflow for "onboarding" a new solution (or existing settings for an existing solution is as follows):

1. Look through the existing solutions to see if the solution already has an entry.
2. If not, create a namespaced directory for the solution (see example below).
3. Create a JSON(5) file for the solution.
4. Test your work within this repository by:
   1. Running `npm postinstall` to regenerate the compiled SR data.
   2. Running `node gpii/node_modules/solutionsRegistry/tests/all-tests.js`
   3. Fix any errors indicated.
   4. Run all tests using `npm test`
5. Test your work with the target operating system(s) by.
   1. Checking your work into a branch in your fork of the universal repository.
   2. Create a branch of each target operating system repository.
   3. Update the `package.json` file to point to your branch of universal, as in:\
      `"gpii-universal": "https://github.com/the-t-in-rtf/universal.git#GPII-4125",`
6. Submit a pull request for your work against gpii-universal.
7. Submit a companion pull request for your work against the target operating system repositories.  
8. The pull will be reviewed and all pull request feedback must be addressed.
9. The pull will be merged.
10. Your work must be verified working with live clients configured to use a "dev cloud" that contains your changes.
11. Your work must be deployed to the live production cloud.

The initial steps are largely prepared on your own, the later steps require core dev involvement, and eventually devops
involvement.
 
## A Simple Solutions Registry Entry

Every solution has a unique name, such as `my.namespaced.solution`.  In the simplest scenario, you will create a
subdirectory for part of the namespace, i.e. `my.namespaced`, and then create a JSON(5) file with the rest of the
namespace, i.e. `solution.json5`.  Here is the most basic example of a setting with a single settings handler holder
and settings (comments inline):

```json5
// Assuming this file is my.namespaced/solution.json5, our implied `type` is `my.namespaced.solution`.
{
  "name": "My Solution",
  "settingsHandlers": {
    "handler": {
      //  The settings handler grade we use to read/write settings.
      "settingsHandlerNamespace": "gpii.settingsHandlers.JSONSettingsHandler",
      // Whether changes can be made in real-time (live), require a restart, et cetera.
      "liveness": "live",
      "options": {
        "works": true
      },
      // The list of settings this handler provides support for.
      "supportedSettings": {
        // The `key` is a critical part of how this setting is understood, and will be part of the setting, as in:
        // http://registry.gpii.net/applications/my.namespaced.solution": {
        //   "setting1": true
        // }
        "setting1": {
          // Schemas are expressed as GSS, a variant of Json Schema documented here: https://github.com/GPII/gpii-json-schema/blob/master/docs/gss.md
          "schema": {
            "title": "Setting One",
            "description": "The first, the last, the only.",
            "type": "boolean",
            "default": false
         }
        }
      }
    }
  }
}
```

## Advanced Usage

The solutions registry provides mechanisms that allow extension and reuse of material, for example:

1. Inheriting common settings from a previous version of a solution.
2. Inheriting a standard definition of the supported "context" (generally the OS on which the solution runs).
3. Simplifying the "boilerplate" for commonly used patterns, such as a range of toggles that use 1 for "on" and 0 for "off".

The inheritance mechanism relies on two key pieces of information:

1. The `type` field gives you a means of overriding the implied namespace for a given grade (see above).
2. The `parents` array lets you inherit material from one or more grades elsewhere in the solutions registry.

These correspond to the `type` and `gradeNames` fields in
[a standard Infusion subcomponent](https://docs.fluidproject.org/infusion/development/ComponentGrades.html).  Here is a
trivial JSON(5) example:

```json5
{
  "type": "my.namespaced.grade",
  "parents": ["gpii.solutionsRegistry.solution"]
  // Additional options omitted for brevity
}
```
This is more or less equivalent to the following component definition:

```javascript
fluid.defaults("my.namespaced.grade", {
    gradeNames: ["gpii.solutionsRegistry.solution"]
    // Additional options omitted for brevity
});
```

Note that in most cases you must include the "base" grade in the list of parents in the outer-most definition in a file.
These grades are:

| Grade Name                                     | Description |
| ---------------------------------------------- | ----------- |
| `gpii.solutionsRegistry.solution`              | A "solution", i.e. an application or operating system feature that can be used with Morphic |
| `gpii.solutionsRegistry.settingsHandlerHolder` | A "settings handler holder", which defines how a block of the solution's settings should be read and written.  |
| `gpii.solutionsRegistry.setting`               | A "setting", which describes the values allowed for a single setting. |
