/* eslint-env node */
"use strict";
var fluid = require("infusion");
var gpii  = fluid.registerNamespace("gpii");

var fs    = require("fs");
var path  = require("path");

// Add the ability to require JSON5 files.
require("json5/lib/register");

fluid.require("%gpii-universal");

// TODO: Make a codex retrieval invoker that returns all known settings (and eventually preferences).

fluid.registerNamespace("gpii.solutionsRegistry.rehydrator");

// Find all solutions grades and wire them into a single "solutions" option so that we can instantiate them as components.
gpii.solutionsRegistry.rehydrator.scan = function (that) {
    // Scan through the solutions directory registering grades
    var resolvedSolutionDirPath = fluid.module.resolvePath(that.options.solutionDir);
    gpii.solutionsRegistry.rehydrator.processDir(that, [], resolvedSolutionDirPath);

    // When everything is scanned, we should be able to find all solutions using `fluid.indexDefaults`:
    //
    // https://github.com/fluid-project/infusion/blob/master/src/framework/core/js/Fluid.js#L1994
    var solutionIndexMatches = fluid.indexDefaults("solutionIndex", {
        gradeNames: ["gpii.solutionsRegistry.solution"],
        indexFunc: function (defaults) {
            return defaults.gradeNames;
        }
    });

    var solutionGrades = solutionIndexMatches["gpii.solutionsRegistry.solution"].filter(function (entry) {
        return entry !== "gpii.solutionsRegistry.solution"; // Exclude the base marker grade itself.
    });

    return solutionGrades;
};

gpii.solutionsRegistry.rehydrator.processDir = function (that, namespaceSegments, dirPath) {
    var dirEntries = fs.readdirSync(dirPath);
    fluid.each(dirEntries, function (entryName) {
        var entryPath = path.resolve(dirPath, entryName);
        var stats = fs.statSync(entryPath);
        if (stats.isDirectory()) {
            var subdirNamespaceSegments = namespaceSegments.concat([entryName]);
            gpii.solutionsRegistry.rehydrator.processDir(that, subdirNamespaceSegments, entryPath);
        }
        else if (stats.isFile() &&  path.extname(entryName).match(/\.json5?$/, "i")) {
            var defaultTypeKey = entryName.split(".").slice(0,-1).join(".");
            var fileNamespaceSegments = namespaceSegments.concat([defaultTypeKey]);
            var fileContents = require(entryPath);
            // Use the default rules for a solution unless we have reason to do otherwise.
            var rules = that.options.rules.fileContentsToSolutionOptions;

            // If one of the parents is the top-level grade for a settingsHandlerHolder, use those rules.
            if (gpii.solutionsRegistry.rehydrator.parentsHaveGrade(fileContents.parents, "gpii.solutionsRegistry.settingsHandlerHolder")) {
                rules = that.options.rules.fileContentsToSettingsHandlerOptions;
            }
            // If one of the parents is the top-level grade for a setting, use those rules.
            else if (gpii.solutionsRegistry.rehydrator.parentsHaveGrade(fileContents.parents, "gpii.solutionsRegistry.setting")) {
                rules = that.options.rules.fileContentsToSettingsOptions;
            }

            var gradeOptions = fluid.model.transformWithRules(fileContents, rules);
            var gradeName = fileContents.type || fileNamespaceSegments.join(".");
            fluid.defaults(gradeName, gradeOptions);
        }
    });
};

// TODO: Discuss whether there is a more reasonable approach to this, as it requires "standalone" grades to directly depend on their top-level ancestor.
gpii.solutionsRegistry.rehydrator.parentsHaveGrade = function (parents, gradeNameSought) {
    return parents && parents.indexOf(gradeNameSought) !== -1;
};

fluid.defaults("gpii.solutionsRegistry.rehydrator", {
    gradeNames: ["fluid.component"],
    solutionDir: "%gpii-universal/gpii/node_modules/solutionsRegistry/src/solutions",
    rules: {
        fileContentsToSolutionOptions: {
            gradeNames: {
                transform: {
                    type: "fluid.transforms.firstValue",
                    values: ["parents", { literalValue: "gpii.solutionsRegistry.solution"}]
                }
            },
            key: "key",
            settingsHandlers: "settingsHandlers",
            solutionOptions: {
                "": "",
                "settingsHandlers": {
                    "transform": {
                        "type": "fluid.transforms.delete"
                    }
                },
                "key": {
                    "transform": {
                        "type": "fluid.transforms.delete"
                    }
                }
            }
        },
        fileContentsToSettingsHandlerOptions: {
            gradeNames: {
                transform: {
                    type: "fluid.transforms.firstValue",
                    values: ["parents", { literalValue: "gpii.solutionsRegistry.settingsHandlerHolder"}]
                }
            },
            supportedSettings: "supportedSettings",
            settingsHandlerOptions: {
                "": "",
                "supportedSettings": {
                    "transform": {
                        "type": "fluid.transforms.delete"
                    }
                }
            }
        },
        fileContentsToSettingsOptions: {
            gradeNames: {
                transform: {
                    type: "fluid.transforms.firstValue",
                    values: ["parents", { literalValue: "gpii.solutionsRegistry.setting"}]
                }
            },
            settingOptions: {
                "": ""
            }
        }
    },
    events: {
        scanRegistry: null
    },
    listeners: {
        "onCreate.scanRegistry": {
            funcName: "fluid.promise.fireTransformEvent",
            args: ["{that}.events.scanRegistry", {}] // event, payload[, options]
        },
        // We use a transforming promise chain not for the transforming part, but for the promise chain part
        "scanRegistry.scan": {
            priority: "first",
            funcName: "gpii.solutionsRegistry.rehydrator.scan",
            args: ["{that}"]
        }
    }
});
