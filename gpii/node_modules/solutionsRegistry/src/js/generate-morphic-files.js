/*

    Generate the various files to be consumed by Morphic Lite, Community, et cetera.

 */
"use strict";
var fluid  = require("infusion");
var gpii   = fluid.registerNamespace("gpii");

var mkdirp = require("mkdirp");
var fs     = require("fs");
var path   = require("path");

require("../../");
require("./liveSolutionsRegistry");

fluid.registerNamespace("gpii.solutionsRegistry.morphicFileGenerator");

gpii.solutionsRegistry.morphicFileGenerator.generate = function (that) {
    // Make the output directory if needed.
    var resolvedOutputPath = fluid.module.resolvePath(that.options.outputPath);
    if (!fs.existsSync(resolvedOutputPath)) {
        mkdirp.sync(resolvedOutputPath);
    }

    // Create each defined "context file", i.e. win32.json, android.json.
    fluid.each(that.options.fileDefs, function (contextFileGrade, contextFileKey) {
        var contextSolutionComponents = fluid.queryIoCSelector(that, contextFileGrade);
        console.log("Found " + contextSolutionComponents.length + " child components for context '" + contextFileKey + "'.");

        // Process each solution.
        fluid.each(contextSolutionComponents, function (solutionComponent) {
            // Add each solution's material to the combined "context" object.
            var rawSolutionDef = solutionComponent.exportOptions();
            var transformedSolution = {
                name: rawSolutionDef.name
            };

            transformedSolution.settingsHandlers = fluid.transform(rawSolutionDef.settingsHandlers, function (settingsHandlerDef) {
                var transformedSettingsHandlerDef = {};

                fluid.each(["supportedSettings", "type", "liveness", "options"], function (settingsHandlerElementKey) {
                    if (settingsHandlerDef[settingsHandlerElementKey]) {
                        transformedSettingsHandlerDef[settingsHandlerElementKey] = settingsHandlerDef[settingsHandlerElementKey];
                    }
                });

                return transformedSettingsHandlerDef;
            });

            // We have to do this to reorder the keys (and omit ones we've already handled above).
            fluid.each(["contexts", "capabilities", "launchHandlers", "isInstalled", "configure", "restore", "start", "stop"], function (elementKey) {
                if (rawSolutionDef[elementKey]) {
                    transformedSolution[elementKey] = rawSolutionDef[elementKey];
                }
            });

            // Output the combined context payload to a JSON file matching the contextFileKey.
            var solutionFilename = solutionComponent.options.key + ".json";
            var solutionFilePath = path.resolve(resolvedOutputPath, solutionFilename);
            fs.writeFileSync(solutionFilePath, JSON.stringify(transformedSolution, null, 4) + "\n", { encoding: "utf8"});
        });


        // Save the transforms into a separate file.
        fluid.each(contextSolutionComponents, function (solutionComponent) {
            var solutionDef = solutionComponent.exportOptions();
            var solutionTranslations = {};
            fluid.each(solutionDef.settingsHandlers, function (settingsHandlerDef, settingsHandlerKey) {
                if (settingsHandlerDef.capabilitiesTransformations || settingsHandlerDef.inverseCapabilitiesTransformations) {
                    fluid.set(solutionTranslations, [settingsHandlerKey], fluid.filterKeys(settingsHandlerDef, ["capabilitiesTransformations", "inverseCapabilitiesTransformations"], false));
                }
            });

            // Output the translations to their own JSON file.
            var translationsFileName = solutionComponent.options.key + "-translations.json";
            var translationsPath = path.resolve(resolvedOutputPath, translationsFileName);
            fs.writeFileSync(translationsPath, JSON.stringify(solutionTranslations, null, 4) + "\n", { encoding: "utf8"});
        });

    });
};

fluid.defaults("gpii.solutionsRegistry.morphicFileGenerator", {
    gradeNames: ["gpii.solutionsRegistry.live"],
    outputPath: "%solutionsRegistry/src/generated/agnostic-solutions-database",
    fileDefs: {
        // TODO: Add darwin, linux and android if requested.
        "morphic-solutions-win32":   "gpii.solutionsRegistry.context.windows",
        "morphic-solutions-generic":   "gpii.solutionsRegistry.context.generic"
    },
    listeners: {
        "registryCreated.generateContextFiles": {
            funcName: "gpii.solutionsRegistry.morphicFileGenerator.generate",
            args: ["{that}"]
        }
    },
    invokers: {
        filterObject: {
            funcName: "fluid.filterKeys",
            args: ["{arguments}.0", "{that}.options.optionsToExclude", true]
        }
    }
});

gpii.solutionsRegistry.morphicFileGenerator();
