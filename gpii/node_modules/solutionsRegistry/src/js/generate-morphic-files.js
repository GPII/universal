/*

    Generate the various files to be consumed by Morphic Lite, Community, et cetera.

 */
"use strict";
var fluid  = require("infusion");
var gpii   = fluid.registerNamespace("gpii");

var mkdirp = require("mkdirp");
var fs     = require("fs");
var path   = require("path");

require("../../");
require("./liveSolutionsRegistry");

fluid.registerNamespace("gpii.solutionsRegistry.morphicFileGenerator");

gpii.solutionsRegistry.morphicFileGenerator.generate = function (that) {
    // Make the output directory if needed.
    var resolvedOutputPath = fluid.module.resolvePath(that.options.outputPath);
    if (!fs.existsSync(resolvedOutputPath)) {
        mkdirp.sync(resolvedOutputPath);
    }

    // Create each defined "context file", i.e. win32.json5, android.json5.
    fluid.each(that.options.fileDefs, function (contextFileGrade, contextFileKey) {
        var contextSolutionComponents = fluid.queryIoCSelector(that, contextFileGrade);
        console.log("Found " + contextSolutionComponents.length + " child components for context '" + contextFileKey + "'.");

        // Process each solution.
        var contextPayload = {};
        fluid.each(contextSolutionComponents, function (solutionComponent) {
            // Add each solution's material to the combined "context" object.
            var rawSolutionDef = solutionComponent.exportOptions();
            var transformedSolution = {
                name: rawSolutionDef.name
            };

            transformedSolution.settingsHandlers = fluid.transform(rawSolutionDef.settingsHandlers, function (settingsHandlerDef) {
                var transformedSettingsHandlerDef = {};

                fluid.each(["supportedSettings", "type", "liveness", "options"], function (settingsHandlerElementKey) {
                    if (settingsHandlerDef[settingsHandlerElementKey]) {
                        transformedSettingsHandlerDef[settingsHandlerElementKey] = settingsHandlerDef[settingsHandlerElementKey];
                    }
                });

                return transformedSettingsHandlerDef;
            });

            // We have to do this to reorder the keys (and omit ones we've already handled above).
            fluid.each(["contexts", "capabilities", "launchHandlers", "isInstalled", "configure", "restore", "start", "stop"], function (elementKey) {
                if (rawSolutionDef[elementKey]) {
                    transformedSolution[elementKey] = rawSolutionDef[elementKey];
                }
            });

            fluid.set(contextPayload, [solutionComponent.options.key], transformedSolution);
        });

        // Output the combined context payload to a JSON file matching the contextFileKey.
        var contextFilename = contextFileKey + ".json5";
        var contextFilePath = path.resolve(resolvedOutputPath, contextFilename);
        fs.writeFileSync(contextFilePath, JSON.stringify(contextPayload, null, 2) + "\n", { encoding: "utf8"});

        // Save the transforms into a separate file.
        var translationsPayload = {};
        fluid.each(contextSolutionComponents, function (solutionComponent) {
            var solutionDef = solutionComponent.exportOptions();
            var onlyTranslations = {};
            fluid.each(solutionDef.settingsHandlers, function (settingsHandlerDef, settingsHandlerKey) {
                if (settingsHandlerDef.capabilitiesTransformations || settingsHandlerDef.inverseCapabilitiesTransformations) {
                    fluid.set(onlyTranslations, [settingsHandlerKey], fluid.filterKeys(settingsHandlerDef, ["capabilitiesTransformations", "inverseCapabilitiesTransformations"], false));
                }
            });
            fluid.set(translationsPayload, [solutionComponent.options.key], onlyTranslations);
        });

        // Output the translations to their own JSON file.
        var translationsFileName = contextFileKey + "-translations.json5";
        var translationsPath = path.resolve(resolvedOutputPath, translationsFileName);
        fs.writeFileSync(translationsPath, JSON.stringify(translationsPayload, null, 2) + "\n", { encoding: "utf8"});
    });
};

fluid.defaults("gpii.solutionsRegistry.morphicFileGenerator", {
    gradeNames: ["gpii.solutionsRegistry.live"],
    outputPath: "%solutionsRegistry/src/generated",
    fileDefs: {
        // TODO: Add linux and android if requested.
        "morphic-solutions-darwin":  "gpii.solutionsRegistry.context.darwin",
        "morphic-solutions-win32":   "gpii.solutionsRegistry.context.windows"
    },
    listeners: {
        "registryCreated.generateContextFiles": {
            funcName: "gpii.solutionsRegistry.morphicFileGenerator.generate",
            args: ["{that}"]
        }
    },
    invokers: {
        filterObject: {
            funcName: "fluid.filterKeys",
            args: ["{arguments}.0", "{that}.options.optionsToExclude", true]
        }
    }
});

gpii.solutionsRegistry.morphicFileGenerator();
