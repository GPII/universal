/* eslint-env node */
"use strict";
var fluid = require("infusion");
var gpii  = fluid.registerNamespace("gpii");

fluid.require("%kettle");
fluid.require("%gpii-json-schema");

// Add the ability to require JSON5 files.
require("json5/lib/register");

// Require universal so that we can resolve paths to it and any sub-modules.
fluid.require("%gpii-universal");

require("./filter-schema-settings");
require("./lib/get-settings-schema");

fluid.registerNamespace("gpii.universal.solutionsRegistry.requestValidation");

/**
 *
 * An invoker called on component creation that filters the "mega schema" to only validate the settings observed in the
 * request.
 *
 * @param {Object} baseSchema - The original GSS schema to filter.
 * @param {Object} req - The request object from which we extract our observed settings.
 * @param {Object} rules - Model transformation rules to use to extract the observed settings from the request.
 * @return {Object} - The filtered GSS schema.
 */
gpii.universal.solutionsRegistry.requestValidation.generateFilteredSchema = function (baseSchema, req, rules) {
    // Find the location of the settings payload using the supplied transformation rules.
    var observedSettings = fluid.model.transformWithRules(req, rules);

    // Filter the underlying schema using the derived settings.
    var filteredSchema = gpii.universal.solutionsRegistry.filterSchemaToSettings(observedSettings, baseSchema);
    return filteredSchema;
};

fluid.defaults("gpii.universal.solutionsRegistry.requestValidation.base", {
    gradeNames: ["gpii.schema.kettle.request.http"],
    mergePolicy: {
        // TODO: Discuss whether to move this up to gpii-json-schema and whether the "has query data" mix-in grade is worth preserving.
        "rules.requestContentToValidate": "nomerge",
        "rules.filterInput": "nomerge"
    },
    settingsSchemaPath: "%gpii-universal/build/schemas/settings-schema.json",
    settingsSchema: "@expand:gpii.universal.solutionsRegistry.getSettingsSchema({that}.options.settingsSchemaPath)",
    filteredSettingsSchema: "@expand:gpii.universal.solutionsRegistry.requestValidation.generateFilteredSchema({that}.options.settingsSchema, {request}.req, {that}.options.rules.filterInput)",
    rules: {
        filterInput: "{that}.options.rules.requestContentToValidate"
    },
    components: {
        validationMiddleware: {
            options: {
                inputSchema: "{gpii.universal.solutionsRegistry.requestValidation.base}.options.inputSchema"
            }
        }
    }
});

fluid.defaults("gpii.universal.solutionsRegistry.requestValidation.settings", {
    gradeNames: ["gpii.universal.solutionsRegistry.requestValidation.base"],
    rules: {
        filterInput: {
            "": "body.flat.contexts.gpii-default.preferences"
        }
    },
    inputSchema: {
        type: "object",
        properties: {
            flat: {
                type: "object",
                required: true,
                properties: {
                    contexts: {
                        type: "object",
                        required: true,
                        additionalProperties: {
                            type: "object",
                            required: true,
                            properties: {
                                settings: "{that}.options.filteredSettingsSchema"
                            }
                        }
                    }
                }
            }
        }
    }
});

fluid.defaults("gpii.universal.solutionsRegistry.requestValidation.preferences", {
    gradeNames: ["gpii.universal.solutionsRegistry.requestValidation.base"],
    rules: {
        filterInput: {
            "": {
                transform: {
                    type: "fluid.transforms.firstValue",
                    // TODO: discuss how to handle contexts other than gpii-default.
                    values: [
                        "body.contexts.gpii-default.preferences.application",
                        "body.contexts.gpii-default.preferences"
                    ]
                }
            }
        }
    },
    inputSchema: {
        type: "object",
        properties: {
            body: {
                type: "object",
                properties: {
                    contexts: {
                        type: "object",
                        required: true,
                        minProperties: 1,
                        additionalProperties: {
                            type: "object",
                            properties: {
                                metadata: {
                                    type: "array",
                                    // TODO: Once gpii-json-schema provides a cleaner means for inheriting material,
                                    // break down a "metadata item" into its own schema and inherit it here.
                                    items: {
                                        type: "object",
                                        properties: {
                                            scope: {
                                                type: "array",
                                                items: {
                                                    oneOf: [
                                                        { type: "string" },
                                                        { type: "array", items: { type: "string" } }
                                                    ]
                                                }
                                            },
                                            source: {
                                                type: "string"
                                            },
                                            type: {
                                                type: "string"
                                            }
                                        }
                                    }
                                },
                                name: {
                                    type: "string",
                                    required: true
                                },
                                preferences: {
                                    required: true,
                                    /*

                                        TODO: As we break down the structure of "viewed" preferences better, we may need
                                        to consider using `if` (to check for the presence of the view field), `then` for
                                        "viewed" preferences, and `else` for "viewless" preferences.

                                     */
                                    anyOf: [
                                        // Without a "view"
                                        "{that}.options.filteredSettingsSchema",
                                        // With a "view"
                                        {
                                            type: "object",
                                            properties: {
                                                application: "{that}.options.filteredSettingsSchema",
                                                // TODO: Break this down further.
                                                control: {
                                                    type: "object"
                                                }
                                                // TODO: look for other meaningful properties in the "view" variant.
                                            }
                                        }
                                    ]
                                }
                            }
                        }
                    }
                }
            }
        }
    }
});
