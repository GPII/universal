/* eslint-env node */
"use strict";
var fluid = require("infusion");
var gpii  = fluid.registerNamespace("gpii");

var fs    = require("fs");
var path  = require("path");

// Add the ability to require JSON5 files.
require("json5/lib/register");

// Require the base definitions for the common underlying grades used in the LSR
require("./contexts");
require("./setting");
require("./settingsHandlerHolder");
require("./solution");

// TODO: Make a context generation endpoint that returns the traditional syntax for something like win32.json.

// TODO: Figure out a sensible filtering scheme to avoid polluting the output with very low level options.

// TODO: Make a codex retrieval invoker that returns all known settings (and eventually preferences).

// A "live" solutions registry that wires together all solutions in a shared scaffold:
//
// 1. A "solutions holder" has one or more dynamic components, each of which is a solution.
// 2. Each solution has one or more dynamic components for its settings handlers.
// 3. Each settings handler (holder) has one or more settings
fluid.defaults("gpii.solutionsRegistry.live", {
    gradeNames: ["fluid.component"],
    dynamicComponents: {
        solution: {
            sources: "{that}.options.solutions",
            type: "{source}"
        }
    },
    components: {
        // // Required so that {environment} references don't bomb.
        // environment: {
        //     type: "fluid.component"
        // },
        // Required so that {session} references don't bomb.
        session: {
            type: "fluid.component"
        }
    }
});


fluid.registerNamespace("gpii.solutionsRegistry.rehydrator");

// TODO: Figure out why the second level of dynamic components isn't created.

// TODO: Make sure we aren't expanding {session} and {environment} references or otherwise corrupting the content.

// TODO: Replace this with generation functions for the codex and context (OS) files.
gpii.solutionsRegistry.inspect = function (registryComponent) {
    console.log("here we are.", registryComponent);
};

// Find all solutions and wire them into a single "solutions" option for the LSR.
gpii.solutionsRegistry.rehydrator.scan = function (that) {
    // Scan through the solutions directory registering grades
    var resolveSolutionDirPath = fluid.module.resolvePath(that.options.solutionDir);
    var namespaceDirs = fs.readdirSync(resolveSolutionDirPath);
    fluid.each(namespaceDirs, function (namespaceDir) {
        var namespaceDirPath = path.resolve(resolveSolutionDirPath, namespaceDir);
        var stats = fs.statSync(namespaceDirPath);
        if (stats.isDirectory()) {
            var namespaceFiles = fs.readdirSync(namespaceDirPath);
            fluid.each(namespaceFiles, function (filename) {
                if (path.extname(filename).match(/\.json5?$/, "i")) {
                    var defaultTypeKey = filename.split(".").slice(0,-1).join(".");
                    var filePath = path.resolve(namespaceDirPath, filename);
                    var fileContents = require(filePath);
                    var fileOptions = fluid.filterKeys(fileContents, ["type", "parents"], true);
                    fileOptions.gradeNames = fileContents.parents || ["gpii.solutionsRegistry.solution"];
                    var gradeName = fileContents.type || ([namespaceDir, defaultTypeKey].join("."));
                    fluid.defaults(gradeName, fileOptions);
                }
            });
        }
    });

    // When everything is scanned, we should be able to find all solutions using `fluid.indexDefaults`:
    //
    // https://github.com/fluid-project/infusion/blob/master/src/framework/core/js/Fluid.js#L1994
    var solutionIndexMatches = fluid.indexDefaults("solutionIndex", {
        gradeNames: ["gpii.solutionsRegistry.solution"],
        indexFunc: function (defaults) {
            return defaults.gradeNames;
        }
    });

    var solutionGrades = solutionIndexMatches["gpii.solutionsRegistry.solution"].filter(function (entry) {
        return entry !== "gpii.solutionsRegistry.solution";
    });

    // Now create the actual registry using the list of grades.
    that.events.createRegistry.fire(solutionGrades);
};

fluid.defaults("gpii.solutionsRegistry.rehydrator", {
    gradeNames: ["fluid.component"],
    solutionDir: "%gpii-universal/gpii/node_modules/solutionsRegistry/src/solutions",
    events: {
        createRegistry: null,
        registryCreated: null
    },
    dynamicComponents: {
        registry: {
            createOnEvent: "createRegistry",
            type: "gpii.solutionsRegistry.live",
            options: {
                solutions: "{arguments}.0",
                listeners: {
                    "onCreate.notifyParent": {
                        func: "{rehydrator}.events.registryCreated.fire"
                    }
                }
            }
        }
    },
    listeners: {
        "onCreate.scan": {
            funcName: "gpii.solutionsRegistry.rehydrator.scan",
            args: ["{that}"]
        },
        "registryCreated.inspect":{
            funcName: "gpii.solutionsRegistry.inspect",
            args: ["{gpii.solutionsRegistry.live}"]
        }
    }
});

gpii.solutionsRegistry.rehydrator();
