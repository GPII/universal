/*

    kettle.middleware "validators" designed to validate preference and settings payloads.

 */
/* eslint-env node */
"use strict";
var fluid = require("infusion");
var gpii  = fluid.registerNamespace("gpii");

// Add the ability to require JSON5 files, the default usage of these grades will need to have this or they will fail to
// expand the base schemas.
require("json5/lib/register");

fluid.registerNamespace("gpii.universal.solutionsRegistry.validators");

fluid.require("%gpii-json-schema");

/**
 *
 * A replacement for the default kettle validation middleware handle invokers backing function, which is more suitable
 * for working with a schema that is generated based on the payload.
 *
 * @param {gpii.universal.solutionsRegistry.validators.base} that - The validation middleware component.
 * @param {gpii.schema.validator} globalValidator - The persistent global validator component.
 * @param {kettle.request.http} requestHandler - The component fielding the individual request.
 * @return {Promise} - A `fluid.promise` that will resolve if the payload is valid or reject with errors if the payload is invalid.
 *
 */
gpii.universal.solutionsRegistry.validators.validateRequest = function (that, globalValidator, requestHandler) {
    var transformationRules = that.options.rules.outerPayload;
    var outerPayload = fluid.model.transformWithRules(requestHandler.req, transformationRules);

    var validationStages = [];

    // "gross" validation based on the overall structure
    validationStages.push(gpii.universal.solutionsRegistry.validators.singleValidation(that, globalValidator, that.options.baseSchema, outerPayload, that.options.baseSchemaHash));

    // "deep" validation of individual settings, per solution.
    var innerPayload = fluid.model.transformWithRules(requestHandler.req, that.options.rules.innerPayload);

    fluid.each(innerPayload, function (solutionPayload, solutionURI) {
        var solutionSchema = that.options.codex[solutionURI];
        if (solutionSchema) {
            if (!that.schemaHashesByUri[solutionURI]) {
                that.schemaHashesByUri[solutionURI] = gpii.schema.hashSchema(solutionSchema);
            }
            validationStages.push(gpii.universal.solutionsRegistry.validators.singleValidation(that, globalValidator, solutionSchema, solutionPayload, that.schemaHashesByUri[solutionURI]));
        }
    });

    // Although our validation is synchronous, we use this pattern so that processing will be cleanly interrupted on the
    // first validation error.
    return fluid.promise.sequence(validationStages);
};

/**
 *
 * Return a promise-returning function that represents a single attempt at validating a given payload.  Meant to be used
 * in a multi-pass validation approach with `fluid.promise.sequence`.
 *
 * @param {gpii.universal.solutionsRegistry.validators.base} validationMiddleware - The validation middleware component.
 * @param {gpii.schema.validator} globalValidator - The persistent global validator component.
 * @param {GssSchema} schema - A GSS schema.
 * @param {Any} toValidate - The payload to validate.
 * @param {String} schemaHash - A hash of the schema to use in
 * @return {Function} - A `fluid.promise` returning function.
 *
 */
gpii.universal.solutionsRegistry.validators.singleValidation = function (validationMiddleware, globalValidator, schema, toValidate, schemaHash) {
    return function () {
        var validationPromise = fluid.promise();

        var validationResults = globalValidator.validate(schema, toValidate, schemaHash);

        if (validationResults.isValid) {
            validationPromise.resolve();
        }
        else {
            var localisedErrors     = gpii.schema.validator.localiseErrors(validationResults.errors, toValidate, validationMiddleware.model.messages, validationMiddleware.options.rules.localisation);
            var localisedPayload    = fluid.copy(validationResults);
            localisedPayload.errors = localisedErrors;

            var failurePayload = fluid.extend({}, validationMiddleware.options.errorTemplate, localisedPayload);
            validationPromise.reject(failurePayload);
        }

        return validationPromise;
    };
};

fluid.defaults("gpii.universal.solutionsRegistry.validators.base", {
    gradeNames: ["kettle.middleware", "fluid.modelComponent"],
    members: {
        schemaHashesByUri: {}
    },
    model: {
        messages: gpii.schema.messages.validationErrors
    },
    errorTemplate: {
        // "Bad Request": https://developer.mozilla.org/nl/docs/Web/HTTP/Status/400
        statusCode: 400,
        message: "Your request was invalid.  See the errors for details."
    },
    mergePolicy: {
        "rules.localisation": "nomerge",
        "rules.innerPayload": "nomerge",
        "rules.outerPayload": "nomerge"
    },
    pathToSettings: "",
    codexPath: "%gpii-universal/build/schemas/solution-schema-codex.json",
    codex: "@expand:fluid.require({that}.options.codexPath)",
    baseSchemaPath: "%gpii-universal/gpii/node_modules/solutionsRegistry/src/schemas/settings-base-schema.json5",
    baseSchema: "@expand:fluid.require({that}.options.baseSchemaPath)",
    baseSchemaHash: "@expand:gpii.schema.hashSchema({that}.options.requestSchema)",
    rules: {
        localisation: {
            "": ""
        },
        outerPayload: {
            "":   "body"
        },
        innerPayload: {
            "": ""
        }
    },
    invokers: {
        handle: {
            funcName: "gpii.universal.solutionsRegistry.validators.validateRequest",
            args:    ["{that}", "{gpii.schema.validator}", "{arguments}.0"] // kettleValidator, globalValidator, request
        }
    }
});

// TODO: discuss how to handle contexts other than gpii-default in both of these stacks.

fluid.defaults("gpii.universal.solutionsRegistry.validators.settings", {
    gradeNames: ["gpii.universal.solutionsRegistry.validators.base"],
    rules: {
        innerPayload: {
            "": "body.flat.contexts.gpii-default.preferences"
        }
    }
});

fluid.defaults("gpii.universal.solutionsRegistry.requestHandlers.settings", {
    gradeNames: ["kettle.request.http"],
    requestMiddleware: {
        validate: {
            middleware: "{gpii.universal.solutionsRegistry.validators.settings}"
        }
    }
});

fluid.defaults("gpii.universal.solutionsRegistry.validators.preferences", {
    gradeNames: ["gpii.universal.solutionsRegistry.validators.base"],
    baseSchemaPath: "%gpii-universal/gpii/node_modules/solutionsRegistry/src/schemas/prefs-base-schema.json5",
    rules: {
        innerPayload: {
            "": {
                transform: {
                    type: "fluid.transforms.firstValue",
                    values: [
                        "body.contexts.gpii-default.preferences.application",
                        "body.contexts.gpii-default.preferences"
                    ]
                }
            }
        }
    }
});

fluid.defaults("gpii.universal.solutionsRegistry.requestHandlers.preferences", {
    gradeNames: ["kettle.request.http"],
    requestMiddleware: {
        validate: {
            middleware: "{gpii.universal.solutionsRegistry.validators.preferences}"
        }
    }
});
